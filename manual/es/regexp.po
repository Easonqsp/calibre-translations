# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# dario hereñu <magallania@gmail.com>, 2014
# Jellby <jellby@yahoo.com>, 2014
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-11-10 15:08+0530\n"
"PO-Revision-Date: 2014-11-10 07:27+0000\n"
"Last-Translator: dario hereñu <magallania@gmail.com>\n"
"Language-Team: Spanish (http://www.transifex.com/projects/p/calibre/language/es/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# 09cf4fa8178d495387d0e311270d8b8b
#: ../../home/kovid/work/calibre/manual/regexp.rst:4
msgid "All about using regular expressions in calibre"
msgstr "Todo acerca de cómo utilizar expresiones regulares en calibre"

# cb06f26ff6954402bfce174681c1a2ca
#: ../../home/kovid/work/calibre/manual/regexp.rst:6
msgid ""
"Regular expressions are features used in many places in calibre to perform "
"sophisticated manipulation of ebook content and metadata. This tutorial is a"
" gentle introduction to getting you started with using regular expressions "
"in calibre."
msgstr "Las expresiones regulares son funciones utilizadas en muchos lugares en calibre para llevar a cabo sofisticadas manipulaciones de contenido y metadatos de libros electrónicos. Este cursillo es una breve introducción al uso de expresiones regulares en calibre."

# 3b4e1e297c894178b4a2f0e4574d9ab7
#: ../../home/kovid/work/calibre/manual/regexp.rst:0
msgid "Contents"
msgstr "Índice"

# 76ca0b6ea63346ac88780d3da543553d
#: ../../home/kovid/work/calibre/manual/regexp.rst:14
msgid "First, a word of warning and a word of courage"
msgstr "Primero, una advertencia y unas palabras de aliento"

# 15c9c42f2f9c4e03ab5f4f91dddc32eb
#: ../../home/kovid/work/calibre/manual/regexp.rst:16
msgid ""
"This is, inevitably, going to be somewhat technical- after all, regular "
"expressions are a technical tool for doing technical stuff. I'm going to "
"have to use some jargon and concepts that may seem complicated or "
"convoluted. I'm going to try to explain those concepts as clearly as I can, "
"but really can't do without using them at all. That being said, don't be "
"discouraged by any jargon, as I've tried to explain everything new. And "
"while regular expressions themselves may seem like an arcane, black magic "
"(or, to be more prosaic, a random string of mumbo-jumbo letters and signs), "
"I promise that they are not all that complicated. Even those who understand "
"regular expressions really well have trouble reading the more complex ones, "
"but writing them isn't as difficult- you construct the expression step by "
"step. So, take a step and follow me into the rabbit hole."
msgstr "Esto, inevitablemente, va a ser un poco técnico, después de todo, las expresiones regulares son una herramienta técnica para hacer cosas técnicas. Voy a tener que usar una jerga y conceptos que pueden parecer complicados o enrevesados. Voy a tratar de explicar esos conceptos tan claramente como pueda, pero realmente no puedo hacerlo sin utilizarlos en absoluto. Dicho esto, no se desanime por la jerga según intento explicar las cosas nuevas. Y mientras que las expresiones regulares en sí pueden parecer cosa magia negra y arcana (o, siendo más prosaicos, una serie aleatoria de letras y signos sin sentido), le aseguro que no son tan complicadas. Incluso los que entienden las expresiones regulares muy bien tienen problemas para leer las más complejas, pero escribirlas no es tan difícil: se va construyendo la expresión paso a paso. Dicho esto, dé el primer paso y sígame en la madriguera."

# 02897c782da649feac76468a0114651a
#: ../../home/kovid/work/calibre/manual/regexp.rst:19
msgid "Where in calibre can you use regular expressions?"
msgstr "¿Dónde puedo utilizar expresiones regulares en calibre?"

# e9b15fce67f142fba106c452b4d5d390
#: ../../home/kovid/work/calibre/manual/regexp.rst:21
msgid ""
"There are a few places calibre uses regular expressions. There's the Search "
"& Replace in conversion options, metadata detection from filenames in the "
"import settings and Search & Replace when editing the metadata of books in "
"bulk."
msgstr "Son pocos los lugares donde calibre utiliza expresiones regulares. Están en Buscar y reemplazar en las opciones de conversión, en la detección de metadatos desde los nombres de archivo en los ajustes de importación y en Buscar & Reemplazar al editar los metadatos de los libros en forma masiva."

# a3648b03fcd2475cb4669344a7cbca6e
#: ../../home/kovid/work/calibre/manual/regexp.rst:24
msgid "What on earth *is* a regular expression?"
msgstr "¿Pero qué *es* una expresión regular?"

# 2e5b35b6a1bb4b94b60e2703a7e918aa
#: ../../home/kovid/work/calibre/manual/regexp.rst:26
msgid ""
"A regular expression is a way to describe sets of strings. A single regular "
"expression can *match* a number of different strings. This is what makes "
"regular expression so powerful -- they are a concise way of describing a "
"potentially large number of variations."
msgstr "Una expresión regular es una manera de describir conjuntos de cadenas de texto. Una sola expresión regular puede hacer *coincidir* una serie de diferentes cadenas. Esto es lo que hace tan poderosa una expresión regular - son una forma concisa de describir un número potencialmente elevado de variaciones."

# 1eb3ca2236a54048b229c721d30a29f9
#: ../../home/kovid/work/calibre/manual/regexp.rst:28
msgid ""
"I'm using string here in the sense it is used in programming languages: a "
"string of one or more characters, characters including actual characters, "
"numbers, punctuation and so-called whitespace (linebreaks, tabulators etc.)."
" Please note that generally, uppercase and lowercase characters are not "
"considered the same, thus \"a\" being a different character from \"A\" and "
"so forth. In calibre, regular expressions are case insensitive in the search"
" bar, but not in the conversion options. There's a way to make every regular"
" expression case insensitive, but we'll discuss that later. It gets "
"complicated because regular expressions allow for variations in the strings "
"it matches, so one expression can match multiple strings, which is why "
"people bother using them at all. More on that in a bit."
msgstr "Estoy usando cadena aquí en el sentido de cómo es utilizado en los lenguajes de programación: una cadena de uno o más caracteres, caracteres incluyendo caracteres reales, números, puntuacion y los llamados espacios en blanco (tabuladores, saltos de línea, etc.). Por favor, tenga en cuenta que en general, los caracteres en mayúsculas y minúsculas no se consideran iguales, por lo tanto \"a\" es  diferente de \"A\" y así sucesivamente. En calibre, las expresiones regulares no distinguen mayúsculas y minúsculas en la barra de búsqueda, pero si en las opciones de conversión. Hay una manera de hacer que todos los casos de expresiones regulares sean insensibles a las mayúsculas y minúsculas, pero hablaremos de eso más tarde. Así se complica porque las expresiones regulares permiten variaciones en las cadenas que coincide, por lo que una expresión pueden coincidir varias cadenas, y el por qué las personas se fastidian al usarlas. Más sobre esto en un momento."

# 1f0f31602ef94bf28bc53487184c8f61
#: ../../home/kovid/work/calibre/manual/regexp.rst:31
msgid "Care to explain?"
msgstr "¿Me lo puede explicar?"

# 90e484aeb81b4ef7b0e8abd4feb86f1a
#: ../../home/kovid/work/calibre/manual/regexp.rst:33
msgid ""
"Well, that's why we're here. First, this is the most important concept in "
"regular expressions: *A string by itself is a regular expression that "
"matches itself*. That is to say, if I wanted to match the string ``\"Hello, "
"World!\"`` using a regular expression, the regular expression to use would "
"be ``Hello, World!``. And yes, it really is that simple. You'll notice, "
"though, that this *only* matches the exact string ``\"Hello, World!\"``, not"
" e.g. ``\"Hello, wOrld!\"`` or ``\"hello, world!\"`` or any other such "
"variation."
msgstr "Bueno, es por eso que estamos aquí. En primer lugar, este es el concepto más importante en las expresiones regulares: *Una cadena por sí misma es una expresión regular que coincide así misma*. Es decir, si yo quería que coincida la cadena ``\"¡Hola, mundo!\"`` utilizando una expresión regular, la misma sería ``Hola, mundo!''. Y sí, realmente es así de simple. Se dará cuenta, sin embargo, que esto *sólo* coincide con la cadena exacta ``\"¡Hola, mundo!\"``, no por ejemplo ``\"¡Hola, mUndo!\"`` u ``\"hola, mundo!\"`` o cualquier otra variación."

# 0c84897902784ff4b74446fa2b00e645
#: ../../home/kovid/work/calibre/manual/regexp.rst:36
msgid "That doesn't sound too bad. What's next?"
msgstr "No suena tan mal. ¿Qué viene después?"

# c155c67628f849f18e3096862d38e6b9
#: ../../home/kovid/work/calibre/manual/regexp.rst:38
msgid ""
"Next is the beginning of the really good stuff. Remember where I said that "
"regular expressions can match multiple strings? This is were it gets a "
"little more complicated. Say, as a somewhat more practical exercise, the "
"ebook you wanted to convert had a nasty footer counting the pages, like "
"\"Page 5 of 423\". Obviously the page number would rise from 1 to 423, thus "
"you'd have to match 423 different strings, right? Wrong, actually: regular "
"expressions allow you to define sets of characters that are matched: To "
"define a set, you put all the characters you want to be in the set into "
"square brackets. So, for example, the set ``[abc]`` would match either the "
"character \"a\", \"b\" or \"c\". *Sets will always only match one of the "
"characters in the set*. They \"understand\" character ranges, that is, if "
"you wanted to match all the lower case characters, you'd use the set "
"``[a-z]`` for lower- and uppercase characters you'd use ``[a-zA-Z]`` and so "
"on. Got the idea? So, obviously, using the expression ``Page [0-9] of 423`` "
"you'd be able to match the first 9 pages, thus reducing the expressions "
"needed to three: The second expression ``Page [0-9][0-9] of 423`` would "
"match all two-digit page numbers, and I'm sure you can guess what the third "
"expression would look like. Yes, go ahead. Write it down."
msgstr "El siguiente es el principio de cosas realmente buenas. ¿Recuerda cuando dije que las expresiones regulares pueden coincidir varias cadenas? Aquí se pone un poco más complicado. Digamos, como un ejercicio un poco más práctico, el libro electrónico que quería convertir tenía un desagradable pie de página contando las páginas, como \"Página 5 de 423\". Obviamente el número de página se elevaría de  1 a 423, así que tendría que coincidir con 423 cadenas diferentes, ¿no? Equivocado: las expresiones regulares permiten definir conjuntos de caracteres que coinciden: para definir un conjunto, disponga de todos los caracteres que desea que estén en el conjunto entre corchetes. Así, por ejemplo, el conjunto ``[abc]`` coincidirían el carácter \"a\", \"b\" o \"c\". *Los conjuntos solo coincidirán uno de los caracteres del conjunto*. Ellos \"entienden\" rangos de caracteres, es decir, si se quería hacer coincidir todos los caracteres en minúsculas, tendrá que utilizar el conjunto de minúsculas ``[az]`` y para mayúsculas tendría que utilizar ``[a-zA-Z]`` y así sucesivamente. ¿Comprendido? Así, obviamente, usando la expresión ``Página [0-9] de 423`` será capaz de seleccionar las primeras 9 páginas, reduciendo así las expresiones necesarias a tres. La segunda expresión ``Página [0-9] [0-9] de 423`` hará coincidir todos los números de página de dos dígitos, y estoy seguro que puede adivinar como la tercera expresión se vería. Sí, adelante. Escríbalo."

# 6e672676cd9745c7b6b4d4cc4e1be7c3
#: ../../home/kovid/work/calibre/manual/regexp.rst:41
msgid "Hey, neat! This is starting to make sense!"
msgstr "Hey, hermano! ¡Esto está empezando a tener sentido!"

# 6d1fb58e18784a83a355d73d20f52a67
#: ../../home/kovid/work/calibre/manual/regexp.rst:43
msgid ""
"I was hoping you'd say that. But brace yourself, now it gets even better! We"
" just saw that using sets, we could match one of several characters at once."
" But you can even repeat a character or set, reducing the number of "
"expressions needed to handle the above page number example to one. Yes, ONE!"
" Excited? You should be! It works like this: Some so-called special "
"characters, \"+\", \"?\" and \"*\", *repeat the single element preceding "
"them*. (Element means either a single character, a character set, an escape "
"sequence or a group (we'll learn about those last two later)- in short, any "
"single entity in a regular expression.) These characters are called "
"wildcards or quantifiers. To be more precise, \"?\" matches *0 or 1* of the "
"preceding element, \"*\" matches *0 or more* of the preceding element and "
"\"+\" matches *1 or more* of the preceding element. A few examples: The "
"expression ``a?`` would match either \"\" (which is the empty string, not "
"strictly useful in this case) or \"a\", the expression ``a*`` would match "
"\"\", \"a\", \"aa\" or any number of a's in a row, and, finally, the "
"expression ``a+`` would match \"a\", \"aa\" or any number of a's in a row "
"(Note: it wouldn't match the empty string!). Same deal for sets: The "
"expression ``[0-9]+`` would match *every integer number there is*! I know "
"what you're thinking, and you're right: If you use that in the above case of"
" matching page numbers, wouldn't that be the single one expression to match "
"all the page numbers? Yes, the expression ``Page [0-9]+ of 423`` would match"
" every page number in that book!"
msgstr "Esperaba que dijeras eso. Pero prepárate, ahora se pone aún mejor! Acabamos de ver que el uso de conjuntos, podríamos coincidir con uno de los varios caracteres a la vez. Pero incluso se puede repetir un carácter o conjunto, reduciendo el número de expresiones necesarias para manejar el ejemplo anterior de la numeración de página a uno. Sí, ¡UNO! ¿Emocionado? Funciona así: Algunos de los así llamados caracteres especiales, \"+\", \"?\" y \"*\", *repetir el elemento único precediéndolos*. (Elemento significa ya sea un único carácter, un conjunto de caracteres, una secuencia de escape o un grupo (vamos a aprender acerca de los últimos dos más tarde) - en resumen, cualquier entidad individual en una expresión regular) Estos caracteres son llamados comodines o cuantificadores. Para ser más precisos, \"?\" coincide *0 ó 1* del elemento anterior, \"*\" coincide *0 o más* del elemento anterior y \"+\" coincide *1 o más* del elemento anterior. Unos pocos ejemplos: La expresión ``a?`` coincidiría ya sea \"\" (que es una cadena vacía, no estrictamente útil en este caso) o \"a\", la expresión ``a*`` coincidiría con \"\", \"a\", \"aa\" o cualquier número de aes seguidas, y, finalmente, la expresión ``a+`` se correspondería con \"a\", \"aa\" o cualquier número de aes seguidas (Nota: no coincidiría la cadena vacía!). Igual trato para los conjuntos. La expresión ``[0-9]+`` coincidiría *todo número entero que exista*! Sé lo que está pensando, y tienes razón: si lo utiliza en el caso anterior de números de página coincidentes, ¿no que sea la única expresión que coincide con todos los números de página? Sí, la expresión ``Página [0-9] + de 423`` se correspondería con cada número de página de ese libro!"

# 165c5517eaed4517bc5217ae5f2c3753
#: ../../home/kovid/work/calibre/manual/regexp.rst:46
msgid ""
"A note on these quantifiers: They generally try to match as much text as "
"possible, so be careful when using them. This is called \"greedy "
"behaviour\"- I'm sure you get why. It gets problematic when you, say, try to"
" match a tag. Consider, for example, the string ``\"<p "
"class=\"calibre2\">Title here</p>\"`` and let's say you'd want to match the "
"opening tag (the part between the first pair of angle brackets, a little "
"more on tags later). You'd think that the expression ``<p.*>`` would match "
"that tag, but actually, it matches the whole string! (The character \".\" is"
" another special character. It matches anything *except* linebreaks, so, "
"basically, the expression ``.*`` would match any single line you can think "
"of.) Instead, try using ``<p.*?>`` which makes the quantifier ``\"*\"`` non-"
"greedy. That expression would only match the first opening tag, as intended."
" There's actually another way to accomplish this: The expression "
"``<p[^>]*>`` will match that same opening tag- you'll see why after the next"
" section. Just note that there quite frequently is more than one way to "
"write a regular expression."
msgstr "Una nota sobre estos cuantificadores: Tratan generalmente de hacer coincidir tanto más texto como sea posible, así que tenga cuidado al usarlos. Esto se conoce como \"comportamiento codicioso\" - Estoy seguro que entiende por qué. Se vuelve problemático cuando, por ejemplo, se trata de hacer coincidir una etiqueta. Consideremos, por ejemplo, la cadena ``\"<p class=\"calibre2\">Título aquí</p>\"`` y digamos que le gustaría que coincida con la etiqueta de apertura (la parte entre el primer par de corchetes angulares, un poco más sobre las etiquetas más adelante). Se podría pensar que la expresión ``<p.*>`` se correspondería con esa etiqueta, pero en realidad, coincide toda la cadena! (El carácter \".\" es otro carácter especial. Coincide cualquier cosa *excepto* saltos de línea, por lo que, básicamente, la expresión ``.*`` se correspondería con cualquier línea que se pueda imaginar.) En su lugar, trate de usar ``<p.*?>`` lo que hace que el cuantificador ``\"*\"`` no ambicioso. Esa expresión sólo coincidiría con la primera etiqueta de apertura, como se pretende. De hecho, hay otra manera de lograr esto. La expresión ``<p[^>]*>`` coincidirá con la misma etiqueta de apertur,a verá por qué después de la siguiente sección. Tenga en cuenta que frecuentemente hay más de una manera de escribir una expresión regular."

# 7cd254b935784783ab220a032e26c0b3
#: ../../home/kovid/work/calibre/manual/regexp.rst:50
msgid ""
"Well, these special characters are very neat and all, but what if I wanted "
"to match a dot or a question mark?"
msgstr "Bien, estos caracteres especiales son perfectos, pero ¿que hay si quería que coincida con un punto o un signo de interrogación?"

# af3123f57b5e4a7fbc77f0d1c779fc09
#: ../../home/kovid/work/calibre/manual/regexp.rst:52
msgid ""
"You can of course do that: Just put a backslash in front of any special "
"character and it is interpreted as the literal character, without any "
"special meaning. This pair of a backslash followed by a single character is "
"called an escape sequence, and the act of putting a backslash in front of a "
"special character is called escaping that character. An escape sequence is "
"interpreted as a single element. There are of course escape sequences that "
"do more than just escaping special characters, for example ``\"\\t\"`` means"
" a tabulator. We'll get to some of the escape sequences later. Oh, and by "
"the way, concerning those special characters: Consider any character we "
"discuss in this introduction as having some function to be special and thus "
"needing to be escaped if you want the literal character."
msgstr "Por supuesto, puede hacer lo siguiente: solo hay que poner una barra invertida delante de cualquier carácter especial y es interpretado como un carácter literal, sin ningún significado especial. Este par de barras invertidas seguida por un solo personaje se llama una secuencia de escape, y el acto de poner una barra invertida delante de un carácter especial se llama escapando ese carácter. Una secuencia de escape se interpreta como un solo elemento. Hay, por supuesto, secuencias de escape que hacen más que sólo escapar caracteres especiales, como por ejemplo ``\"\\t\"`` significa un tabulador. Vamos a llegar a algunas de las secuencias de escape más tarde. Ah, y por cierto, en relación con esos caracteres especiales: considere a cualquier carácter que señalamos en esta introducción como poseedores de alguna función especial y por lo tanto necesita ser escapado si desea que sea un carácter literal."

# 2194474af86248b2bee9a0fcf08296e7
#: ../../home/kovid/work/calibre/manual/regexp.rst:55
msgid "So, what are the most useful sets?"
msgstr "¿Y cuáles son los conjuntos más útiles?"

# fb59ffe6777a4e2db4b69ebefa4c1771
#: ../../home/kovid/work/calibre/manual/regexp.rst:57
msgid ""
"Knew you'd ask. Some useful sets are ``[0-9]`` matching a single number, "
"``[a-z]`` matching a single lowercase letter, ``[A-Z]`` matching a single "
"uppercase letter, ``[a-zA-Z]`` matching a single letter and ``[a-zA-Z0-9]`` "
"matching a single letter or number. You can also use an escape sequence as "
"shorthand::"
msgstr "Sabía que lo preguntarías. Algunos conjuntos útiles son ``[0-9]`` donde coinciden un solo número, ``[az]`` donde coincide con una sola letra en minúscula, ``[AZ]`` donde coinciden una sola letra mayúscula, ``[a-zA-Z]`` donde coincide una sola letra y ``[a-zA-Z0-9]`` donde coincide una sola letra o  un número. También puede utilizar una secuencia de escape como taquigrafía::"

# 9e6754ceb527477d8f193c43cbe1dd36
#: ../../home/kovid/work/calibre/manual/regexp.rst:64
msgid ""
"\"Whitespace\" is a term for anything that won't be printed. These "
"characters include space, tabulator, line feed, form feed and carriage "
"return."
msgstr "\"Espacios en blanco\" es un término para cualquier cosa que no se imprime. Estos caracteres incluyen el espacio, tabulador, avance de línea, salto de página y retorno de carro."

# db5ea86e8ea74fad94559c9f4b102b37
#: ../../home/kovid/work/calibre/manual/regexp.rst:66
msgid ""
"As a last note on sets, you can also define a set as any character *but* "
"those in the set. You do that by including the character ``\"^\"`` as the "
"*very first character in the set*. Thus, ``[^a]`` would match any character "
"excluding \"a\". That's called complementing the set. Those escape sequence "
"shorthands we saw earlier can also be complemented: ``\"\\D\"`` means any "
"non-number character, thus being equivalent to ``[^0-9]``. The other "
"shorthands can be complemented by, you guessed it, using the respective "
"uppercase letter instead of the lowercase one. So, going back to the example"
" ``<p[^>]*>`` from the previous section, now you can see that the character "
"set it's using tries to match any character except for a closing angle "
"bracket."
msgstr "Como una última nota sobre los conjuntos, también puede definir un conjunto como cualquier personaje *pero* aquellos del conjunto. Lo hace al incluir el carácter ``\"^\" '' como el *primer carácter en el conjunto*. Por lo tanto, ``[^a]`` haría coincidir con cualquier carácter excluyendo \"a\". Eso se llama complementar el conjunto. Esos taquigráficas secuencias de escape que vimos anteriormente también pueden complementarse. ``\"\\D\"`` significa cualquier carácter que no sea un número, siendo por lo tanto equivalente a ``[^0-9]``. Las otras abreviaturas pueden ser complementadas por, lo has adivinado, utilizando la respectiva letra mayúscula en lugar de la minúscula. Así que, volviendo al ejemplo ``<p[^>]*>`` de la sección anterior, ahora se puede ver que el juego de caracteres está intentando coincidir con cualquier carácter excepto el corchete angular de cierre."

# b35e7af8841b44309940b6b1ae5b041f
#: ../../home/kovid/work/calibre/manual/regexp.rst:69
msgid ""
"But if I had a few varying strings I wanted to match, things get "
"complicated?"
msgstr "Pero ¿si tuviera un par de cadenas diferentes a igualar, las cosas se complican?"

# 1996d26a54c24fd49a675230b7f462dd
#: ../../home/kovid/work/calibre/manual/regexp.rst:71
msgid ""
"Fear not, life still is good and easy. Consider this example: The book "
"you're converting has \"Title\" written on every odd page and \"Author\" "
"written on every even page. Looks great in print, right? But in ebooks, it's"
" annoying. You can group whole expressions in normal parentheses, and the "
"character ``\"|\"`` will let you match *either* the expression to its right "
"*or* the one to its left. Combine those and you're done. Too fast for you? "
"Okay, first off, we group the expressions for odd and even pages, thus "
"getting ``(Title)(Author)`` as our two needed expressions. Now we make "
"things simpler by using the vertical bar (``\"|\"`` is called the vertical "
"bar character): If you use the expression ``(Title|Author)`` you'll either "
"get a match for \"Title\" (on the odd pages) or you'd match \"Author\" (on "
"the even pages). Well, wasn't that easy?"
msgstr "No temas, la vida todavía es buena y fácil. Considere este ejemplo: El libro que está convirtiendo  tiene un \"Título\" escrito en cada página impar y \"Autor\" escrito en cada página par. Luce muy bien en la impresión, ¿no? Pero en libros electrónicos, es molesto. Puede agrupar expresiones enteras en paréntesis normales, y el carácter ``\"|\"`` hará coincidir *o* la expresión a la derecha *o* el de la izquierda. Combínelas y ya está. Demasiado rápido para usted? Bueno, en primer lugar, agrupamos las expresiones para páginas pares e impares, consiguiendo de este modo ``(Título)(Autor)`` como nuestras dos expresiones necesarias. Ahora hacemos las cosas más simples mediante el uso de la barra vertical (``\"|\"`` se llama al carácter de barra vertical). Si utiliza la expresión ``(Título|Autor)`` conseguiría \"Título\" (en las páginas impares) o conseguiría \"Autor\" (en las páginas pares). Bueno, no era tan fácil?"

# 7a4437c0c9e14785a0cd4cd10fa28996
#: ../../home/kovid/work/calibre/manual/regexp.rst:73
msgid ""
"You can, of course, use the vertical bar without using grouping parentheses,"
" as well. Remember when I said that quantifiers repeat the element preceding"
" them? Well, the vertical bar works a little differently: The expression "
"\"Title|Author\" will also match either the string \"Title\" or the string "
"\"Author\", just as the above example using grouping. *The vertical bar "
"selects between the entire expression preceding and following it*. So, if "
"you wanted to match the strings \"Calibre\" and \"calibre\" and wanted to "
"select only between the upper- and lowercase \"c\", you'd have to use the "
"expression ``(c|C)alibre``, where the grouping ensures that only the \"c\" "
"will be selected. If you were to use ``c|Calibre``, you'd get a match on the"
" string \"c\" or on the string \"Calibre\", which isn't what we wanted. In "
"short: If in doubt, use grouping together with the vertical bar."
msgstr "Puede, por supuesto, usar la barra vertical sin utilizar paréntesis de agrupamiento, también. ¿Recuerdas cuando dije que los cuantificadores repiten el elemento anterior a ellos? Bueno, la barra vertical funciona un poco diferente. La expresión \"Título|Autor\" también corresponde o a la cadena \"Título\" o la cadena \"Autor\", al igual que el ejemplo anterior utilizando agrupamiento. *La barra vertical selecciona entre toda la expresión anterior y posterior a la misma*. Así que, si quiere que coincidan las cadenas \"Calibre\" y \"calibre\" y quiso seleccionar sólo entre la \"c\" mayúsculas y minúsculas, tendría que utilizar la expresión `` (c|C)alibre``, donde el agrupamiento asegura que sólo la \"c\" se seleccionará. Si va a usar ``c|Calibre``, obtendrá coincidencias con la cadena \"c\" o la cadena \"Calibre\", que no es lo que queríamos. En caso de duda, utilice el agrupamiento con la barra vertical."

# 469057254e604c1e9d3eb138519b1410
#: ../../home/kovid/work/calibre/manual/regexp.rst:76
msgid "You missed..."
msgstr "Falta algo..."

# 2a99ab9ab2be4ebca9e63f9734611acf
#: ../../home/kovid/work/calibre/manual/regexp.rst:78
msgid ""
"... wait just a minute, there's one last, really neat thing you can do with "
"groups. If you have a group that you previously matched, you can use "
"references to that group later in the expression: Groups are numbered "
"starting with 1, and you reference them by escaping the number of the group "
"you want to reference, thus, the fifth group would be referenced as ``\\5``."
" So, if you searched for ``([^ ]+) \\1`` in the string \"Test Test\", you'd "
"match the whole string!"
msgstr "...espere un minuto, hay un último asunto, cosas muy buenas se pueden hacer con los grupos. Si tiene un grupo que previamente fue coincidente, puede utilizar las referencias a ese grupo más adelante en la expresión. Los grupos se numeran comenzando por 1, y los referencia escapando por el número del grupo que desea hacer referencia, por lo tanto, el quinto grupo sería referencia como ``\\5``. Así, si buscó ``([^ ]+) \\1`` en la cadena \"Prueba Prueba\", coincidirá toda la cadena!"

# 1947faa961264629a5413187fd781f59
#: ../../home/kovid/work/calibre/manual/regexp.rst:82
msgid ""
"In the beginning, you said there was a way to make a regular expression case"
" insensitive?"
msgstr "En el inicio, ¿dijo que había una manera de hacer una especie de expresión regular que no dscrimina mayúsculas y minúsculas?"

# b001c8e17592435fbfc40215d46eac0a
#: ../../home/kovid/work/calibre/manual/regexp.rst:84
msgid ""
"Yes, I did, thanks for paying attention and reminding me. You can tell "
"calibre how you want certain things handled by using something called flags."
" You include flags in your expression by using the special construct "
"``(?flags go here)`` where, obviously, you'd replace \"flags go here\" with "
"the specific flags you want. For ignoring case, the flag is ``i``, thus you "
"include ``(?i)`` in your expression. Thus, ``test(?i)`` would match "
"\"Test\", \"tEst\", \"TEst\" and any case variation you could think of."
msgstr "Sí, lo hice, gracias por prestar atención y recordarme. Puede decirle a calibre cómo desea ciertas cosas se manejen mediante el uso de banderas. Incluya banderas en su expresión mediante el uso de construcción especial ``(?banderas van aquí)``, donde, obviamente, sustituya \"banderas van aquí\" con las banderas específicos que desea. Para ignorar caso, la bandera es ``i``, así que incluya ``(?I)`` en su expresión. Por lo tanto, ``prueba(?i)`` se correspondería con \"Prueba\", \"pRueba\", \"PRueba\" y cualquier variación en las mayúsculas y minúsculas que podría pensar."

# f8f24505d5bc4066aee8ed921088304d
#: ../../home/kovid/work/calibre/manual/regexp.rst:86
msgid ""
"Another useful flag lets the dot match any character at all, *including* the"
" newline, the flag ``s``. If you want to use multiple flags in an "
"expression, just put them in the same statement: ``(?is)`` would ignore case"
" and make the dot match all. It doesn't matter which flag you state first, "
"``(?si)`` would be equivalent to the above. By the way, good places for "
"putting flags in your expression would be either the very beginning or the "
"very end. That way, they don't get mixed up with anything else."
msgstr "Otra bandera útil le permite al punto coincidir con cualquier carácter en todo, *incluyendo* la nueva línea, la bandera ``s``. Si desea utilizar varias banderas en una expresión, sólo hay que ponerlas en la misma declaración:  ``(?is)`` ignoraría las mayúsculas y minúsculas y hacer que el punto coincida con todo. No importa cual bandera declara en primer lugar, ``(?si)`` sería equivalente a la anterior. Por cierto, buenos lugares para poner banderas en su expresión podrían ser el principio o el final. De esa manera, no se mezclan con cualquier otra cosa."

# 3ed9aab6285346c4881762cb2dfcc9db
#: ../../home/kovid/work/calibre/manual/regexp.rst:89
msgid ""
"I think I'm beginning to understand these regular expressions now... how do "
"I use them in calibre?"
msgstr "Creo que empiezo a entender esto de las expresiones regulares... ¿cómo las utilizo en calibre?"

# b92667fd7d724d838c482e3f2d9314fc
#: ../../home/kovid/work/calibre/manual/regexp.rst:92
msgid "Conversions"
msgstr "Conversiones"

# 4c92f5f2c07b403e967b3d314dd96727
#: ../../home/kovid/work/calibre/manual/regexp.rst:94
msgid ""
"Let's begin with the conversion settings, which is really neat. In the "
"Search and Replace part, you can input a regexp (short for regular "
"expression) that describes the string that will be replaced during the "
"conversion. The neat part is the wizard. Click on the wizard staff and you "
"get a preview of what calibre \"sees\" during the conversion process. Scroll"
" down to the string you want to remove, select and copy it, paste it into "
"the regexp field on top of the window. If there are variable parts, like "
"page numbers or so, use sets and quantifiers to cover those, and while "
"you're at it, remember to escape special characters, if there are some. Hit "
"the button labeled :guilabel:`Test` and calibre highlights the parts it "
"would replace were you to use the regexp. Once you're satisfied, hit OK and "
"convert. Be careful if your conversion source has tags like this example::"
msgstr "Vamos a comenzar con la configuración de conversión, lo que es realmente bueno. En la sección Buscar y reemplazar, puede introducir una expresión regular (abreviatura de expresión regular) que describe la cadena que será sustituida durante la conversión. La parte interesante es el asistente. Haga clic en el asistente personal y se obtiene una vista previa de lo que calibre \"ve\" durante el proceso de conversión. Vaya a la cadena que desea eliminar, selecciónelo y copielo, péguelo en el campo de expresión regular en la parte superior de la ventana. Si hay partes variables, como números de página o más, use conjuntos y cuantificadores para alcanzarlos, y mientras estás allí, recuerde los caracteres especiales de escape, si hay algunos. Pulse el botón con la etiqueta :guilabel:`Test` y calibre resalta las partes que reemplazaría al utilizar la expresión regular. Una vez que esté satisfecho, pulse Aceptar y se inicia el proceso de convertir. Tenga cuidado si su fuente de conversión tiene etiquetas como este ejemplo::"

# 832f8733a70a483ca3c18125aa7d2f7d
#: ../../home/kovid/work/calibre/manual/regexp.rst:104
msgid ""
"(shamelessly ripped out of `this thread "
"<http://www.mobileread.com/forums/showthread.php?t=75594\">`_). You'd have "
"to remove some of the tags as well. In this example, I'd recommend beginning"
" with the tag ``<b class=\"calibre2\">``, now you have to end with the "
"corresponding closing tag (opening tags are ``<tag>``, closing tags are "
"``</tag>``), which is simply the next ``</b>`` in this case. (Refer to a "
"good HTML manual or ask in the forum if you are unclear on this point.) The "
"opening tag can be described using ``<b.*?>``, the closing tag using "
"``</b>``, thus we could remove everything between those tags using "
"``<b.*?>.*?</b>``. But using this expression would be a bad idea, because it"
" removes everything enclosed by <b>- tags (which, by the way, render the "
"enclosed text in bold print), and it's a fair bet that we'll remove portions"
" of the book in this way. Instead, include the beginning of the enclosed "
"string as well, making the regular expression "
"``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` The ``\\s`` with"
" quantifiers are included here instead of explicitly using the spaces as "
"seen in the string to catch any variations of the string that might occur. "
"Remember to check what calibre will remove to make sure you don't remove any"
" portions you want to keep if you test a new expression. If you only check "
"one occurrence, you might miss a mismatch somewhere else in the text. Also "
"note that should you accidentally remove more or fewer tags than you "
"actually wanted to, calibre tries to repair the damaged code after doing the"
" removal."
msgstr "(descaradamente tomado de `este hilo <http://www.mobileread.com/forums/showthread.php?t=75594\"> `_). Habría que eliminar algunas de las etiquetas también. En este ejemplo, me gustaría recomendar empezando con la etiqueta ``<b class=\"calibre2\">``, ahora tiene que acabar con la etiqueta de cierre correspondiente (etiquetas de apertura son ``<tag>``, etiquetas de cierre son ``</tag>``), que es simplemente el siguiente ``</b>'' en este caso. (Consulte a un buen manual de HTML o pregunte en el foro si tiene dudas sobre este punto.) La etiqueta de apertura puede ser descrito usando ``<b.*?>``, la etiqueta de cierre usando ``</b>'', por lo que podríamos quitar todo lo que está entre estas etiquetas usando ``<b.*?>.*?</b>``. Pero usando esta expresión sería una mala idea, ya que elimina todo lo encerrado entre las etiquetas <b> (que, por cierto, hacen que el texto encerrado se vean en negrita), y es una apuesta segura que eliminaremos porciones de este libro de esta manera. En su lugar, incluya el principio de la cadena cerrada también, haciendo la expresión regular ``<b.*?>\\s*Generado\\s+por+ABC\\s+Ámbar\\s+LIT.*?</b>`` La ``\\s`` con cuantificadores se incluyen aquí en lugar de utilizar explícitamente los espacios como se ve en la cadena para atrapar cualquier variación de la cadena que pudiera ocurrir. Recuerde revisar qué eliminará calibre para asegurarse que no elimine cualquier parte que desea conservar si ensaya una nueva expresión. Si sólo examina una ocurrencia, es posible que se pierda un desajuste en otro lugar del texto. También tenga en cuenta que en caso que accidentalmente elimine algunas etiquetas de lo que realmente deseaba, calibre intenta reparar el código dañado después de hacer la eliminación."

# 007edc5637364f1b91510bec73ad4825
#: ../../home/kovid/work/calibre/manual/regexp.rst:107
msgid "Adding books"
msgstr "Añadir libros"

# 8609f664ba5d47c8b769734d2701b20d
#: ../../home/kovid/work/calibre/manual/regexp.rst:109
msgid ""
"Another thing you can use regular expressions for is to extract metadata "
"from filenames. You can find this feature in the \"Adding books\" part of "
"the settings. There's a special feature here: You can use field names for "
"metadata fields, for example ``(?P<title>)`` would indicate that calibre "
"uses this part of the string as book title. The allowed field names are "
"listed in the windows, together with another nice test field. An example: "
"Say you want to import a whole bunch of files named like ``Classical Texts: "
"The Divine Comedy by Dante Alighieri.mobi``. (Obviously, this is already in "
"your library, since we all love classical italian poetry) or ``Science "
"Fiction epics: The Foundation Trilogy by Isaac Asimov.epub``. This is "
"obviously a naming scheme that calibre won't extract any meaningful data out"
" of - its standard expression for extracting metadata is ``(?P<title>.+) - "
"(?P<author>[^_]+)``. A regular expression that works here would be "
"``[a-zA-Z]+: (?P<title>.+) by (?P<author>.+)``. Please note that, inside the"
" group for the metadata field, you need to use expressions to describe what "
"the field actually matches. And also note that, when using the test field "
"calibre provides, you need to add the file extension to your testing "
"filename, otherwise you won't get any matches at all, despite using a "
"working expression."
msgstr "También puede utilizar expresiones regulares para extraer metadatos de los nombres de archivo.  Puede encontrar esta función de \"Adición de libros\" en la sección de ajustes. Hay una característica especial: puede utilizar nombres de campo para los campos de metadatos, por ejemplo ``(?P<title>)`` que indicaría que calibre utiliza esta parte de la cadena como el título del libro. Los nombres de los campos permitidos se enumeran en las ventanas, junto con otro campo de prueba. Un ejemplo: digamos que desea importar un montón de archivos llamados así ``Textos Clásicos: La Divina Comedia de Dante Alighieri.mobi``. (Obviamente, ya está en la biblioteca, ya que a todos nos gusta la poesía italiana clásica) o `` Ciencia ficción épica: La Trilogía de la Fundación por Isaac Asimov.epub``. Esto es obviamente un esquema de nombres que calibre no va a extraer datos significativos  - la expresión estándar para la extracción de los metadatos es ``(?P<titulo>.+) - (?P<autor>[^_]+)``. Una expresión regular que funciona aquí sería ``[a-zA-Z]+: (?P<titulo>.+) by (?P<autor>.+)``. Tenga en cuenta que, dentro del grupo para el campo de metadatos, es necesario utilizar expresiones para describir lo que el campo actualmente iguala. Y también tenga en cuenta que, cuando se utiliza el campo de prueba que calibre ofrece, es necesario agregar la extensión de archivo a su nombre de archivo de prueba, de lo contrario no recibirá ninguna correspondencia en absoluto, a pesar de utilizar una expresión de trabajo."

# c9dea4b0d4f74d7eb779009fb5a5ed7f
#: ../../home/kovid/work/calibre/manual/regexp.rst:113
msgid "Bulk editing metadata"
msgstr "Edición de metadatos masiva"

# dfde42372c24400aaa6f495031c27f67
#: ../../home/kovid/work/calibre/manual/regexp.rst:115
msgid ""
"The last part is regular expression search and replace in metadata fields. "
"You can access this by selecting multiple books in the library and using "
"bulk metadata edit. Be very careful when using this last feature, as it can "
"do **Very Bad Things** to your library! Doublecheck that your expressions do"
" what you want them to using the test fields, and only mark the books you "
"really want to change! In the regular expression search mode, you can search"
" in one field, replace the text with something and even write the result "
"into another field. A practical example: Say your library contained the "
"books of Frank Herbert's Dune series, named after the fashion ``Dune 1 - "
"Dune``, ``Dune 2 - Dune Messiah`` and so on. Now you want to get ``Dune`` "
"into the series field. You can do that by searching for ``(.*?) \\d+ - .*`` "
"in the title field and replacing it with ``\\1`` in the series field. See "
"what I did there? That's a reference to the first group you're replacing the"
" series field with. Now that you have the series all set, you only need to "
"do another search for ``.*? -`` in the title field and replace it with "
"``\"\"`` (an empty string), again in the title field, and your metadata is "
"all neat and tidy. Isn't that great? By the way, instead of replacing the "
"entire field, you can also append or prepend to the field, so, if you "
"*wanted* the book title to be prepended with series info, you could do that "
"as well. As you by now have undoubtedly noticed, there's a checkbox labeled "
":guilabel:`Case sensitive`, so you won't have to use flags to select "
"behaviour here."
msgstr "La última parte es la búsqueda y reemplazo de expresiones regulares en los campos de metadatos. Puede acceder a ésta seleccionando varios libros en la biblioteca y editar metadatos masivamente. Tenga mucho cuidado al utilizar esta última característica, ya que puede hacer **cosas muy malas** en su biblioteca! Verifique que sus expresiones hacen lo que quiere que haga en los campos de prueba, y sólo marcan los libros que realmente quiere cambiar! En el modo de búsqueda de expresiones regulares, puede buscar en un campo, reemplazar el texto con algo e incluso escribir el resultado en otro campo. Un ejemplo práctico: Digamos que su biblioteca contenía los libros de la serie Dune de Frank Herbert, nombrados de este modo `` Dune 1 - Dune``, ``Dune 2 - Dune Messiah`` y así sucesivamente. Ahora desea conseguir ``Dune`` en el campo series. Puede hacerlo mediante la búsqueda ``(.*?) \\d+ - .*`` en el campo Título y reemplazando con ``\\1`` en el campo series. Ve lo que hice allí? Eso es una referencia al primer grupo que está reemplazando. Ahora que tiene toda la serie lista, sólo tiene que hacer otra búsqueda ``.*? -`` en el campo Título y reemplazarlo con ``\"\"`` (una cadena vacía), de nuevo en el campo Título, y sus metadatos están todos limpios y ordenado. ¿No es genial? Por cierto, en lugar de sustituir todo el campo, puede también añadir o anteponer al campo, por lo que, si *quería* el título del libro que se anteponga con la información de la serie, puede hacerlo también. Como sin duda se ha dado cuenta, hay una casilla etiquetada :guilabel:`Mayúsculas-minúsculas`, así no tendrá que usar marcas para seleccionar comportamientos aquí."

# 0e2b15910c5b443983ac458ad0561bcc
#: ../../home/kovid/work/calibre/manual/regexp.rst:117
msgid ""
"Well, that just about concludes the very short introduction to regular "
"expressions. Hopefully I'll have shown you enough to at least get you "
"started and to enable you to continue learning by yourself- a good starting "
"point would be the `Python documentation for regexps "
"<http://docs.python.org/library/re.html>`_."
msgstr "Bueno, casi llegamos a la conclusión de la muy breve introducción a las expresiones regulares. Esperemos que le haya mostrado lo suficiente como para, al menos, comenzar y seguir aprendiendo por sí mismo. Un buen punto de partida sería la documentación `Python para expresiones regulares <http://docs.python.org/library/re.html> `_."

# a2a13e19d54d435aab1c5e00a4fb3777
#: ../../home/kovid/work/calibre/manual/regexp.rst:119
msgid ""
"One last word of warning, though: Regexps are powerful, but also really easy"
" to get wrong. calibre provides really great testing possibilities to see if"
" your expressions behave as you expect them to. Use them. Try not to shoot "
"yourself in the foot. (God, I love that expression...) But should you, "
"despite the warning, injure your foot (or any other body parts), try to "
"learn from it."
msgstr "Una última palabra de advertencia: las expresiones regulares son poderosas, pero también es muy fácil equivocarse. calibre ofrece muy buenas posibilidades de pruebas para ver si sus expresiones se comportan como se espera que lo hagan. Úselos. Trate de dispararse los pies. (Dios, me encanta esa expresión ...) Pero en caso de que, a pesar de la advertencia, lesionar su pie (o cualquier otra parte del cuerpo), trate de aprender de ellas."

# 08ef6a0a76224118b05f6bd123399f0b
#: ../../home/kovid/work/calibre/manual/regexp.rst:122
msgid "Credits"
msgstr "Créditos"

# fc97f1995ce943b190ee4f8c7fbd746c
#: ../../home/kovid/work/calibre/manual/regexp.rst:124
msgid "Thanks for helping with tips, corrections and such:"
msgstr "Gracias por ayudar con sugerencias, correcciones y demás:"

# fedc6bac0c5947788ba013e8c5e3c9cf
#: ../../home/kovid/work/calibre/manual/regexp.rst:126
msgid "ldolse"
msgstr "ldolse"

# 755f6601a774474ab0ac9f64784e7893
#: ../../home/kovid/work/calibre/manual/regexp.rst:127
msgid "kovidgoyal"
msgstr "kovidgoyal"

# 72aa77a9f7d94158b2f06e7cbbed8f06
#: ../../home/kovid/work/calibre/manual/regexp.rst:128
msgid "chaley"
msgstr "chaley"

# ff1eba4f339b4596b060eb28c643117c
#: ../../home/kovid/work/calibre/manual/regexp.rst:129
msgid "dwanthny"
msgstr "dwanthny"

# ef2d510f20c14023b629d4d74c8c1fe0
#: ../../home/kovid/work/calibre/manual/regexp.rst:130
msgid "kacir"
msgstr "kacir"

# 14e894731bd84ef9bfae6c766c24343a
#: ../../home/kovid/work/calibre/manual/regexp.rst:131
msgid "Starson17"
msgstr "Starson17"

# 66cd9c2563bf4f74b61a302ffc2e421d
#: ../../home/kovid/work/calibre/manual/regexp.rst:133
msgid ""
"For more about regexps see `The Python User Manual "
"<http://docs.python.org/library/re.html>`_."
msgstr "Para saber más acerca de las expresiones regulares, vea `El manual de usuario de Python <http://docs.python.org/library/re.html>`_ (en inglés)."
