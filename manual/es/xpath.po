# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# dario hereñu <magallania@gmail.com>, 2014
# Jellby <jellby@yahoo.com>, 2014
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-11-06 09:51+0530\n"
"PO-Revision-Date: 2014-11-04 19:01+0000\n"
"Last-Translator: Jellby <jellby@yahoo.com>\n"
"Language-Team: Spanish (http://www.transifex.com/projects/p/calibre/language/es/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# 212dc09f9ebb4915bdbbc630a7eef129
#: ../../home/kovid/work/calibre/manual/xpath.rst:4
msgid "XPath Tutorial"
msgstr "Cursillo de XPath"

# ad0647403fe0412d834241e04a0ed655
#: ../../home/kovid/work/calibre/manual/xpath.rst:6
msgid ""
"In this tutorial, you will be given a gentle introduction to `XPath "
"<http://en.wikipedia.org/wiki/XPath>`_, a query language that can be used to"
" select arbitrary parts of `HTML <http://en.wikipedia.org/wiki/HTML>`_ "
"documents in calibre. XPath is a widely used standard, and googling it will "
"yield a ton of information. This tutorial, however, focuses on using XPath "
"for ebook related tasks like finding chapter headings in an unstructured "
"HTML document."
msgstr "En este tutorial, se le dará una pequeña introducción a `XPath <http://en.wikipedia.org/wiki/XPath>`_, un lenguaje de consulta que se puede utilizar para seleccionar partes arbitrarias de documentos `HTML <http://en.wikipedia.org/wiki/HTML>`_ en calibre. XPath es un estándar ampliamente utilizado, y buscando a través de Google se producirá una tonelada de información. Este tutorial, sin embargo, se centra en el uso de XPath para tareas relacionados con libros electrónicos, como la búsqueda de encabezados de capítulos en un documento HTML sin estructura."

# b766d6f18d01416889f19281dfec49dd
#: ../../home/kovid/work/calibre/manual/xpath.rst:0
msgid "Contents"
msgstr "Índice"

# e294b9c9f0a8455fb94e3827c5a2984b
#: ../../home/kovid/work/calibre/manual/xpath.rst:19
msgid "Selecting by tagname"
msgstr "Seleccionar por nombre de etiqueta"

# a337a2a0d01c49b8b523068d70f637d7
#: ../../home/kovid/work/calibre/manual/xpath.rst:21
msgid ""
"The simplest form of selection is to select tags by name. For example, "
"suppose you want to select all the ``<h2>`` tags in a document. The XPath "
"query for this is simply::"
msgstr "La forma más simple de selección es seleccionar las etiquetas por su nombre. Por ejemplo, suponga que desea seleccionar todas las etiquetas ``<h2>`` en un documento. La consulta XPath para esto es simplemente::"

# 665e80bcb1aa44c59f8b716159251229
#: ../../home/kovid/work/calibre/manual/xpath.rst:27
msgid ""
"The prefix `//` means *search at any level of the document*. Now suppose you"
" want to search for ``<span>`` tags that are inside ``<a>`` tags. That can "
"be achieved with::"
msgstr "El prefijo ``//` significa *buscar en cualquier nivel del documento*. Ahora suponga que desea buscar las etiquetas ``<span>`` que están dentro de las etiquetas ``<a>``. Eso se puede lograr con::"

# 329c8c2dcc424369b70adb0864cd4a70
#: ../../home/kovid/work/calibre/manual/xpath.rst:33
msgid ""
"If you want to search for tags at a particular level in the document, change"
" the prefix::"
msgstr "Si quiere buscar etiquetas en un nivel particular del documento, cambie el prefijo::"

# 422dd3c31c8040dea34b8fe1aba4d5f4
#: ../../home/kovid/work/calibre/manual/xpath.rst:39
msgid ""
"This will match only ``<p>A very short ebook to demonstrate the use of "
"XPath.</p>`` in the :ref:`sample_ebook` but not any of the other ``<p>`` "
"tags. The ``h:`` prefix in the above examples is needed to match XHTML tags."
" This is because internally, calibre represents all content as XHTML. In "
"XHTML tags have a *namespace*, and ``h:`` is the namespace prefix for HTML "
"tags."
msgstr "Esto coincidirá con sólo ``<p>Un muy breve libro electrónico para demostrar el uso de XPath.</p>`` en :ref:`sample_ebook` pero no cualquiera de las otras etiquetas ``<p>``. El prefijo ``h:``  en los ejemplos anteriores se necesita para que coincida con las etiquetas XHTML. Esto se debe a que internamente, calibre representa todo el contenido como XHTML. En las etiquetas XHTML tienen un *nombre de espacio*, y ``h:`` es el prefijo de nombres de espacio para las etiquetas HTML."

# 948bfe8cec1f4c5ead9540e4540f891b
#: ../../home/kovid/work/calibre/manual/xpath.rst:45
msgid ""
"Now suppose you want to select both ``<h1>`` and ``<h2>`` tags. To do that, "
"we need a XPath construct called *predicate*. A :dfn:`predicate` is simply a"
" test that is used to select tags. Tests can be arbitrarily powerful and as "
"this tutorial progresses, you will see more powerful examples. A predicate "
"is created by enclosing the test expression in square brackets::"
msgstr "Ahora suponga que desea seleccionar ambas etiquetas``<h1>`` y ``<h2>``. Para hacer eso, necesitamos un constructo XPath llamado *predicado*. Un :dfn:`predicate` es simplemente una prueba que se utiliza para seleccionar las etiquetas. Las pruebas pueden ser arbitrariamente poderosas y en tanto  avanza este tutorial, podrá ver ejemplos más potentes. Un predicado se crea encerrando la expresión de prueba entre corchetes::"

# 52a48f0754584b18a5f8f1b7a6820a75
#: ../../home/kovid/work/calibre/manual/xpath.rst:53
msgid ""
"There are several new features in this XPath expression. The first is the "
"use of the wildcard ``*``. It means *match any tag*. Now look at the test "
"expression ``name()='h1' or name()='h2'``. :term:`name()` is an example of a"
" *built-in function*. It simply evaluates to the name of the tag. So by "
"using it, we can select tags whose names are either `h1` or `h2`. Note that "
"the :term:`name()` function ignores namespaces so that there is no need for "
"the ``h:`` prefix. XPath has several useful built-in functions. A few more "
"will be introduced in this tutorial."
msgstr "Hay varias y nuevas características en esta expresión XPath. La primera es el uso del comodín ``*``. Significa *coincide con cualquier etiqueta*. Ahora observe la expresión de prueba ``nombre()='h1' o nombre()='h2'``. :term:`nombre()` es un ejemplo de una *función incorporada*. Simplemente evalúa el nombre de la etiqueta. Así mediante el uso de ella, podemos seleccionar etiquetas cuyos nombres son o bien `h1` o `h2`. Tenga en cuenta que la función :term:`name()` ignora los espacios de nombres de modo que no hay necesidad del prefijo ``h:``. XPath tiene varias funciones integradass. Unos pocos más serán presentadas en este tutorial."

# dad19a967af6484a9efbaf751caef695
#: ../../home/kovid/work/calibre/manual/xpath.rst:62
msgid "Selecting by attributes"
msgstr "Seleccionar por atributos"

# d81c1ba03dec49cda68d56b00bca3afd
#: ../../home/kovid/work/calibre/manual/xpath.rst:64
msgid ""
"To select tags based on their attributes, the use of predicates is "
"required::"
msgstr "Para seleccionar etiquetas en base a sus atributos, se requiere el uso de predicados::"

# 05a2c055251346c0b0c7fda9ddb0454d
#: ../../home/kovid/work/calibre/manual/xpath.rst:70
msgid ""
"Here, the ``@`` operator refers to the attributes of the tag. You can use "
"some of the `XPath built-in functions`_ to perform more sophisticated "
"matching on attribute values."
msgstr "Aquí, el operador ``@`` se refiere a los atributos de la etiqueta. Puede utilizar algunas de las `funciones incorporadas XPath`_  para realizar coincidencias más sofisticadas en los valores de los atributos."

# 341497f9dab44a52bc5791d2febe7286
#: ../../home/kovid/work/calibre/manual/xpath.rst:76
msgid "Selecting by tag content"
msgstr "Seleccionar por contenido de etiqueta"

# 87e520e5a06944f6b9e3ba63100f05b5
#: ../../home/kovid/work/calibre/manual/xpath.rst:78
msgid ""
"Using XPath, you can even select tags based on the text they contain. The "
"best way to do this is to use the power of *regular expressions* via the "
"built-in function :term:`re:test()`::"
msgstr "Utilizando XPath, puede incluso seleccionar etiquetas basadas en el texto que contienen. La mejor manera para llevarlo a cabo es usar el poder de las *expresiones regulares* via la función interna :term:`re:test()`::"

# b853ce142625451292dc8826103ddd10
#: ../../home/kovid/work/calibre/manual/xpath.rst:84
msgid ""
"Here the ``.`` operator refers to the contents of the tag, just as the ``@``"
" operator referred to its attributes."
msgstr "Aquí el operador ``.`` refiere a los contenidos de la etiqueta, tanto como el operador ``@`` se refiere a sus atributos."

# 33fbf744d38d4022998035bc200df85c
#: ../../home/kovid/work/calibre/manual/xpath.rst:90
msgid "Sample ebook"
msgstr "Libro electrónico de muestra"

# fef6f4633dbe4a17914fb3ce62a35ad2
#: ../../home/kovid/work/calibre/manual/xpath.rst:96
msgid "XPath built-in functions"
msgstr "Funciones XPath predefinidas"

# 2037710b4182487eaab98faa7e30695e
#: ../../home/kovid/work/calibre/manual/xpath.rst:99
msgid "name()"
msgstr "name()"

# 8d360ad5c536445593680d2b56f48fad
#: ../../home/kovid/work/calibre/manual/xpath.rst:101
msgid "The name of the current tag."
msgstr "El nombre de la etiqueta actual."

# dfef84cdbc504c5bb53022671c2d0019
#: ../../home/kovid/work/calibre/manual/xpath.rst:102
msgid "contains()"
msgstr "contains()"

# f6f1599891af4d058dab3743c7d30cbe
#: ../../home/kovid/work/calibre/manual/xpath.rst:104
msgid "``contains(s1, s2)`` returns `true` if s1 contains s2."
msgstr "``contains(s1, s2)`` devuelve `true` si s1 contiene s2."

# 4ff785b8315c455f94d2165854b91519
#: ../../home/kovid/work/calibre/manual/xpath.rst:105
msgid "re:test()"
msgstr "re:test()"

# fa42c9e902914add83a69b735f3b85ab
#: ../../home/kovid/work/calibre/manual/xpath.rst:107
msgid ""
"``re:test(src, pattern, flags)`` returns `true` if the string `src` matches "
"the regular expression `pattern`. A particularly useful flag is ``i``, it "
"makes matching case insensitive. A good primer on the syntax for regular "
"expressions can be found at `regexp syntax <http://docs.python.org/lib/re-"
"syntax.html>`_"
msgstr "``re:test(src, pattern, flags)`` devuelve `true` si la cadena `src` coincide con la expresión regular `pattern`. Una marca particularmente útil es ``i``, que hace que las coincidencias sean insensibles a las minúsculas y mayúsculas.. Una buena introducción en la sintaxis de las expresiones regular puede ser encontrada en `sintaxis de expresiones regulares <http://docs.python.org/lib/re-syntax.html>`_"
