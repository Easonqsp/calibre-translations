# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-07-09 09:04+0530\n"
"PO-Revision-Date: 2014-07-09 03:35+0000\n"
"Last-Translator: Kovid Goyal <kovid@kovidgoyal.net>\n"
"Language-Team: Malay (http://www.transifex.com/projects/p/calibre/language/ms/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ms\n"
"Plural-Forms: nplurals=1; plural=0;\n"

# 5db6eaa477f74891a8b53a432087c1ed
#: ../../template_ref.rst:6
msgid "Reference for all built-in template language functions"
msgstr ""

# 325ebd7c80f94a83b6c021e6e2c1eaf7
#: ../../template_ref.rst:8
msgid ""
"Here, we document all the built-in functions available in the |app| template"
" language. Every function is implemented as a class in python and you can "
"click the source links to see the source code, in case the documentation is "
"insufficient. The functions are arranged in logical groups by type."
msgstr ""

# 0f551071b63e4772af8f5ba2cce54884
#: ../../template_ref.rst:17
msgid "Arithmetic"
msgstr ""

# 4072811b67354bbeb8c6dfba6ec7c72b
#: ../../template_ref.rst:20
msgid "add(x, y)"
msgstr ""

# 73b8fe7e2af74b428a9204d815cb7a4d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAdd:1
msgid ""
"add(x, y) -- returns x + y. Throws an exception if either x or y are not "
"numbers."
msgstr ""

# 3cac2b3f013340ef9e9650d32d5fdf1a
#: ../../template_ref.rst:25
msgid "divide(x, y)"
msgstr ""

# de55cdf1a9604b93a56183ea7fa05f4c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinDivide:1
msgid ""
"divide(x, y) -- returns x / y. Throws an exception if either x or y are not "
"numbers."
msgstr ""

# b6de347ad59f4c6ab8e3ba178254d747
#: ../../template_ref.rst:30
msgid "multiply(x, y)"
msgstr ""

# 340d46aa98d94b8296fea105f34c9d69
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinMultiply:1
msgid ""
"multiply(x, y) -- returns x * y. Throws an exception if either x or y are "
"not numbers."
msgstr ""

# f8cfe60924174abfbcae6429db4bf597
#: ../../template_ref.rst:35
msgid "subtract(x, y)"
msgstr ""

# 129fa75c468f4bf78868c151a39a8de2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubtract:1
msgid ""
"subtract(x, y) -- returns x - y. Throws an exception if either x or y are "
"not numbers."
msgstr ""

# 4b87d25789aa41718b0cfb775b94558a
#: ../../template_ref.rst:40
msgid "Boolean"
msgstr ""

# e1a72f38233e486ba931860ac7d64c94
#: ../../template_ref.rst:43
msgid "and(value, value, ...)"
msgstr ""

# 5fcc68f5eeb3417c89e23856c0d913e9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAnd:1
msgid ""
"and(value, value, ...) -- returns the string \"1\" if all values are not "
"empty, otherwise returns the empty string. This function works well with "
"test or first_non_empty. You can have as many values as you want."
msgstr ""

# d937bea9f7a04c69b2c7a7e4c58d99fe
#: ../../template_ref.rst:48
msgid "not(value)"
msgstr ""

# e4edef9caf3642e5a120f8bfdf7ad371
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinNot:1
msgid ""
"not(value) -- returns the string \"1\" if the value is empty, otherwise "
"returns the empty string. This function works well with test or "
"first_non_empty. You can have as many values as you want."
msgstr ""

# 2ffcf4ea876b49f4967a3e53728d6c01
#: ../../template_ref.rst:53
msgid "or(value, value, ...)"
msgstr ""

# 00008dcf55cd4e319e4a75d7e7bb3c5c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinOr:1
msgid ""
"or(value, value, ...) -- returns the string \"1\" if any value is not empty,"
" otherwise returns the empty string. This function works well with test or "
"first_non_empty. You can have as many values as you want."
msgstr ""

# 77c882216c9e4d5aa88f8465cb6f8dd6
#: ../../template_ref.rst:58
msgid "Date functions"
msgstr ""

# 1b22ce959204423f943471374048c141
#: ../../template_ref.rst:61
msgid "days_between(date1, date2)"
msgstr ""

# ae3af79f18c943cc95de0b63195bf0f5
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinDaysBetween:1
msgid ""
"days_between(date1, date2) -- return the number of days between date1 and "
"date2. The number is positive if date1 is greater than date2, otherwise "
"negative. If either date1 or date2 are not dates, the function returns the "
"empty string."
msgstr ""

# b6eb74d8183c4343bd95c6c1e7f6c6ed
#: ../../template_ref.rst:66
msgid "today()"
msgstr ""

# beabb894be514d41ac6a1600a9550fdc
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinToday:1
msgid ""
"today() -- return a date string for today. This value is designed for use in"
" format_date or days_between, but can be manipulated like any other string. "
"The date is in ISO format."
msgstr ""

# 1ee37b68194b49fbbc68e14db742dd96
#: ../../template_ref.rst:71
msgid "Formatting values"
msgstr ""

# 42accf9d568f4065bac9160704c347d4
#: ../../template_ref.rst:74
msgid "finish_formatting(val, fmt, prefix, suffix)"
msgstr ""

# 25017d5710d847c884b8b2be486eb24d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFinishFormatting:1
msgid ""
"finish_formatting(val, fmt, prefix, suffix) -- apply the format, prefix, and"
" suffix to a value in the same way as done in a template like "
"`{series_index:05.2f| - |- }`. For example, the following program produces "
"the same output as the above template: program: "
"finish_formatting(field(\"series_index\"), \"05.2f\", \" - \", \" - \")"
msgstr ""

# e45fd7c38bb14ab49c0285f695e2ed39
#: ../../template_ref.rst:79
msgid "format_date(val, format_string)"
msgstr ""

# dfb7d6e27b814f2693d9340882584946
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatDate:1
msgid ""
"format_date(val, format_string) -- format the value, which must be a date, "
"using the format_string, returning a string. The formatting codes are: d    "
": the day as number without a leading zero (1 to 31) dd   : the day as "
"number with a leading zero (01 to 31) ddd  : the abbreviated localized day "
"name (e.g. \"Mon\" to \"Sun\"). dddd : the long localized day name (e.g. "
"\"Monday\" to \"Sunday\"). M    : the month as number without a leading zero"
" (1 to 12). MM   : the month as number with a leading zero (01 to 12) MMM  :"
" the abbreviated localized month name (e.g. \"Jan\" to \"Dec\"). MMMM : the "
"long localized month name (e.g. \"January\" to \"December\"). yy   : the "
"year as two digit number (00 to 99). yyyy : the year as four digit number. h"
"    : the hours without a leading 0 (0 to 11 or 0 to 23, depending on am/pm)"
" hh   : the hours with a leading 0 (00 to 11 or 00 to 23, depending on "
"am/pm) m    : the minutes without a leading 0 (0 to 59) mm   : the minutes "
"with a leading 0 (00 to 59) s    : the seconds without a leading 0 (0 to 59)"
" ss   : the seconds with a leading 0 (00 to 59) ap   : use a 12-hour clock "
"instead of a 24-hour clock, with \"ap\" replaced by the localized string for"
" am or pm AP   : use a 12-hour clock instead of a 24-hour clock, with \"AP\""
" replaced by the localized string for AM or PM iso  : the date with time and"
" timezone. Must be the only format present"
msgstr ""

# e46f7c184d0a4139ae897232ab6e1d5d
#: ../../template_ref.rst:84
msgid "format_number(v, template)"
msgstr ""

# 97de902e906341f692348e3c91ab4358
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatNumber:1
msgid ""
"format_number(v, template) -- format the number v using a python formatting "
"template such as \"{0:5.2f}\" or \"{0:,d}\" or \"${0:5,.2f}\". The "
"field_name part of the template must be a 0 (zero) (the \"{0:\" in the above"
" examples). See the template language and python documentation for more "
"examples. Returns the empty string if formatting fails."
msgstr ""

# 484afcf0069c4bd8a7d05d77a908d071
#: ../../template_ref.rst:89
msgid "human_readable(v)"
msgstr ""

# a16e871d64704f5fa8b221d809bc56a2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinHumanReadable:1
msgid ""
"human_readable(v) -- return a string representing the number v in KB, MB, "
"GB, etc."
msgstr ""

# b0b49a2f986f4c47908058ec093c9676
#: ../../template_ref.rst:94
msgid "Get values from metadata"
msgstr ""

# 2c71ca41c3754c4f820b4e27df4c4b7b
#: ../../template_ref.rst:97
msgid "approximate_formats()"
msgstr ""

# e4d8e25567f94c22be89118ec73861f9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinApproximateFormats:1
msgid ""
"approximate_formats() -- return a comma-separated list of formats that at "
"one point were associated with the book. There is no guarantee that this "
"list is correct, although it probably is. This function can be called in "
"template program mode using the template \"{:'approximate_formats()'}\". "
"Note that format names are always uppercase, as in EPUB. This function works"
" only in the GUI. If you want to use these values in save-to-disk or send-"
"to-device templates then you must make a custom \"Column built from other "
"columns\", use the function in that column's template, and use that column's"
" value in your save/send templates"
msgstr ""

# 932a0f8697034a4f81688e435f2b6327
#: ../../template_ref.rst:102
msgid "booksize()"
msgstr ""

# 2364e1c418b44790adf1a02603f48eec
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinBooksize:1
msgid ""
"booksize() -- return value of the size field. This function works only in "
"the GUI. If you want to use this value in save-to-disk or send-to-device "
"templates then you must make a custom \"Column built from other columns\", "
"use the function in that column's template, and use that column's value in "
"your save/send templates"
msgstr ""

# f32f8a6c07f74dfc8939e52d5aa5f29e
#: ../../template_ref.rst:107
msgid "current_library_name()"
msgstr ""

# d65d1062a419486c8ed5a6b3a8de3d04
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCurrentLibraryName:1
msgid ""
"current_library_name() -- return the last name on the path to the current "
"calibre library. This function can be called in template program mode using "
"the template \"{:'current_library_name()'}\"."
msgstr ""

# 0ffc5e84be894cbc9a1c2b7e89aa56f4
#: ../../template_ref.rst:112
msgid "current_library_path()"
msgstr ""

# de91e725431f429eb513b032189738db
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCurrentLibraryPath:1
msgid ""
"current_library_path() -- return the path to the current calibre library. "
"This function can be called in template program mode using the template "
"\"{:'current_library_path()'}\"."
msgstr ""

# 68968e68c555431fb0dbb6c7c8e9a618
#: ../../template_ref.rst:117
msgid "field(name)"
msgstr ""

# a7f0972b583f469eb997afa72d444b92
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinField:1
msgid "field(name) -- returns the metadata field named by name"
msgstr ""

# b746df357ff345d191870cabb8c2f6e2
#: ../../template_ref.rst:122
msgid "formats_modtimes(date_format)"
msgstr ""

# a0d0e1f21e88478ea4834618bf2d737a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsModtimes:1
msgid ""
"formats_modtimes(date_format) -- return a comma-separated list of "
"colon_separated items representing modification times for the formats of a "
"book. The date_format parameter specifies how the date is to be formatted. "
"See the date_format function for details. You can use the select function to"
" get the mod time for a specific format. Note that format names are always "
"uppercase, as in EPUB."
msgstr ""

# 9077850949ea4be0ba67b2025742e239
#: ../../template_ref.rst:127
msgid "formats_paths()"
msgstr ""

# fe87ef09146f445cbc6e12abc723f280
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsPaths:1
msgid ""
"formats_paths() -- return a comma-separated list of colon_separated items "
"representing full path to the formats of a book. You can use the select "
"function to get the path for a specific format. Note that format names are "
"always uppercase, as in EPUB."
msgstr ""

# d0c59429d56c4281a0b3353bd197142a
#: ../../template_ref.rst:132
msgid "formats_sizes()"
msgstr ""

# e105ede5fbee4e85839525a1076fde49
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsSizes:1
msgid ""
"formats_sizes() -- return a comma-separated list of colon_separated items "
"representing sizes in bytes of the formats of a book. You can use the select"
" function to get the size for a specific format. Note that format names are "
"always uppercase, as in EPUB."
msgstr ""

# 36c71158f79f4510b95d5e565901c640
#: ../../template_ref.rst:137
msgid "has_cover()"
msgstr ""

# 191498a940e54419b9e5f483bb8fc22f
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinHasCover:1
msgid ""
"has_cover() -- return Yes if the book has a cover, otherwise return the "
"empty string"
msgstr ""

# d64e4c7a37ad44c0905657ede7d6125e
#: ../../template_ref.rst:142
msgid "language_codes(lang_strings)"
msgstr ""

# e482f6bc14fd4e8eb9ef0b8b8f0c1d0b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLanguageCodes:1
msgid ""
"language_codes(lang_strings) -- return the language codes for the strings "
"passed in lang_strings. The strings must be in the language of the current "
"locale. Lang_strings is a comma-separated list."
msgstr ""

# c48ca973579440cc9e5414c985ddf9aa
#: ../../template_ref.rst:147
msgid "language_strings(lang_codes, localize)"
msgstr ""

# eedc981e45524cea87edb98ef1eefc2f
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLanguageStrings:1
msgid ""
"language_strings(lang_codes, localize) -- return the strings for the "
"language codes passed in lang_codes. If localize is zero, return the strings"
" in English. If localize is not zero, return the strings in the language of "
"the current locale. Lang_codes is a comma-separated list."
msgstr ""

# ffe62ce8f9494927a14835b07912f14d
#: ../../template_ref.rst:152
msgid "ondevice()"
msgstr ""

# 34ec4418816a45db99f8a42367c65a05
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinOndevice:1
msgid ""
"ondevice() -- return Yes if ondevice is set, otherwise return the empty "
"string. This function works only in the GUI. If you want to use this value "
"in save-to-disk or send-to-device templates then you must make a custom "
"\"Column built from other columns\", use the function in that column's "
"template, and use that column's value in your save/send templates"
msgstr ""

# f060524b57b149cea825f3a61cdde037
#: ../../template_ref.rst:157
msgid "raw_field(name)"
msgstr ""

# f05a08146c4d46dca7303268d1cf79b3
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinRawField:1
msgid ""
"raw_field(name) -- returns the metadata field named by name without applying"
" any formatting."
msgstr ""

# 18b48053c3c74b4cac1599ec78c4a19f
#: ../../template_ref.rst:162
msgid "series_sort()"
msgstr ""

# 0fea0c3347744f54aacd97538651ace0
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSeriesSort:1
msgid "series_sort() -- return the series sort value"
msgstr ""

# bff6add2815245f88b218bb8453c3f42
#: ../../template_ref.rst:167
msgid "virtual_libraries()"
msgstr ""

# d2bc42d5a84c4e23a169f21bb3462df0
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinVirtualLibraries:1
msgid ""
"virtual_libraries() -- return a comma-separated list of virtual libraries "
"that contain this book. This function works only in the GUI. If you want to "
"use these values in save-to-disk or send-to-device templates then you must "
"make a custom \"Column built from other columns\", use the function in that "
"column's template, and use that column's value in your save/send templates"
msgstr ""

# 8f6537f3f3284974bb77475d5a91dc1b
#: ../../template_ref.rst:172
msgid "If-then-else"
msgstr ""

# a8e6e3b65cd94a8db340cc76a3e65f4c
#: ../../template_ref.rst:175
msgid "contains(val, pattern, text if match, text if not match)"
msgstr ""

# 5553a9ef6dec450494dff0a29122236d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinContains:1
msgid ""
"contains(val, pattern, text if match, text if not match) -- checks if field "
"contains matches for the regular expression `pattern`. Returns `text if "
"match` if matches are found, otherwise it returns `text if no match`"
msgstr ""

# aaeead6e09a94675a792fe75bdd615b2
#: ../../template_ref.rst:180
msgid "ifempty(val, text if empty)"
msgstr ""

# 0af69c12eb874803babe46d344c16942
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinIfempty:1
msgid ""
"ifempty(val, text if empty) -- return val if val is not empty, otherwise "
"return `text if empty`"
msgstr ""

# d79472ddd090428ca86efc8b4a4eb22b
#: ../../template_ref.rst:185
msgid "test(val, text if not empty, text if empty)"
msgstr ""

# 3eafbd5098734444ae2c06de48c10ba0
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTest:1
msgid ""
"test(val, text if not empty, text if empty) -- return `text if not empty` if"
" the field is not empty, otherwise return `text if empty`"
msgstr ""

# 11b1147864924bb7a4e63a144f45e24b
#: ../../template_ref.rst:190
msgid "Iterating over values"
msgstr ""

# 49a8818e119240eaa4b1a64cbc0926de
#: ../../template_ref.rst:193
msgid "first_non_empty(value, value, ...)"
msgstr ""

# 803538a635c54965a1704a8debfb0c59
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFirstNonEmpty:1
msgid ""
"first_non_empty(value, value, ...) -- returns the first value that is not "
"empty. If all values are empty, then the empty value is returned. You can "
"have as many values as you want."
msgstr ""

# 80bb91d306a64ef9b13b29e015ba59b0
#: ../../template_ref.rst:198
msgid "lookup(val, pattern, field, pattern, field, ..., else_field)"
msgstr ""

# 2e7a3bc7b9d44797bba438924b32d4ea
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLookup:1
msgid ""
"lookup(val, pattern, field, pattern, field, ..., else_field) -- like switch,"
" except the arguments are field (metadata) names, not text. The value of the"
" appropriate field will be fetched and used. Note that because composite "
"columns are fields, you can use this function in one composite field to use "
"the value of some other composite field. This is extremely useful when "
"constructing variable save paths"
msgstr ""

# 83bb51470e7d4007963b2e72eac644d7
#: ../../template_ref.rst:203
msgid "switch(val, pattern, value, pattern, value, ..., else_value)"
msgstr ""

# 8eadd0227c0f42d29ff4ae61bc9a08d1
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSwitch:1
msgid ""
"switch(val, pattern, value, pattern, value, ..., else_value) -- for each "
"`pattern, value` pair, checks if the field matches the regular expression "
"`pattern` and if so, returns that `value`. If no pattern matches, then "
"else_value is returned. You can have as many `pattern, value` pairs as you "
"want"
msgstr ""

# 1271d19e423343f0a61adc712a97482d
#: ../../template_ref.rst:208
msgid "List lookup"
msgstr ""

# c14cf9af4b954d4c84375f762a159dd3
#: ../../template_ref.rst:211
msgid "identifier_in_list(val, id, found_val, not_found_val)"
msgstr ""

# 97fd250f5fce4999b0c45e928a854498
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinIdentifierInList:1
msgid ""
"identifier_in_list(val, id, found_val, not_found_val) -- treat val as a list"
" of identifiers separated by commas, comparing the string against each value"
" in the list. An identifier has the format \"identifier:value\". The id "
"parameter should be either \"id\" or \"id:regexp\". The first case matches "
"if there is any identifier with that id. The second case matches if the "
"regexp matches the identifier's value. If there is a match, return "
"found_val, otherwise return not_found_val."
msgstr ""

# cd11b6b2abc4474dab780a694f92c516
#: ../../template_ref.rst:216
msgid "in_list(val, separator, pattern, found_val, not_found_val)"
msgstr ""

# f65411249acc4fb68901d4a3d6fc2da1
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinInList:1
msgid ""
"in_list(val, separator, pattern, found_val, not_found_val) -- treat val as a"
" list of items separated by separator, comparing the pattern against each "
"value in the list. If the pattern matches a value, return found_val, "
"otherwise return not_found_val."
msgstr ""

# cf0070dab1084f87b4b6d1fc95c22013
#: ../../template_ref.rst:221
msgid "list_item(val, index, separator)"
msgstr ""

# 38b10e8925b543c1b0d6a3e0362b6f2d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListitem:1
msgid ""
"list_item(val, index, separator) -- interpret the value as a list of items "
"separated by `separator`, returning the `index`th item. The first item is "
"number zero. The last item can be returned using `list_item(-1,separator)`. "
"If the item is not in the list, then the empty value is returned. The "
"separator has the same meaning as in the count function."
msgstr ""

# c99302a3af0742ffaa2033df572242e8
#: ../../template_ref.rst:226
msgid "select(val, key)"
msgstr ""

# ca683a5014a540bf915475baa6b4175c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSelect:1
msgid ""
"select(val, key) -- interpret the value as a comma-separated list of items, "
"with the items being \"id:value\". Find the pair with the id equal to key, "
"and return the corresponding value."
msgstr ""

# 890243ba9cc14b4884a329fcdfcb318e
#: ../../template_ref.rst:231
msgid "str_in_list(val, separator, string, found_val, not_found_val)"
msgstr ""

# fed4e0e02cc841508605b9fc6047ed85
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrInList:1
msgid ""
"str_in_list(val, separator, string, found_val, not_found_val) -- treat val "
"as a list of items separated by separator, comparing the string against each"
" value in the list. If the string matches a value, return found_val, "
"otherwise return not_found_val. If the string contains separators, then it "
"is also treated as a list and each value is checked."
msgstr ""

# 7c67a57358434c16bc75d47ac6f7e3f0
#: ../../template_ref.rst:236
msgid "List manipulation"
msgstr ""

# 6c9573ca3f1d4117ad2f5ea960db0998
#: ../../template_ref.rst:239
msgid "count(val, separator)"
msgstr ""

# 3669728bf0e54c6b80b246fc6207a529
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCount:1
msgid ""
"count(val, separator) -- interprets the value as a list of items separated "
"by `separator`, returning the number of items in the list. Most lists use a "
"comma as the separator, but authors uses an ampersand. Examples: "
"{tags:count(,)}, {authors:count(&)}"
msgstr ""

# 3f3cd6ec344f46e0965508bc8b19c326
#: ../../template_ref.rst:244
msgid "list_difference(list1, list2, separator)"
msgstr ""

# e4f89ca83e6a40a28a9246e1c037b4f2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListDifference:1
msgid ""
"list_difference(list1, list2, separator) -- return a list made by removing "
"from list1 any item found in list2, using a case-insensitive compare. The "
"items in list1 and list2 are separated by separator, as are the items in the"
" returned list."
msgstr ""

# 0ef45b454f784f0994db5ab86bd06c4d
#: ../../template_ref.rst:249
msgid "list_equals(list1, sep1, list2, sep2, yes_val, no_val)"
msgstr ""

# ede93ae7460841ed92d0e554aa24c085
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListEquals:1
msgid ""
"list_equals(list1, sep1, list2, sep2, yes_val, no_val) -- return yes_val if "
"list1 and list2 contain the same items, otherwise return no_val. The items "
"are determined by splitting each list using the appropriate separator "
"character (sep1 or sep2). The order of items in the lists is not relevant. "
"The compare is case insensitive."
msgstr ""

# 47b4dd1f968d445e97d1ccd45523e80a
#: ../../template_ref.rst:254
msgid "list_intersection(list1, list2, separator)"
msgstr ""

# d4fa125dc0494a489462f7e6a4b1fb62
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListIntersection:1
msgid ""
"list_intersection(list1, list2, separator) -- return a list made by removing"
" from list1 any item not found in list2, using a case-insensitive compare. "
"The items in list1 and list2 are separated by separator, as are the items in"
" the returned list."
msgstr ""

# 50bb14f0c0e640ccbc6331e8c81a9108
#: ../../template_ref.rst:259
msgid "list_re(src_list, separator, include_re, opt_replace)"
msgstr ""

# 16dca3bcce4d48199f26cd8d7976ac45
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListRe:1
msgid ""
"list_re(src_list, separator, include_re, opt_replace) -- Construct a list by"
" first separating src_list into items using the separator character. For "
"each item in the list, check if it matches include_re. If it does, then add "
"it to the list to be returned. If opt_replace is not the empty string, then "
"apply the replacement before adding the item to the returned list."
msgstr ""

# fd1a201b88e64b89b37e82e4466bcade
#: ../../template_ref.rst:264
msgid ""
"list_re_group(src_list, separator, include_re, search_re, group_1_template, "
"...)"
msgstr ""

# b2666dd645b1492f9a1875c03b97b246
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListReGroup:1
msgid ""
"list_re_group(src_list, separator, include_re, search_re, group_1_template, "
"...) -- Like list_re except replacements are not optional. It uses "
"re_group(list_item, search_re, group_1_template, ...) when doing the "
"replacements on the resulting list."
msgstr ""

# 8070e07cecb246468efc9af64ae63d97
#: ../../template_ref.rst:269
msgid "list_sort(list, direction, separator)"
msgstr ""

# 6c2ee9a4028e4b339c6d2d42a8af0b66
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListSort:1
msgid ""
"list_sort(list, direction, separator) -- return list sorted using a case-"
"insensitive sort. If direction is zero, the list is sorted ascending, "
"otherwise descending. The list items are separated by separator, as are the "
"items in the returned list."
msgstr ""

# 45c045a6533e469f8ae3abcc53015dbc
#: ../../template_ref.rst:274
msgid "list_union(list1, list2, separator)"
msgstr ""

# d75fb810835049c0a8ff02b55ef9f45c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListUnion:1
msgid ""
"list_union(list1, list2, separator) -- return a list made by merging the "
"items in list1 and list2, removing duplicate items using a case-insensitive "
"compare. If items differ in case, the one in list1 is used. The items in "
"list1 and list2 are separated by separator, as are the items in the returned"
" list."
msgstr ""

# 17ec566c94e645e7b79f93f809c51c96
#: ../../template_ref.rst:279
msgid "subitems(val, start_index, end_index)"
msgstr ""

# 52cdb7e40d154e09a60e0b0a20ac21d8
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubitems:1
msgid ""
"subitems(val, start_index, end_index) -- This function is used to break "
"apart lists of items such as genres. It interprets the value as a comma-"
"separated list of items, where each item is a period-separated list. Returns"
" a new list made by first finding all the period-separated items, then for "
"each such item extracting the `start_index` to the `end_index` components, "
"then combining the results back together. The first component in a period-"
"separated list has an index of zero. If an index is negative, then it counts"
" from the end of the list. As a special case, an end_index of zero is "
"assumed to be the length of the list. Example using basic template mode and "
"assuming a #genre value of \"A.B.C\": {#genre:subitems(0,1)} returns \"A\". "
"{#genre:subitems(0,2)} returns \"A.B\". {#genre:subitems(1,0)} returns "
"\"B.C\". Assuming a #genre value of \"A.B.C, D.E.F\", {#genre:subitems(0,1)}"
" returns \"A, D\". {#genre:subitems(0,2)} returns \"A.B, D.E\""
msgstr ""

# 473509b1433c4873b0a8ef5e4a2258c6
#: ../../template_ref.rst:284
msgid "sublist(val, start_index, end_index, separator)"
msgstr ""

# 993d6f210f8f4a3b98df74aa1fa66d5b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSublist:1
msgid ""
"sublist(val, start_index, end_index, separator) -- interpret the value as a "
"list of items separated by `separator`, returning a new list made from the "
"`start_index` to the `end_index` item. The first item is number zero. If an "
"index is negative, then it counts from the end of the list. As a special "
"case, an end_index of zero is assumed to be the length of the list. Examples"
" using basic template mode and assuming that the tags column (which is "
"comma-separated) contains \"A, B, C\": {tags:sublist(0,1,\\,)} returns "
"\"A\". {tags:sublist(-1,0,\\,)} returns \"C\". {tags:sublist(0,-1,\\,)} "
"returns \"A, B\"."
msgstr ""

# f074723f8af44962ad4fbd8457056e92
#: ../../template_ref.rst:289
msgid "Other"
msgstr ""

# 1beda48caf0449dca4d29acd15781f15
#: ../../template_ref.rst:292
msgid "assign(id, val)"
msgstr ""

# fd1a666927244ccdbee8a22792d88786
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAssign:1
msgid ""
"assign(id, val) -- assigns val to id, then returns val. id must be an "
"identifier, not an expression"
msgstr ""

# 1b0a3a1155574fa1bf4bffb7142923e1
#: ../../template_ref.rst:297
msgid "print(a, b, ...)"
msgstr ""

# e7bad9390ea54f528c3ca283fed7aa2c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinPrint:1
msgid ""
"print(a, b, ...) -- prints the arguments to standard output. Unless you "
"start calibre from the command line (calibre-debug -g), the output will go "
"to a black hole."
msgstr ""

# b53917a7c5c74ec995c0231a1e08d7f0
#: ../../template_ref.rst:302
msgid "Recursion"
msgstr ""

# 15b177d597364123b16c64522aefa3d5
#: ../../template_ref.rst:305
msgid "eval(template)"
msgstr ""

# 5a5e033f716547d7af77bbde9685012e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinEval:1
msgid ""
"eval(template) -- evaluates the template, passing the local variables (those"
" 'assign'ed to) instead of the book metadata.  This permits using the "
"template processor to construct complex results from local variables. "
"Because the { and } characters are special, you must use [[ for the { "
"character and ]] for the } character; they are converted automatically. Note"
" also that prefixes and suffixes (the `|prefix|suffix` syntax) cannot be "
"used in the argument to this function when using template program mode."
msgstr ""

# 6e9f5d5b20dc436c93314cfa29deca3e
#: ../../template_ref.rst:310
msgid "template(x)"
msgstr ""

# 06fa3480aaea4b7aa17af973fc9d5bea
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTemplate:1
msgid ""
"template(x) -- evaluates x as a template. The evaluation is done in its own "
"context, meaning that variables are not shared between the caller and the "
"template evaluation. Because the { and } characters are special, you must "
"use [[ for the { character and ]] for the } character; they are converted "
"automatically. For example, template('[[title_sort]]') will evaluate the "
"template {title_sort} and return its value. Note also that prefixes and "
"suffixes (the `|prefix|suffix` syntax) cannot be used in the argument to "
"this function when using template program mode."
msgstr ""

# 3f0c98ed4c484241bedc8be59444c9d8
#: ../../template_ref.rst:315
msgid "Relational"
msgstr ""

# f72b3265fb7b4fb581be21b0a26fee2e
#: ../../template_ref.rst:318
msgid "cmp(x, y, lt, eq, gt)"
msgstr ""

# 3963c8d2f508420db9a0c18fcfaa2bcd
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCmp:1
msgid ""
"cmp(x, y, lt, eq, gt) -- compares x and y after converting both to numbers. "
"Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr ""

# 369654cee0034b34b3feeb6375e89f06
#: ../../template_ref.rst:323
msgid "first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result)"
msgstr ""

# 542e8e73a4774c098378e6d3deaea27d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFirstMatchingCmp:1
msgid ""
"first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result) -- "
"compares \"val < cmpN\" in sequence, returning resultN for the first "
"comparison that succeeds. Returns else_result if no comparison succeeds. "
"Example: "
"first_matching_cmp(10,5,\"small\",10,\"middle\",15,\"large\",\"giant\") "
"returns \"large\". The same example with a first value of 16 returns "
"\"giant\"."
msgstr ""

# a196a747f72c48c691a3c4e06ba5d299
#: ../../template_ref.rst:328
msgid "strcmp(x, y, lt, eq, gt)"
msgstr ""

# ba58fa593f194f049c18f72b5b91412a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcmp:1
msgid ""
"strcmp(x, y, lt, eq, gt) -- does a case-insensitive comparison of x and y as"
" strings. Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr ""

# 2b520817ceed45639e293c3504b4c59f
#: ../../template_ref.rst:333
msgid "String case changes"
msgstr ""

# f5f6d9bcab2a4bc3a7d21fa111f5ab7a
#: ../../template_ref.rst:336
msgid "capitalize(val)"
msgstr ""

# 198424afbfb54f63836f893195782da8
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCapitalize:1
msgid "capitalize(val) -- return value of the field capitalized"
msgstr ""

# 1fbe8194ad02469bb53dfb246d251c07
#: ../../template_ref.rst:341
msgid "lowercase(val)"
msgstr ""

# 45df15a40b6e455ebffa2cbc6e3b4fce
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLowercase:1
msgid "lowercase(val) -- return value of the field in lower case"
msgstr ""

# 8e37ad28097f4c19ae7f9be9c16ff8e5
#: ../../template_ref.rst:346
msgid "titlecase(val)"
msgstr ""

# 1147440c0f1c4222a7cc866394f4b431
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTitlecase:1
msgid "titlecase(val) -- return value of the field in title case"
msgstr ""

# b444256cec734b3c9ccedd463af94256
#: ../../template_ref.rst:351
msgid "uppercase(val)"
msgstr ""

# e9ca1cf188e94ed6bff719c34a15775e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinUppercase:1
msgid "uppercase(val) -- return value of the field in upper case"
msgstr ""

# 1799ee17b7fa463a9e7f75ecdc7298a2
#: ../../template_ref.rst:356
msgid "String manipulation"
msgstr ""

# bbed61f664d1411490247b2b9b7b7e2a
#: ../../template_ref.rst:359
msgid "re(val, pattern, replacement)"
msgstr ""

# 590528d7df1f47e68d411c4893c7c6af
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinRe:1
msgid ""
"re(val, pattern, replacement) -- return the field after applying the regular"
" expression. All instances of `pattern` are replaced with `replacement`. As "
"in all of calibre, these are python-compatible regular expressions"
msgstr ""

# 3a0df4da798f4d0ba1f777e4ccf14ed6
#: ../../template_ref.rst:364
msgid "re_group(val, pattern, template_for_group_1, for_group_2, ...)"
msgstr ""

# 002313cfe7f745d498b1de23d0f2566a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinReGroup:1
msgid ""
"re_group(val, pattern, template_for_group_1, for_group_2, ...) -- return a "
"string made by applying the reqular expression pattern to the val and "
"replacing each matched instance with the string computed by replacing each "
"matched group by the value returned by the corresponding template. The "
"original matched value for the group is available as $. In template program "
"mode, like for the template and the eval functions, you use [[ for { and ]] "
"for }. The following example in template program mode looks for series with "
"more than one word and uppercases the first word: {series:'re_group($, "
"\"(\\S* )(.*)\", \"[[$:uppercase()]]\", \"[[$]]\")'}"
msgstr ""

# e78b91c2bbc2477291c9be8ba3eb81c6
#: ../../template_ref.rst:369
msgid "shorten(val, left chars, middle text, right chars)"
msgstr ""

# 1e5ec41014ba444bb21023756334791c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinShorten:1
msgid ""
"shorten(val, left chars, middle text, right chars) -- Return a shortened "
"version of the field, consisting of `left chars` characters from the "
"beginning of the field, followed by `middle text`, followed by `right chars`"
" characters from the end of the string. `Left chars` and `right chars` must "
"be integers. For example, assume the title of the book is `Ancient English "
"Laws in the Times of Ivanhoe`, and you want it to fit in a space of at most "
"15 characters. If you use {title:shorten(9,-,5)}, the result will be "
"`Ancient E-nhoe`. If the field's length is less than left chars + right "
"chars + the length of `middle text`, then the field will be used intact. For"
" example, the title `The Dome` would not be changed."
msgstr ""

# e5187f0a31b2407693f8e3d896896cb2
#: ../../template_ref.rst:374
msgid "strcat(a, b, ...)"
msgstr ""

# 30b2c10900f6486f8edb6a5bbe4943b9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcat:1
msgid ""
"strcat(a, b, ...) -- can take any number of arguments. Returns a string "
"formed by concatenating all the arguments"
msgstr ""

# b80cd10326fb47f3930fa3d818ece14a
#: ../../template_ref.rst:379
msgid "strcat_max(max, string1, prefix2, string2, ...)"
msgstr ""

# 6a950d5fdc14468fb1108e271ef3250c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcatMax:1
msgid ""
"strcat_max(max, string1, prefix2, string2, ...) -- Returns a string formed "
"by concatenating the arguments. The returned value is initialized to "
"string1. `Prefix, string` pairs are added to the end of the value as long as"
" the resulting string length is less than `max`. String1 is returned even if"
" string1 is longer than max. You can pass as many `prefix, string` pairs as "
"you wish."
msgstr ""

# 6bcf0743682d455c88f3023995d5e465
#: ../../template_ref.rst:384
msgid "strlen(a)"
msgstr ""

# 5698e953e7a04d5888cb89aaba908524
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrlen:1
msgid "strlen(a) -- Returns the length of the string passed as the argument"
msgstr ""

# c4f65594a2b04301855d8a83fa05cb1e
#: ../../template_ref.rst:389
msgid "substr(str, start, end)"
msgstr ""

# ae21c65d1c874645b5395e63f16b72bb
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubstr:1
msgid ""
"substr(str, start, end) -- returns the start'th through the end'th "
"characters of str. The first character in str is the zero'th character. If "
"end is negative, then it indicates that many characters counting from the "
"right. If end is zero, then it indicates the last character. For example, "
"substr('12345', 1, 0) returns '2345', and substr('12345', 1, -1) returns "
"'234'."
msgstr ""

# 51a3de5510a042d090867b094dbed838
#: ../../template_ref.rst:394
msgid "swap_around_comma(val)"
msgstr ""

# cb79fae17e424fad9cc9102eba343563
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSwapAroundComma:1
msgid ""
"swap_around_comma(val) -- given a value of the form \"B, A\", return \"A "
"B\". This is most useful for converting names in LN, FN format to FN LN. If "
"there is no comma, the function returns val unchanged"
msgstr ""

# 676f9595b6f54e5f8faca843bf9d719c
#: ../../template_ref.rst:399
msgid "transliterate(a)"
msgstr ""

# 65fdcef8eca440f8891cab04b770748b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTransliterate:1
msgid ""
"transliterate(a) -- Returns a string in a latin alphabet formed by "
"approximating the sound of the words in the source string. For example, if "
"the source is \"Фёдор Миха́йлович Достоевский\" the function returns "
"\"Fiodor Mikhailovich Dostoievskii\"."
msgstr ""

# a9d86b1564154bcd8015bec00c0d4d32
#: ../../template_ref.rst:405
msgid "API of the Metadata objects"
msgstr ""

# ad7f4767a3ba4950b5baf34aaa34099d
#: ../../template_ref.rst:407
msgid ""
"The python implementation of the template functions is passed in a Metadata "
"object. Knowing it's API is useful if you want to define your own template "
"functions."
msgstr ""

# fb98cab260f2429586fe3c29f1bb8346
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:1
msgid ""
"A class representing all the metadata for a book. The various standard "
"metadata fields are available as attributes of this object. You can also "
"stick arbitrary attributes onto this object."
msgstr ""

# 9a3d0466ffbf40cfb0d961f3067a2e19
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:5
msgid ""
"Metadata from custom columns should be accessed via the get() method, "
"passing in the lookup name for the column, for example: \"#mytags\"."
msgstr ""

# 90296c227c5d44d3b68f5a3aad19d5f8
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:8
msgid "Use the :meth:`is_null` method to test if a field is null."
msgstr ""

# 637d38ff90da491f9fb2a8dbb89553aa
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:10
msgid "This object also has functions to format fields into strings."
msgstr ""

# 9fdb58d82a2f44db8b09a3fa8db6631c
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:12
msgid ""
"The list of standard metadata fields grows with time is in "
":data:`STANDARD_METADATA_FIELDS`."
msgstr ""

# f85e21bc028346f2a67ec25bd55cf676
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:15
msgid ""
"Please keep the method based API of this class to a minimum. Every method "
"becomes a reserved field name."
msgstr ""

# 59ca794036f945389b77ed81707a73d8
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:1
msgid ""
"Return True if the value of field is null in this object. 'null' means it is"
" unknown or evaluates to False. So a title of _('Unknown') is null or a "
"language of 'und' is null."
msgstr ""

# b91d82b3ed044060a93335b92966c2fe
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:5
msgid ""
"Be careful with numeric fields since this will return True for zero as well "
"as None."
msgstr ""

# e6a944c2c5e54f91ba9f976d04815e0b
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:8
msgid "Also returns True if the field does not exist."
msgstr ""

# 3368dd6235a34e0381420fc87045f843
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.deepcopy:1
msgid ""
"Do not use this method unless you know what you are doing, if you want to "
"create a simple clone of this object, use :meth:`deepcopy_metadata` instead."
" Class_generator must be a function that returns an instance of Metadata or "
"a subclass of it."
msgstr ""

# d1e9626cdeb74469885004cd55d5b71a
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_identifiers:1
msgid ""
"Return a copy of the identifiers dictionary. The dict is small, and the "
"penalty for using a reference where a copy is needed is large. Also, we "
"don't want any manipulations of the returned dict to show up in the book."
msgstr ""

# 254023cd49ad462d81c0f408a63f8043
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_identifiers:1
msgid ""
"Set all identifiers. Note that if you previously set ISBN, calling this "
"method will delete it."
msgstr ""

# e3441ff708b1496b82da21e53317c2c3
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_identifier:1
msgid "If val is empty, deletes identifier of type typ"
msgstr ""

# c858fe8b2d96434693e29d7e989b2684
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.standard_field_keys:1
msgid ""
"return a list of all possible keys, even if this book doesn't have them"
msgstr ""

# f79b67181ae54a858eab3eb1b2fa9a40
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.custom_field_keys:1
msgid "return a list of the custom fields in this book"
msgstr ""

# 71d0b873b948419180850efb71d67715
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.all_field_keys:1
msgid "All field keys known by this instance, even if their value is None"
msgstr ""

# 2693d48f42a94946a0271427b5b50982
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.metadata_for_field:1
msgid "return metadata describing a standard or custom field."
msgstr ""

# 710d1242b9324cd99bcae454990ac730
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.all_non_none_fields:1
msgid ""
"Return a dictionary containing all non-None metadata fields, including the "
"custom ones."
msgstr ""

# 841f5de809a646b08b9f664ad352e1dd
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_standard_metadata:1
msgid ""
"return field metadata from the field if it is there. Otherwise return None. "
"field is the key name, not the label. Return a copy if requested, just in "
"case the user wants to change values in the dict."
msgstr ""

# 512099ba9872428ca14436eaeec5bf67
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_all_standard_metadata:1
msgid ""
"return a dict containing all the standard field metadata associated with the"
" book."
msgstr ""

# f696445f4eaf47cfbaf6510d3fc5dc99
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_all_user_metadata:1
msgid ""
"return a dict containing all the custom field metadata associated with the "
"book."
msgstr ""

# 702c8a37e25d489eba635b20088dfde8
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_user_metadata:1
msgid ""
"return field metadata from the object if it is there. Otherwise return None."
" field is the key name, not the label. Return a copy if requested, just in "
"case the user wants to change values in the dict."
msgstr ""

# 4620963924144b15a4197ab9874748d1
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_all_user_metadata:1
msgid ""
"store custom field metadata into the object. Field is the key name not the "
"label"
msgstr ""

# 9d4d178e614e4fef982e164b29369947
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_user_metadata:1
msgid ""
"store custom field metadata for one column into the object. Field is the key"
" name not the label"
msgstr ""

# 23539aac6e1e4337b318d90a59568df9
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.template_to_attribute:1
msgid ""
"Takes a list [(src,dest), (src,dest)], evaluates the template in the context"
" of other, then copies the result to self[dest]. This is on a best-efforts "
"basis. Some assignments can make no sense."
msgstr ""

# a3b3633551214decbee9a29d604a949b
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.smart_update:1
msgid ""
"Merge the information in `other` into self. In case of conflicts, the "
"information in `other` takes precedence, unless the information in `other` "
"is NULL."
msgstr ""

# 966679224e84444ca1006816418eccfe
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.format_field:1
msgid "Returns the tuple (display_name, formatted_value)"
msgstr ""

# 1591c7b2cc3245ccbdd685367fce9ffb
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.to_html:1
msgid "A HTML representation of this object."
msgstr ""

# 25b14ed3ea8e43e2bb1c8e6f754a4549
#: ../../template_ref.rst:417
msgid "The set of standard metadata fields."
msgstr ""
