# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: calibre 2.20.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-02-20 09:11+0530\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../home/kovid/work/calibre/manual/regexp.rst:4
# e275649b4cf04885a1b9553dcf63fd2f
msgid "All about using regular expressions in calibre"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:6
# 733ebf700bbb45208cda0982a81a8676
msgid "Regular expressions are features used in many places in calibre to perform sophisticated manipulation of ebook content and metadata. This tutorial is a gentle introduction to getting you started with using regular expressions in calibre."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:0
# 730e080d8cc347b39c4005e6ad37af33
msgid "Contents"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:14
# 9e4174a006fa43aaae7aeb30adc82b8f
msgid "First, a word of warning and a word of courage"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:16
# c09f0c85d3e84a0ea1d7f2b3095c5641
msgid "This is, inevitably, going to be somewhat technical- after all, regular expressions are a technical tool for doing technical stuff. I'm going to have to use some jargon and concepts that may seem complicated or convoluted. I'm going to try to explain those concepts as clearly as I can, but really can't do without using them at all. That being said, don't be discouraged by any jargon, as I've tried to explain everything new. And while regular expressions themselves may seem like an arcane, black magic (or, to be more prosaic, a random string of mumbo-jumbo letters and signs), I promise that they are not all that complicated. Even those who understand regular expressions really well have trouble reading the more complex ones, but writing them isn't as difficult- you construct the expression step by step. So, take a step and follow me into the rabbit hole."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:19
# 83755585cc994f41993ae7dfc90fd0ed
msgid "Where in calibre can you use regular expressions?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:21
# ece76e6b09c94313a6980be9952e2057
msgid "There are a few places calibre uses regular expressions. There's the Search & Replace in conversion options, metadata detection from filenames in the import settings and Search & Replace when editing the metadata of books in bulk. The calibre book editor can also use regular expressions in its search and replace feature."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:28
# 5839b0b6298d46a796f797cf05df6fb8
msgid "What on earth *is* a regular expression?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:30
# 06e82a95414e4ad4af2942a5d668324e
msgid "A regular expression is a way to describe sets of strings. A single regular expression can *match* a number of different strings. This is what makes regular expression so powerful -- they are a concise way of describing a potentially large number of variations."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:32
# fcc2e6410aa8478f82630444420c3120
msgid "I'm using string here in the sense it is used in programming languages: a string of one or more characters, characters including actual characters, numbers, punctuation and so-called whitespace (linebreaks, tabulators etc.). Please note that generally, uppercase and lowercase characters are not considered the same, thus \"a\" being a different character from \"A\" and so forth. In calibre, regular expressions are case insensitive in the search bar, but not in the conversion options. There's a way to make every regular expression case insensitive, but we'll discuss that later. It gets complicated because regular expressions allow for variations in the strings it matches, so one expression can match multiple strings, which is why people bother using them at all. More on that in a bit."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:35
# 896d86eb5f4547c89584098df6313d2e
msgid "Care to explain?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:37
# f286d6ed1b244a509e02305ec6f1994f
msgid "Well, that's why we're here. First, this is the most important concept in regular expressions: *A string by itself is a regular expression that matches itself*. That is to say, if I wanted to match the string ``\"Hello, World!\"`` using a regular expression, the regular expression to use would be ``Hello, World!``. And yes, it really is that simple. You'll notice, though, that this *only* matches the exact string ``\"Hello, World!\"``, not e.g. ``\"Hello, wOrld!\"`` or ``\"hello, world!\"`` or any other such variation."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:40
# 93cdb347207442799ec3063e3a14a2da
msgid "That doesn't sound too bad. What's next?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:42
# 02550c71c310440d8e53729294531aeb
msgid "Next is the beginning of the really good stuff. Remember where I said that regular expressions can match multiple strings? This is were it gets a little more complicated. Say, as a somewhat more practical exercise, the ebook you wanted to convert had a nasty footer counting the pages, like \"Page 5 of 423\". Obviously the page number would rise from 1 to 423, thus you'd have to match 423 different strings, right? Wrong, actually: regular expressions allow you to define sets of characters that are matched: To define a set, you put all the characters you want to be in the set into square brackets. So, for example, the set ``[abc]`` would match either the character \"a\", \"b\" or \"c\". *Sets will always only match one of the characters in the set*. They \"understand\" character ranges, that is, if you wanted to match all the lower case characters, you'd use the set ``[a-z]`` for lower- and uppercase characters you'd use ``[a-zA-Z]`` and so on. Got the idea? So, obviously, using the expression ``Page [0-9] of 423`` you'd be able to match the first 9 pages, thus reducing the expressions needed to three: The second expression ``Page [0-9][0-9] of 423`` would match all two-digit page numbers, and I'm sure you can guess what the third expression would look like. Yes, go ahead. Write it down."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:45
# 680b99a2559241c98372e310cda038d0
msgid "Hey, neat! This is starting to make sense!"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:47
# 77ef27d43068470c823ce590aad6352f
msgid "I was hoping you'd say that. But brace yourself, now it gets even better! We just saw that using sets, we could match one of several characters at once. But you can even repeat a character or set, reducing the number of expressions needed to handle the above page number example to one. Yes, ONE! Excited? You should be! It works like this: Some so-called special characters, \"+\", \"?\" and \"*\", *repeat the single element preceding them*. (Element means either a single character, a character set, an escape sequence or a group (we'll learn about those last two later)- in short, any single entity in a regular expression.) These characters are called wildcards or quantifiers. To be more precise, \"?\" matches *0 or 1* of the preceding element, \"*\" matches *0 or more* of the preceding element and \"+\" matches *1 or more* of the preceding element. A few examples: The expression ``a?`` would match either \"\" (which is the empty string, not strictly useful in this case) or \"a\", the expression ``a*`` would match \"\", \"a\", \"aa\" or any number of a's in a row, and, finally, the expression ``a+`` would match \"a\", \"aa\" or any number of a's in a row (Note: it wouldn't match the empty string!). Same deal for sets: The expression ``[0-9]+`` would match *every integer number there is*! I know what you're thinking, and you're right: If you use that in the above case of matching page numbers, wouldn't that be the single one expression to match all the page numbers? Yes, the expression ``Page [0-9]+ of 423`` would match every page number in that book!"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:50
# 083f5cabf56c455e938ea10fc667dab1
msgid "A note on these quantifiers: They generally try to match as much text as possible, so be careful when using them. This is called \"greedy behaviour\"- I'm sure you get why. It gets problematic when you, say, try to match a tag. Consider, for example, the string ``\"<p class=\"calibre2\">Title here</p>\"`` and let's say you'd want to match the opening tag (the part between the first pair of angle brackets, a little more on tags later). You'd think that the expression ``<p.*>`` would match that tag, but actually, it matches the whole string! (The character \".\" is another special character. It matches anything *except* linebreaks, so, basically, the expression ``.*`` would match any single line you can think of.) Instead, try using ``<p.*?>`` which makes the quantifier ``\"*\"`` non-greedy. That expression would only match the first opening tag, as intended. There's actually another way to accomplish this: The expression ``<p[^>]*>`` will match that same opening tag- you'll see why after the next section. Just note that there quite frequently is more than one way to write a regular expression."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:54
# a9d1ed660eb042ad83284f4f5fc0d1fe
msgid "Well, these special characters are very neat and all, but what if I wanted to match a dot or a question mark?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:56
# d58d905a2a2d4d48ad2b08fa177ef642
msgid "You can of course do that: Just put a backslash in front of any special character and it is interpreted as the literal character, without any special meaning. This pair of a backslash followed by a single character is called an escape sequence, and the act of putting a backslash in front of a special character is called escaping that character. An escape sequence is interpreted as a single element. There are of course escape sequences that do more than just escaping special characters, for example ``\"\\t\"`` means a tabulator. We'll get to some of the escape sequences later. Oh, and by the way, concerning those special characters: Consider any character we discuss in this introduction as having some function to be special and thus needing to be escaped if you want the literal character."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:59
# 69c4f3bd31a84fe7ba76fdb9cc0eb7e7
msgid "So, what are the most useful sets?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:61
# b1386f39e9974454a48db647382dabcf
msgid "Knew you'd ask. Some useful sets are ``[0-9]`` matching a single number, ``[a-z]`` matching a single lowercase letter, ``[A-Z]`` matching a single uppercase letter, ``[a-zA-Z]`` matching a single letter and ``[a-zA-Z0-9]`` matching a single letter or number. You can also use an escape sequence as shorthand::"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:68
# 7cecd56d2d254362a28d76f67186126c
msgid "\"Whitespace\" is a term for anything that won't be printed. These characters include space, tabulator, line feed, form feed and carriage return."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:70
# 6a2e5647fe904d5eaaf82ce929d57b77
msgid "As a last note on sets, you can also define a set as any character *but* those in the set. You do that by including the character ``\"^\"`` as the *very first character in the set*. Thus, ``[^a]`` would match any character excluding \"a\". That's called complementing the set. Those escape sequence shorthands we saw earlier can also be complemented: ``\"\\D\"`` means any non-number character, thus being equivalent to ``[^0-9]``. The other shorthands can be complemented by, you guessed it, using the respective uppercase letter instead of the lowercase one. So, going back to the example ``<p[^>]*>`` from the previous section, now you can see that the character set it's using tries to match any character except for a closing angle bracket."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:73
# 84e0906f15504207b74ebf445f6b7e83
msgid "But if I had a few varying strings I wanted to match, things get complicated?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:75
# 39dc93cec334476ead8f7f5eae6278a0
msgid "Fear not, life still is good and easy. Consider this example: The book you're converting has \"Title\" written on every odd page and \"Author\" written on every even page. Looks great in print, right? But in ebooks, it's annoying. You can group whole expressions in normal parentheses, and the character ``\"|\"`` will let you match *either* the expression to its right *or* the one to its left. Combine those and you're done. Too fast for you? Okay, first off, we group the expressions for odd and even pages, thus getting ``(Title)(Author)`` as our two needed expressions. Now we make things simpler by using the vertical bar (``\"|\"`` is called the vertical bar character): If you use the expression ``(Title|Author)`` you'll either get a match for \"Title\" (on the odd pages) or you'd match \"Author\" (on the even pages). Well, wasn't that easy?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:77
# 1f231746acd14dffb9b95766a5d955d2
msgid "You can, of course, use the vertical bar without using grouping parentheses, as well. Remember when I said that quantifiers repeat the element preceding them? Well, the vertical bar works a little differently: The expression \"Title|Author\" will also match either the string \"Title\" or the string \"Author\", just as the above example using grouping. *The vertical bar selects between the entire expression preceding and following it*. So, if you wanted to match the strings \"Calibre\" and \"calibre\" and wanted to select only between the upper- and lowercase \"c\", you'd have to use the expression ``(c|C)alibre``, where the grouping ensures that only the \"c\" will be selected. If you were to use ``c|Calibre``, you'd get a match on the string \"c\" or on the string \"Calibre\", which isn't what we wanted. In short: If in doubt, use grouping together with the vertical bar."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:80
# 18fefb7e95d74e60be6c3e321448217b
msgid "You missed..."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:82
# b40eb04a040b403284d8dccd1cae3f4a
msgid "... wait just a minute, there's one last, really neat thing you can do with groups. If you have a group that you previously matched, you can use references to that group later in the expression: Groups are numbered starting with 1, and you reference them by escaping the number of the group you want to reference, thus, the fifth group would be referenced as ``\\5``. So, if you searched for ``([^ ]+) \\1`` in the string \"Test Test\", you'd match the whole string!"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:86
# 1066be35e26d4df493350d8d9960dc51
msgid "In the beginning, you said there was a way to make a regular expression case insensitive?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:88
# 9e4de93051d149979ddb96529b1e8b67
msgid "Yes, I did, thanks for paying attention and reminding me. You can tell calibre how you want certain things handled by using something called flags. You include flags in your expression by using the special construct ``(?flags go here)`` where, obviously, you'd replace \"flags go here\" with the specific flags you want. For ignoring case, the flag is ``i``, thus you include ``(?i)`` in your expression. Thus, ``test(?i)`` would match \"Test\", \"tEst\", \"TEst\" and any case variation you could think of."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:90
# c1819e47fe5c4abcb5d161c66172b722
msgid "Another useful flag lets the dot match any character at all, *including* the newline, the flag ``s``. If you want to use multiple flags in an expression, just put them in the same statement: ``(?is)`` would ignore case and make the dot match all. It doesn't matter which flag you state first, ``(?si)`` would be equivalent to the above. By the way, good places for putting flags in your expression would be either the very beginning or the very end. That way, they don't get mixed up with anything else."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:93
# 4f94474fdf1e4cceaa4e05ea46781446
msgid "I think I'm beginning to understand these regular expressions now... how do I use them in calibre?"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:96
# 06c063fd23b94ee7ae3efdbd95109c4f
msgid "Conversions"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:98
# d866f662ef0942c599621ab46a7408d1
msgid "Let's begin with the conversion settings, which is really neat. In the Search and Replace part, you can input a regexp (short for regular expression) that describes the string that will be replaced during the conversion. The neat part is the wizard. Click on the wizard staff and you get a preview of what calibre \"sees\" during the conversion process. Scroll down to the string you want to remove, select and copy it, paste it into the regexp field on top of the window. If there are variable parts, like page numbers or so, use sets and quantifiers to cover those, and while you're at it, remember to escape special characters, if there are some. Hit the button labeled :guilabel:`Test` and calibre highlights the parts it would replace were you to use the regexp. Once you're satisfied, hit OK and convert. Be careful if your conversion source has tags like this example::"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:108
# fece11738c92497facd30f3974aa82e5
msgid "(shamelessly ripped out of `this thread <http://www.mobileread.com/forums/showthread.php?t=75594\">`_). You'd have to remove some of the tags as well. In this example, I'd recommend beginning with the tag ``<b class=\"calibre2\">``, now you have to end with the corresponding closing tag (opening tags are ``<tag>``, closing tags are ``</tag>``), which is simply the next ``</b>`` in this case. (Refer to a good HTML manual or ask in the forum if you are unclear on this point.) The opening tag can be described using ``<b.*?>``, the closing tag using ``</b>``, thus we could remove everything between those tags using ``<b.*?>.*?</b>``. But using this expression would be a bad idea, because it removes everything enclosed by <b>- tags (which, by the way, render the enclosed text in bold print), and it's a fair bet that we'll remove portions of the book in this way. Instead, include the beginning of the enclosed string as well, making the regular expression ``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` The ``\\s`` with quantifiers are included here instead of explicitly using the spaces as seen in the string to catch any variations of the string that might occur. Remember to check what calibre will remove to make sure you don't remove any portions you want to keep if you test a new expression. If you only check one occurrence, you might miss a mismatch somewhere else in the text. Also note that should you accidentally remove more or fewer tags than you actually wanted to, calibre tries to repair the damaged code after doing the removal."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:111
# 3ff13e506c3c43d58c042bdd80196064
msgid "Adding books"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:113
# fb527774880d48729d7546b38d874899
msgid "Another thing you can use regular expressions for is to extract metadata from filenames. You can find this feature in the \"Adding books\" part of the settings. There's a special feature here: You can use field names for metadata fields, for example ``(?P<title>)`` would indicate that calibre uses this part of the string as book title. The allowed field names are listed in the windows, together with another nice test field. An example: Say you want to import a whole bunch of files named like ``Classical Texts: The Divine Comedy by Dante Alighieri.mobi``. (Obviously, this is already in your library, since we all love classical italian poetry) or ``Science Fiction epics: The Foundation Trilogy by Isaac Asimov.epub``. This is obviously a naming scheme that calibre won't extract any meaningful data out of - its standard expression for extracting metadata is ``(?P<title>.+) - (?P<author>[^_]+)``. A regular expression that works here would be ``[a-zA-Z]+: (?P<title>.+) by (?P<author>.+)``. Please note that, inside the group for the metadata field, you need to use expressions to describe what the field actually matches. And also note that, when using the test field calibre provides, you need to add the file extension to your testing filename, otherwise you won't get any matches at all, despite using a working expression."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:117
# 4abff796e8864d35a6126a9aebdd2b93
msgid "Bulk editing metadata"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:119
# 7e0078d15bff4bb3b25d4b7714b82cea
msgid "The last part is regular expression search and replace in metadata fields. You can access this by selecting multiple books in the library and using bulk metadata edit. Be very careful when using this last feature, as it can do **Very Bad Things** to your library! Doublecheck that your expressions do what you want them to using the test fields, and only mark the books you really want to change! In the regular expression search mode, you can search in one field, replace the text with something and even write the result into another field. A practical example: Say your library contained the books of Frank Herbert's Dune series, named after the fashion ``Dune 1 - Dune``, ``Dune 2 - Dune Messiah`` and so on. Now you want to get ``Dune`` into the series field. You can do that by searching for ``(.*?) \\d+ - .*`` in the title field and replacing it with ``\\1`` in the series field. See what I did there? That's a reference to the first group you're replacing the series field with. Now that you have the series all set, you only need to do another search for ``.*? -`` in the title field and replace it with ``\"\"`` (an empty string), again in the title field, and your metadata is all neat and tidy. Isn't that great? By the way, instead of replacing the entire field, you can also append or prepend to the field, so, if you *wanted* the book title to be prepended with series info, you could do that as well. As you by now have undoubtedly noticed, there's a checkbox labeled :guilabel:`Case sensitive`, so you won't have to use flags to select behaviour here."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:121
# 0a3dde6cde6f4bbeb2979d34bda3954e
msgid "Well, that just about concludes the very short introduction to regular expressions. Hopefully I'll have shown you enough to at least get you started and to enable you to continue learning by yourself- a good starting point would be the `Python documentation for regexps <https://docs.python.org/2/library/re.html>`_."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:123
# ee4389af6a2d4be3bbda11ce731d82ed
msgid "One last word of warning, though: Regexps are powerful, but also really easy to get wrong. calibre provides really great testing possibilities to see if your expressions behave as you expect them to. Use them. Try not to shoot yourself in the foot. (God, I love that expression...) But should you, despite the warning, injure your foot (or any other body parts), try to learn from it."
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:126
# 40076fd1ee9645fc85efa64fc6dcbb26
msgid "Credits"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:128
# 2b33312cb91b40aea4c6f4aecaf505a5
msgid "Thanks for helping with tips, corrections and such:"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:130
# 4d0c9e6c4ea04ea9a1aeb2a8078906f1
msgid "ldolse"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:131
# 619cecc6ae6741d3bf5387a0e6ed2d7d
msgid "kovidgoyal"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:132
# a7ec424666bf44aeba77fcb61a395530
msgid "chaley"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:133
# eb76e047b4f0456c9d373def7009c484
msgid "dwanthny"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:134
# 953c2b5c8e764eb780c425b047d78781
msgid "kacir"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:135
# 46b6cee5ae924168b975c2842cc6dee1
msgid "Starson17"
msgstr ""

#: ../../home/kovid/work/calibre/manual/regexp.rst:137
# 577d69a69b8e4c039bac80ed1d894a53
msgid "For more about regexps see `The Python User Manual <https://docs.python.org/2/library/re.html>`_."
msgstr ""

