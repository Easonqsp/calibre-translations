# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-06-28 13:56+0530\n"
"PO-Revision-Date: 2014-06-27 03:56+0000\n"
"Last-Translator: Kovid Goyal <kovid@kovidgoyal.net>\n"
"Language-Team: Bulgarian (http://www.transifex.com/projects/p/calibre/language/bg/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: bg\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# a94be384b23a40c08f31ca7c4f758eca
#: ../../template_ref.rst:6
msgid "Reference for all built-in template language functions"
msgstr ""

# 5bcac68b587d41488e8a5dd61215d758
#: ../../template_ref.rst:8
msgid ""
"Here, we document all the built-in functions available in the |app| template"
" language. Every function is implemented as a class in python and you can "
"click the source links to see the source code, in case the documentation is "
"insufficient. The functions are arranged in logical groups by type."
msgstr ""

# 0a7fc35fa59f494ca2c0a1b9e0e638e5
#: ../../template_ref.rst:17
msgid "Arithmetic"
msgstr ""

# 5f55f2a0241a4ec0acf22340fc2e0d92
#: ../../template_ref.rst:20
msgid "add(x, y)"
msgstr ""

# a8415493cdf4454a8572622aff92e596
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAdd:1
msgid ""
"add(x, y) -- returns x + y. Throws an exception if either x or y are not "
"numbers."
msgstr ""

# 4398c704ef154a808bd16c3cfadbf459
#: ../../template_ref.rst:25
msgid "divide(x, y)"
msgstr ""

# 97bf63ec8156404a97b6d5a3bba0d1db
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinDivide:1
msgid ""
"divide(x, y) -- returns x / y. Throws an exception if either x or y are not "
"numbers."
msgstr ""

# 0245a2ea8bc84703a2b4fc3d1bd92be3
#: ../../template_ref.rst:30
msgid "multiply(x, y)"
msgstr ""

# f35062e80be34be28f246bf4a4bd737a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinMultiply:1
msgid ""
"multiply(x, y) -- returns x * y. Throws an exception if either x or y are "
"not numbers."
msgstr ""

# 88abbd5b79704e3190e7cd7d0eafb343
#: ../../template_ref.rst:35
msgid "subtract(x, y)"
msgstr ""

# 8adb815d8501472a8138e495611e42a1
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubtract:1
msgid ""
"subtract(x, y) -- returns x - y. Throws an exception if either x or y are "
"not numbers."
msgstr ""

# 339a50087ee743e486437211c19bcf91
#: ../../template_ref.rst:40
msgid "Boolean"
msgstr ""

# e5a401b842834162ac0ffa5e7db5de81
#: ../../template_ref.rst:43
msgid "and(value, value, ...)"
msgstr ""

# 813735b9f96b43adac424b41422c9152
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAnd:1
msgid ""
"and(value, value, ...) -- returns the string \"1\" if all values are not "
"empty, otherwise returns the empty string. This function works well with "
"test or first_non_empty. You can have as many values as you want."
msgstr ""

# a0a8964a56524612ba704e0bdabd52ba
#: ../../template_ref.rst:48
msgid "not(value)"
msgstr ""

# e0bc9b402c5e428c8621ff388f5b6159
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinNot:1
msgid ""
"not(value) -- returns the string \"1\" if the value is empty, otherwise "
"returns the empty string. This function works well with test or "
"first_non_empty. You can have as many values as you want."
msgstr ""

# 3da1b4286e0348c48c77ec9da4ad78b9
#: ../../template_ref.rst:53
msgid "or(value, value, ...)"
msgstr ""

# cd9ad63b559343268202e6aad15fd580
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinOr:1
msgid ""
"or(value, value, ...) -- returns the string \"1\" if any value is not empty,"
" otherwise returns the empty string. This function works well with test or "
"first_non_empty. You can have as many values as you want."
msgstr ""

# 5f87fa4d1baa41cda97478c68fdbea45
#: ../../template_ref.rst:58
msgid "Date functions"
msgstr ""

# 46b4e01c4aed403f9205bcc99ec04945
#: ../../template_ref.rst:61
msgid "days_between(date1, date2)"
msgstr ""

# 992a1246ce7b474dab1ddd45ec71915b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinDaysBetween:1
msgid ""
"days_between(date1, date2) -- return the number of days between date1 and "
"date2. The number is positive if date1 is greater than date2, otherwise "
"negative. If either date1 or date2 are not dates, the function returns the "
"empty string."
msgstr ""

# 7815ce6c77b14316820f9a7f78584008
#: ../../template_ref.rst:66
msgid "today()"
msgstr ""

# 4527a1c09a864904a2a474acdac91f91
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinToday:1
msgid ""
"today() -- return a date string for today. This value is designed for use in"
" format_date or days_between, but can be manipulated like any other string. "
"The date is in ISO format."
msgstr ""

# 96f4fd89b51840f3879ac49d3a89bff0
#: ../../template_ref.rst:71
msgid "Formatting values"
msgstr ""

# 85be4432d1ba43ca91681ec42c6a8b26
#: ../../template_ref.rst:74
msgid "finish_formatting(val, fmt, prefix, suffix)"
msgstr ""

# 05191b48018c46cfb3a1a512938b3e5c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFinishFormatting:1
msgid ""
"finish_formatting(val, fmt, prefix, suffix) -- apply the format, prefix, and"
" suffix to a value in the same way as done in a template like "
"`{series_index:05.2f| - |- }`. For example, the following program produces "
"the same output as the above template: program: "
"finish_formatting(field(\"series_index\"), \"05.2f\", \" - \", \" - \")"
msgstr ""

# 306fe57c4fd4499cb4c29406410f4b61
#: ../../template_ref.rst:79
msgid "format_date(val, format_string)"
msgstr ""

# 1f4be46902e34946abf83d43b0d2bc60
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatDate:1
msgid ""
"format_date(val, format_string) -- format the value, which must be a date, "
"using the format_string, returning a string. The formatting codes are: d    "
": the day as number without a leading zero (1 to 31) dd   : the day as "
"number with a leading zero (01 to 31) ddd  : the abbreviated localized day "
"name (e.g. \"Mon\" to \"Sun\"). dddd : the long localized day name (e.g. "
"\"Monday\" to \"Sunday\"). M    : the month as number without a leading zero"
" (1 to 12). MM   : the month as number with a leading zero (01 to 12) MMM  :"
" the abbreviated localized month name (e.g. \"Jan\" to \"Dec\"). MMMM : the "
"long localized month name (e.g. \"January\" to \"December\"). yy   : the "
"year as two digit number (00 to 99). yyyy : the year as four digit number. h"
"    : the hours without a leading 0 (0 to 11 or 0 to 23, depending on am/pm)"
" hh   : the hours with a leading 0 (00 to 11 or 00 to 23, depending on "
"am/pm) m    : the minutes without a leading 0 (0 to 59) mm   : the minutes "
"with a leading 0 (00 to 59) s    : the seconds without a leading 0 (0 to 59)"
" ss   : the seconds with a leading 0 (00 to 59) ap   : use a 12-hour clock "
"instead of a 24-hour clock, with \"ap\" replaced by the localized string for"
" am or pm AP   : use a 12-hour clock instead of a 24-hour clock, with \"AP\""
" replaced by the localized string for AM or PM iso  : the date with time and"
" timezone. Must be the only format present"
msgstr ""

# 800fdbbe7ae8476980271f1640cea4b8
#: ../../template_ref.rst:84
msgid "format_number(v, template)"
msgstr ""

# d31e29233d3248b4917a631333ee71e9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatNumber:1
msgid ""
"format_number(v, template) -- format the number v using a python formatting "
"template such as \"{0:5.2f}\" or \"{0:,d}\" or \"${0:5,.2f}\". The "
"field_name part of the template must be a 0 (zero) (the \"{0:\" in the above"
" examples). See the template language and python documentation for more "
"examples. Returns the empty string if formatting fails."
msgstr ""

# 5a143d92f60f4587ac30b91df99a15c2
#: ../../template_ref.rst:89
msgid "human_readable(v)"
msgstr ""

# 2091f3d09e6b41da8070cfa969f83766
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinHumanReadable:1
msgid ""
"human_readable(v) -- return a string representing the number v in KB, MB, "
"GB, etc."
msgstr ""

# fcd4162f30654ea69393b1221e29c108
#: ../../template_ref.rst:94
msgid "Get values from metadata"
msgstr ""

# 51b9a5e508ff4d678d95695292e19d9c
#: ../../template_ref.rst:97
msgid "approximate_formats()"
msgstr ""

# 1a868963448d4b28a2b171b8d0ad8f2b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinApproximateFormats:1
msgid ""
"approximate_formats() -- return a comma-separated list of formats that at "
"one point were associated with the book. There is no guarantee that this "
"list is correct, although it probably is. This function can be called in "
"template program mode using the template \"{:'approximate_formats()'}\". "
"Note that format names are always uppercase, as in EPUB. This function works"
" only in the GUI. If you want to use these values in save-to-disk or send-"
"to-device templates then you must make a custom \"Column built from other "
"columns\", use the function in that column's template, and use that column's"
" value in your save/send templates"
msgstr ""

# a5b757a848844374b10b8c569363459a
#: ../../template_ref.rst:102
msgid "booksize()"
msgstr ""

# 278bc705bf0f40a5b9c953621c134504
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinBooksize:1
msgid ""
"booksize() -- return value of the size field. This function works only in "
"the GUI. If you want to use this value in save-to-disk or send-to-device "
"templates then you must make a custom \"Column built from other columns\", "
"use the function in that column's template, and use that column's value in "
"your save/send templates"
msgstr ""

# 72a96afe4e3449bb919fcad2415228f6
#: ../../template_ref.rst:107
msgid "current_library_name()"
msgstr ""

# 5fb1b568c7cf48279e9c2c5e10d2d0e6
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCurrentLibraryName:1
msgid ""
"current_library_name() -- return the last name on the path to the current "
"calibre library. This function can be called in template program mode using "
"the template \"{:'current_library_name()'}\"."
msgstr ""

# 3fe52923099643a99c5074ba6cb53522
#: ../../template_ref.rst:112
msgid "current_library_path()"
msgstr ""

# 949556942e7f4335a59db143c7b9a175
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCurrentLibraryPath:1
msgid ""
"current_library_path() -- return the path to the current calibre library. "
"This function can be called in template program mode using the template "
"\"{:'current_library_path()'}\"."
msgstr ""

# 820ab6b62f5d4a999023972ff0804190
#: ../../template_ref.rst:117
msgid "field(name)"
msgstr ""

# df5e31335b054b46bf543f4fe8da8a47
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinField:1
msgid "field(name) -- returns the metadata field named by name"
msgstr ""

# 4e1a67499c8a42ec9f43f8e9d9e59f79
#: ../../template_ref.rst:122
msgid "formats_modtimes(date_format)"
msgstr ""

# ffc6fab5cd0d4fa295d6866473d87e14
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsModtimes:1
msgid ""
"formats_modtimes(date_format) -- return a comma-separated list of "
"colon_separated items representing modification times for the formats of a "
"book. The date_format parameter specifies how the date is to be formatted. "
"See the date_format function for details. You can use the select function to"
" get the mod time for a specific format. Note that format names are always "
"uppercase, as in EPUB."
msgstr ""

# f3ee4e17a31b4a1fb48abd9cb2c42e54
#: ../../template_ref.rst:127
msgid "formats_paths()"
msgstr ""

# d2913ec41732494290776e61f67622bf
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsPaths:1
msgid ""
"formats_paths() -- return a comma-separated list of colon_separated items "
"representing full path to the formats of a book. You can use the select "
"function to get the path for a specific format. Note that format names are "
"always uppercase, as in EPUB."
msgstr ""

# 267cd73034f64f21ac6baede21d206a6
#: ../../template_ref.rst:132
msgid "formats_sizes()"
msgstr ""

# 9023a0edd1b641a789d52eb0db0ae1fc
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsSizes:1
msgid ""
"formats_sizes() -- return a comma-separated list of colon_separated items "
"representing sizes in bytes of the formats of a book. You can use the select"
" function to get the size for a specific format. Note that format names are "
"always uppercase, as in EPUB."
msgstr ""

# 5d147a5b78e74640be568387aa76e114
#: ../../template_ref.rst:137
msgid "has_cover()"
msgstr ""

# 214d2b9904364257ab059124711ef9d9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinHasCover:1
msgid ""
"has_cover() -- return Yes if the book has a cover, otherwise return the "
"empty string"
msgstr ""

# f719c34dba1b454cbc76cc1803a85e78
#: ../../template_ref.rst:142
msgid "language_codes(lang_strings)"
msgstr ""

# 31c218fde27c4d03951301b977015fb9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLanguageCodes:1
msgid ""
"language_codes(lang_strings) -- return the language codes for the strings "
"passed in lang_strings. The strings must be in the language of the current "
"locale. Lang_strings is a comma-separated list."
msgstr ""

# a7aa391c8a4d4d61acc304283ad6ff12
#: ../../template_ref.rst:147
msgid "language_strings(lang_codes, localize)"
msgstr ""

# 747a868ded4146108ae42228eed8fe27
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLanguageStrings:1
msgid ""
"language_strings(lang_codes, localize) -- return the strings for the "
"language codes passed in lang_codes. If localize is zero, return the strings"
" in English. If localize is not zero, return the strings in the language of "
"the current locale. Lang_codes is a comma-separated list."
msgstr ""

# b0d0068ae4304553bbb9d56333387a1b
#: ../../template_ref.rst:152
msgid "ondevice()"
msgstr ""

# da282d2a681a4002a46ec0ff3d0b2534
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinOndevice:1
msgid ""
"ondevice() -- return Yes if ondevice is set, otherwise return the empty "
"string. This function works only in the GUI. If you want to use this value "
"in save-to-disk or send-to-device templates then you must make a custom "
"\"Column built from other columns\", use the function in that column's "
"template, and use that column's value in your save/send templates"
msgstr ""

# a93cdae414704dfd87072961e7875767
#: ../../template_ref.rst:157
msgid "raw_field(name)"
msgstr ""

# 2bf3fb7ee3604f6399bdd5c141c8c690
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinRawField:1
msgid ""
"raw_field(name) -- returns the metadata field named by name without applying"
" any formatting."
msgstr ""

# beb59d7064ab44d0b1e549c7701c5804
#: ../../template_ref.rst:162
msgid "series_sort()"
msgstr ""

# b713ef19b4df4d42ab73d94707d45b12
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSeriesSort:1
msgid "series_sort() -- return the series sort value"
msgstr ""

# feb97d7dbb4f49cfbecf93fbbb70702f
#: ../../template_ref.rst:167
msgid "virtual_libraries()"
msgstr ""

# 8761d8a3bf06449bbe7c60031999e8b3
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinVirtualLibraries:1
msgid ""
"virtual_libraries() -- return a comma-separated list of virtual libraries "
"that contain this book. This function works only in the GUI. If you want to "
"use these values in save-to-disk or send-to-device templates then you must "
"make a custom \"Column built from other columns\", use the function in that "
"column's template, and use that column's value in your save/send templates"
msgstr ""

# 51e337d30aca404fac571ccbe7851f2a
#: ../../template_ref.rst:172
msgid "If-then-else"
msgstr ""

# 7e73d9f905f848f98fc995fd1dfb41fe
#: ../../template_ref.rst:175
msgid "contains(val, pattern, text if match, text if not match)"
msgstr ""

# e3b551742e4f42a0a99503a2b79a8026
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinContains:1
msgid ""
"contains(val, pattern, text if match, text if not match) -- checks if field "
"contains matches for the regular expression `pattern`. Returns `text if "
"match` if matches are found, otherwise it returns `text if no match`"
msgstr ""

# 94f64c49b1984b70ae557e14707233af
#: ../../template_ref.rst:180
msgid "ifempty(val, text if empty)"
msgstr ""

# 846ac3ace61545eaadcf35bbadc026f2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinIfempty:1
msgid ""
"ifempty(val, text if empty) -- return val if val is not empty, otherwise "
"return `text if empty`"
msgstr ""

# c358bc0cf9454fc895ac4bbd58862ab4
#: ../../template_ref.rst:185
msgid "test(val, text if not empty, text if empty)"
msgstr ""

# e684be6656ce472385dd750c7a620687
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTest:1
msgid ""
"test(val, text if not empty, text if empty) -- return `text if not empty` if"
" the field is not empty, otherwise return `text if empty`"
msgstr ""

# 1260492eb1324933ad0e4b2c05a8fc49
#: ../../template_ref.rst:190
msgid "Iterating over values"
msgstr ""

# 0191511fe7f049caa45db8edef763cc9
#: ../../template_ref.rst:193
msgid "first_non_empty(value, value, ...)"
msgstr ""

# 55fab94de0c241fb99da1cad4b54a627
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFirstNonEmpty:1
msgid ""
"first_non_empty(value, value, ...) -- returns the first value that is not "
"empty. If all values are empty, then the empty value is returned. You can "
"have as many values as you want."
msgstr ""

# d1a3f6f2bb03462d9a8abbe55be0e1fa
#: ../../template_ref.rst:198
msgid "lookup(val, pattern, field, pattern, field, ..., else_field)"
msgstr ""

# 9260166b4c2e421cbcb608bdb1f89cb7
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLookup:1
msgid ""
"lookup(val, pattern, field, pattern, field, ..., else_field) -- like switch,"
" except the arguments are field (metadata) names, not text. The value of the"
" appropriate field will be fetched and used. Note that because composite "
"columns are fields, you can use this function in one composite field to use "
"the value of some other composite field. This is extremely useful when "
"constructing variable save paths"
msgstr ""

# 9ae594f4e35147c39d2a4f0522254aa7
#: ../../template_ref.rst:203
msgid "switch(val, pattern, value, pattern, value, ..., else_value)"
msgstr ""

# 6a2642aa88ae455aace78216a1f7e5c5
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSwitch:1
msgid ""
"switch(val, pattern, value, pattern, value, ..., else_value) -- for each "
"`pattern, value` pair, checks if the field matches the regular expression "
"`pattern` and if so, returns that `value`. If no pattern matches, then "
"else_value is returned. You can have as many `pattern, value` pairs as you "
"want"
msgstr ""

# 47e5731e2c3340539e9d413dc099bf0e
#: ../../template_ref.rst:208
msgid "List lookup"
msgstr ""

# d8e88bc498564a0e92c2e5bd30aedd20
#: ../../template_ref.rst:211
msgid "identifier_in_list(val, id, found_val, not_found_val)"
msgstr ""

# 1299f16e3dbb417690abcb6d838b6fd5
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinIdentifierInList:1
msgid ""
"identifier_in_list(val, id, found_val, not_found_val) -- treat val as a list"
" of identifiers separated by commas, comparing the string against each value"
" in the list. An identifier has the format \"identifier:value\". The id "
"parameter should be either \"id\" or \"id:regexp\". The first case matches "
"if there is any identifier with that id. The second case matches if the "
"regexp matches the identifier's value. If there is a match, return "
"found_val, otherwise return not_found_val."
msgstr ""

# 4fb45dc53d9b4598af2156c22dbc07c4
#: ../../template_ref.rst:216
msgid "in_list(val, separator, pattern, found_val, not_found_val)"
msgstr ""

# 9b97ffb474ac4873bde5222f9d9d4787
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinInList:1
msgid ""
"in_list(val, separator, pattern, found_val, not_found_val) -- treat val as a"
" list of items separated by separator, comparing the pattern against each "
"value in the list. If the pattern matches a value, return found_val, "
"otherwise return not_found_val."
msgstr ""

# ad29d39908ec42f6937b6ca109840948
#: ../../template_ref.rst:221
msgid "list_item(val, index, separator)"
msgstr ""

# bc2057baf13f4fd7ab526063a29a6368
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListitem:1
msgid ""
"list_item(val, index, separator) -- interpret the value as a list of items "
"separated by `separator`, returning the `index`th item. The first item is "
"number zero. The last item can be returned using `list_item(-1,separator)`. "
"If the item is not in the list, then the empty value is returned. The "
"separator has the same meaning as in the count function."
msgstr ""

# 4a2fd837388c4fe4a3cc9a8becb575e1
#: ../../template_ref.rst:226
msgid "select(val, key)"
msgstr ""

# 95657be02269429ab91231e5d0e29c72
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSelect:1
msgid ""
"select(val, key) -- interpret the value as a comma-separated list of items, "
"with the items being \"id:value\". Find the pair with the id equal to key, "
"and return the corresponding value."
msgstr ""

# 71b4d04f01da4acd8d4b2124dba7dd47
#: ../../template_ref.rst:231
msgid "str_in_list(val, separator, string, found_val, not_found_val)"
msgstr ""

# 44b24f47730f435ca61e8ffbea83698a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrInList:1
msgid ""
"str_in_list(val, separator, string, found_val, not_found_val) -- treat val "
"as a list of items separated by separator, comparing the string against each"
" value in the list. If the string matches a value, return found_val, "
"otherwise return not_found_val. If the string contains separators, then it "
"is also treated as a list and each value is checked."
msgstr ""

# 14abf806f31a4ba5a91249e00341bf0c
#: ../../template_ref.rst:236
msgid "List manipulation"
msgstr ""

# 6896f1759c014304939e9900aaa935b4
#: ../../template_ref.rst:239
msgid "count(val, separator)"
msgstr ""

# 7ffb210a06894fe49666790245080b21
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCount:1
msgid ""
"count(val, separator) -- interprets the value as a list of items separated "
"by `separator`, returning the number of items in the list. Most lists use a "
"comma as the separator, but authors uses an ampersand. Examples: "
"{tags:count(,)}, {authors:count(&)}"
msgstr ""

# a419c972a7d04789bc6d722081c22dff
#: ../../template_ref.rst:244
msgid "list_difference(list1, list2, separator)"
msgstr ""

# 091fd54711c341a08143b738bdd5ca2f
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListDifference:1
msgid ""
"list_difference(list1, list2, separator) -- return a list made by removing "
"from list1 any item found in list2, using a case-insensitive compare. The "
"items in list1 and list2 are separated by separator, as are the items in the"
" returned list."
msgstr ""

# f15b0ec26748490c881208bb02cd9775
#: ../../template_ref.rst:249
msgid "list_equals(list1, sep1, list2, sep2, yes_val, no_val)"
msgstr ""

# 38ec30873fef49478aa5c315ba6077fc
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListEquals:1
msgid ""
"list_equals(list1, sep1, list2, sep2, yes_val, no_val) -- return yes_val if "
"list1 and list2 contain the same items, otherwise return no_val. The items "
"are determined by splitting each list using the appropriate separator "
"character (sep1 or sep2). The order of items in the lists is not relevant. "
"The compare is case insensitive."
msgstr ""

# f66c575f42794aa99df015f22c8552d4
#: ../../template_ref.rst:254
msgid "list_intersection(list1, list2, separator)"
msgstr ""

# 9eba593689d24ef9b2be2b5a1e018ad4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListIntersection:1
msgid ""
"list_intersection(list1, list2, separator) -- return a list made by removing"
" from list1 any item not found in list2, using a case-insensitive compare. "
"The items in list1 and list2 are separated by separator, as are the items in"
" the returned list."
msgstr ""

# cf1369ab49734e8f94fe377f58db1b35
#: ../../template_ref.rst:259
msgid "list_re(src_list, separator, include_re, opt_replace)"
msgstr ""

# aba581b54d4b4bb3af5478bdb2da990c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListRe:1
msgid ""
"list_re(src_list, separator, include_re, opt_replace) -- Construct a list by"
" first separating src_list into items using the separator character. For "
"each item in the list, check if it matches include_re. If it does, then add "
"it to the list to be returned. If opt_replace is not the empty string, then "
"apply the replacement before adding the item to the returned list."
msgstr ""

# 012cf27d358a4fb6a35855596d604dd3
#: ../../template_ref.rst:264
msgid ""
"list_re(src_list, separator, include_re, search_re, group_1_template, ...)"
msgstr ""

# 175e4e99421a44eaa8a86738dbb6f283
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListReGroup:1
msgid ""
"list_re(src_list, separator, include_re, search_re, group_1_template, ...) "
"-- Like list_re except replacements are not optional. It uses "
"re_group(list_item, search_re, group_1_template, ...) when doing the "
"replacements on the resulting list."
msgstr ""

# 37fc8b095d87430aa21ad0943e1747e7
#: ../../template_ref.rst:269
msgid "list_sort(list, direction, separator)"
msgstr ""

# 25436a26e6a5454ca3d9d7ac1d8734c4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListSort:1
msgid ""
"list_sort(list, direction, separator) -- return list sorted using a case-"
"insensitive sort. If direction is zero, the list is sorted ascending, "
"otherwise descending. The list items are separated by separator, as are the "
"items in the returned list."
msgstr ""

# 825bfe6d25ec4018aaf134f3033a2994
#: ../../template_ref.rst:274
msgid "list_union(list1, list2, separator)"
msgstr ""

# f867a1f8f82c457b92e35af21c9a2d38
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListUnion:1
msgid ""
"list_union(list1, list2, separator) -- return a list made by merging the "
"items in list1 and list2, removing duplicate items using a case-insensitive "
"compare. If items differ in case, the one in list1 is used. The items in "
"list1 and list2 are separated by separator, as are the items in the returned"
" list."
msgstr ""

# f0ec8c1c2d0e46f49a4057ddc47bfdea
#: ../../template_ref.rst:279
msgid "subitems(val, start_index, end_index)"
msgstr ""

# b2551771721d463b94a96eaffa73639c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubitems:1
msgid ""
"subitems(val, start_index, end_index) -- This function is used to break "
"apart lists of items such as genres. It interprets the value as a comma-"
"separated list of items, where each item is a period-separated list. Returns"
" a new list made by first finding all the period-separated items, then for "
"each such item extracting the `start_index` to the `end_index` components, "
"then combining the results back together. The first component in a period-"
"separated list has an index of zero. If an index is negative, then it counts"
" from the end of the list. As a special case, an end_index of zero is "
"assumed to be the length of the list. Example using basic template mode and "
"assuming a #genre value of \"A.B.C\": {#genre:subitems(0,1)} returns \"A\". "
"{#genre:subitems(0,2)} returns \"A.B\". {#genre:subitems(1,0)} returns "
"\"B.C\". Assuming a #genre value of \"A.B.C, D.E.F\", {#genre:subitems(0,1)}"
" returns \"A, D\". {#genre:subitems(0,2)} returns \"A.B, D.E\""
msgstr ""

# 7455ac24966641c981a3d533789c2e28
#: ../../template_ref.rst:284
msgid "sublist(val, start_index, end_index, separator)"
msgstr ""

# 0d89abc35a4141d59b75953f520726f2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSublist:1
msgid ""
"sublist(val, start_index, end_index, separator) -- interpret the value as a "
"list of items separated by `separator`, returning a new list made from the "
"`start_index` to the `end_index` item. The first item is number zero. If an "
"index is negative, then it counts from the end of the list. As a special "
"case, an end_index of zero is assumed to be the length of the list. Examples"
" using basic template mode and assuming that the tags column (which is "
"comma-separated) contains \"A, B, C\": {tags:sublist(0,1,\\,)} returns "
"\"A\". {tags:sublist(-1,0,\\,)} returns \"C\". {tags:sublist(0,-1,\\,)} "
"returns \"A, B\"."
msgstr ""

# 8156894c89a443fcbee0bc2bb8a76800
#: ../../template_ref.rst:289
msgid "Other"
msgstr ""

# 9a45483fcaf34eb48b975b92612a5675
#: ../../template_ref.rst:292
msgid "assign(id, val)"
msgstr ""

# 23f9f98f0cd4479d98f16a1394662f63
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAssign:1
msgid ""
"assign(id, val) -- assigns val to id, then returns val. id must be an "
"identifier, not an expression"
msgstr ""

# 5350133bbce14e248aa7f85452c2b7c3
#: ../../template_ref.rst:297
msgid "print(a, b, ...)"
msgstr ""

# 34164f322f4f4c10a609a907f0f18037
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinPrint:1
msgid ""
"print(a, b, ...) -- prints the arguments to standard output. Unless you "
"start calibre from the command line (calibre-debug -g), the output will go "
"to a black hole."
msgstr ""

# 8795f2a7492143a7bd9a6b2278b3f0c0
#: ../../template_ref.rst:302
msgid "Recursion"
msgstr ""

# 3db23672f8b4483bafdf6c4db338d739
#: ../../template_ref.rst:305
msgid "eval(template)"
msgstr ""

# f9f9a2c591414cfb8ce18e0512697280
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinEval:1
msgid ""
"eval(template) -- evaluates the template, passing the local variables (those"
" 'assign'ed to) instead of the book metadata.  This permits using the "
"template processor to construct complex results from local variables. "
"Because the { and } characters are special, you must use [[ for the { "
"character and ]] for the } character; they are converted automatically. Note"
" also that prefixes and suffixes (the `|prefix|suffix` syntax) cannot be "
"used in the argument to this function when using template program mode."
msgstr ""

# 3625a377e8eb4640851ddd8947145505
#: ../../template_ref.rst:310
msgid "template(x)"
msgstr ""

# 8682adde67e543e081779de4aef4499b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTemplate:1
msgid ""
"template(x) -- evaluates x as a template. The evaluation is done in its own "
"context, meaning that variables are not shared between the caller and the "
"template evaluation. Because the { and } characters are special, you must "
"use [[ for the { character and ]] for the } character; they are converted "
"automatically. For example, template('[[title_sort]]') will evaluate the "
"template {title_sort} and return its value. Note also that prefixes and "
"suffixes (the `|prefix|suffix` syntax) cannot be used in the argument to "
"this function when using template program mode."
msgstr ""

# d89a06f0394e4a8a81987bfa2479b8fe
#: ../../template_ref.rst:315
msgid "Relational"
msgstr ""

# 27be983f92354d3f9f997d782bbccac2
#: ../../template_ref.rst:318
msgid "cmp(x, y, lt, eq, gt)"
msgstr ""

# 0ae6aaf4926e4255ae9a3cb3740ec624
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCmp:1
msgid ""
"cmp(x, y, lt, eq, gt) -- compares x and y after converting both to numbers. "
"Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr ""

# f4e55d43f94d43459cf2f9bf5a5d3abd
#: ../../template_ref.rst:323
msgid "first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result)"
msgstr ""

# c0358aadf9d144d3bf85c3b2bf6c8545
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFirstMatchingCmp:1
msgid ""
"first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result) -- "
"compares \"val < cmpN\" in sequence, returning resultN for the first "
"comparison that succeeds. Returns else_result if no comparison succeeds. "
"Example: "
"first_matching_cmp(10,5,\"small\",10,\"middle\",15,\"large\",\"giant\") "
"returns \"large\". The same example with a first value of 16 returns "
"\"giant\"."
msgstr ""

# 2e2583dd1d8c47a78cfaa90c0af9c569
#: ../../template_ref.rst:328
msgid "strcmp(x, y, lt, eq, gt)"
msgstr ""

# 659c3954d9f14e15a0cd752eb1714a74
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcmp:1
msgid ""
"strcmp(x, y, lt, eq, gt) -- does a case-insensitive comparison of x and y as"
" strings. Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr ""

# 1d5cfe3f0c044ca1ae5d9f4a36603115
#: ../../template_ref.rst:333
msgid "String case changes"
msgstr ""

# 59ad5818b988463aae442eb1259829e3
#: ../../template_ref.rst:336
msgid "capitalize(val)"
msgstr ""

# ec1ab2ff3cb346d5a4c39d15b0b133c4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCapitalize:1
msgid "capitalize(val) -- return value of the field capitalized"
msgstr ""

# 74f8cb3495c34edc9a5e15fd6db0b9ce
#: ../../template_ref.rst:341
msgid "lowercase(val)"
msgstr ""

# 16c84f8c3067436289265d1d13e401b4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLowercase:1
msgid "lowercase(val) -- return value of the field in lower case"
msgstr ""

# d485e63d58d7457faea6361069dd3b0f
#: ../../template_ref.rst:346
msgid "titlecase(val)"
msgstr ""

# f7ba006f6eb84d55bda1210191d42067
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTitlecase:1
msgid "titlecase(val) -- return value of the field in title case"
msgstr ""

# e89da73501334002b443a110c32e3bfc
#: ../../template_ref.rst:351
msgid "uppercase(val)"
msgstr ""

# 4560e68b4ef246f3a461836f2c18408b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinUppercase:1
msgid "uppercase(val) -- return value of the field in upper case"
msgstr ""

# 528a13c612df4cb3bb86fabf91b6d0d0
#: ../../template_ref.rst:356
msgid "String manipulation"
msgstr ""

# 454d8384c1fb4e1481b0a0df831589b2
#: ../../template_ref.rst:359
msgid "re(val, pattern, replacement)"
msgstr ""

# ce982ca9f24d43ad8040f6ce6c410004
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinRe:1
msgid ""
"re(val, pattern, replacement) -- return the field after applying the regular"
" expression. All instances of `pattern` are replaced with `replacement`. As "
"in all of calibre, these are python-compatible regular expressions"
msgstr ""

# 9c8f5054e4454f98bce35ebbc2c1941e
#: ../../template_ref.rst:364
msgid "re_group(val, pattern, template_for_group_1, for_group_2, ...)"
msgstr ""

# a7b7da6e74e1491499f3bf8a75ae02d8
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinReGroup:1
msgid ""
"re_group(val, pattern, template_for_group_1, for_group_2, ...) -- return a "
"string made by applying the reqular expression pattern to the val and "
"replacing each matched instance with the string computed by replacing each "
"matched group by the value returned by the corresponding template. The "
"original matched value for the group is available as $. In template program "
"mode, like for the template and the eval functions, you use [[ for { and ]] "
"for }. The following example in template program mode looks for series with "
"more than one word and uppercases the first word: {series:'re_group($, "
"\"(\\S* )(.*)\", \"[[$:uppercase()]]\", \"[[$]]\")'}"
msgstr ""

# f8a3983dc70141e0bfb6910c1e0795b5
#: ../../template_ref.rst:369
msgid "shorten(val, left chars, middle text, right chars)"
msgstr ""

# 16eed58f095141d49f4b82c92659d3ed
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinShorten:1
msgid ""
"shorten(val, left chars, middle text, right chars) -- Return a shortened "
"version of the field, consisting of `left chars` characters from the "
"beginning of the field, followed by `middle text`, followed by `right chars`"
" characters from the end of the string. `Left chars` and `right chars` must "
"be integers. For example, assume the title of the book is `Ancient English "
"Laws in the Times of Ivanhoe`, and you want it to fit in a space of at most "
"15 characters. If you use {title:shorten(9,-,5)}, the result will be "
"`Ancient E-nhoe`. If the field's length is less than left chars + right "
"chars + the length of `middle text`, then the field will be used intact. For"
" example, the title `The Dome` would not be changed."
msgstr ""

# 4f924c87ff8646889a291f7541cde4dd
#: ../../template_ref.rst:374
msgid "strcat(a, b, ...)"
msgstr ""

# 0c41a86d805a4ed5816d5e329264c6eb
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcat:1
msgid ""
"strcat(a, b, ...) -- can take any number of arguments. Returns a string "
"formed by concatenating all the arguments"
msgstr ""

# 4fd7aa6fa20c41a493a702d10f7bcdce
#: ../../template_ref.rst:379
msgid "strcat_max(max, string1, prefix2, string2, ...)"
msgstr ""

# 16089d05e8824d5bae5b5e824e14499b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcatMax:1
msgid ""
"strcat_max(max, string1, prefix2, string2, ...) -- Returns a string formed "
"by concatenating the arguments. The returned value is initialized to "
"string1. `Prefix, string` pairs are added to the end of the value as long as"
" the resulting string length is less than `max`. String1 is returned even if"
" string1 is longer than max. You can pass as many `prefix, string` pairs as "
"you wish."
msgstr ""

# ca92e5618ff54bc3a5bb07f62c293579
#: ../../template_ref.rst:384
msgid "strlen(a)"
msgstr ""

# 6136466020da45a18a6ec15bdefe9f3c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrlen:1
msgid "strlen(a) -- Returns the length of the string passed as the argument"
msgstr ""

# c0f0a6b5ee2a4ae684a08899ed3627bd
#: ../../template_ref.rst:389
msgid "substr(str, start, end)"
msgstr ""

# bbb5a0a276b9438fb0495d1379a53f17
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubstr:1
msgid ""
"substr(str, start, end) -- returns the start'th through the end'th "
"characters of str. The first character in str is the zero'th character. If "
"end is negative, then it indicates that many characters counting from the "
"right. If end is zero, then it indicates the last character. For example, "
"substr('12345', 1, 0) returns '2345', and substr('12345', 1, -1) returns "
"'234'."
msgstr ""

# 3a83d58d2a404a2397c9b2fec9d39d40
#: ../../template_ref.rst:394
msgid "swap_around_comma(val)"
msgstr ""

# a7cb619387cb4bd1b920167f3fae7be3
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSwapAroundComma:1
msgid ""
"swap_around_comma(val) -- given a value of the form \"B, A\", return \"A "
"B\". This is most useful for converting names in LN, FN format to FN LN. If "
"there is no comma, the function returns val unchanged"
msgstr ""

# bcc65ca2877d49b0bdee60f5c39bc0a9
#: ../../template_ref.rst:399
msgid "transliterate(a)"
msgstr ""

# e28665f57e4b42658334d789421f5a49
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTransliterate:1
msgid ""
"transliterate(a) -- Returns a string in a latin alphabet formed by "
"approximating the sound of the words in the source string. For example, if "
"the source is \"Фёдор Миха́йлович Достоевский\" the function returns "
"\"Fiodor Mikhailovich Dostoievskii\"."
msgstr ""

# a8e66b58401e4ee395017ff57e342e62
#: ../../template_ref.rst:405
msgid "API of the Metadata objects"
msgstr ""

# 081411ee86dd4bc1a9b86939b56af27f
#: ../../template_ref.rst:407
msgid ""
"The python implementation of the template functions is passed in a Metadata "
"object. Knowing it's API is useful if you want to define your own template "
"functions."
msgstr ""

# 61400ae405b04310bf4c94ae96f4da96
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:1
msgid ""
"A class representing all the metadata for a book. The various standard "
"metadata fields are available as attributes of this object. You can also "
"stick arbitrary attributes onto this object."
msgstr ""

# e7b95758243b4c79898b93ae462f4e00
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:5
msgid ""
"Metadata from custom columns should be accessed via the get() method, "
"passing in the lookup name for the column, for example: \"#mytags\"."
msgstr ""

# b265611032ea484da51b84c6cac1ce46
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:8
msgid "Use the :meth:`is_null` method to test if a field is null."
msgstr ""

# 818f2852f9974eeda1f81cf5c7c99198
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:10
msgid "This object also has functions to format fields into strings."
msgstr ""

# ec4b7e440d584f719ce2da75487018fe
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:12
msgid ""
"The list of standard metadata fields grows with time is in "
":data:`STANDARD_METADATA_FIELDS`."
msgstr ""

# 62184eef01134eb99e98500a0c640384
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:15
msgid ""
"Please keep the method based API of this class to a minimum. Every method "
"becomes a reserved field name."
msgstr ""

# e58fec93eccc4efc935e31b37dd098f7
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:1
msgid ""
"Return True if the value of field is null in this object. 'null' means it is"
" unknown or evaluates to False. So a title of _('Unknown') is null or a "
"language of 'und' is null."
msgstr ""

# 90f7675598064a5baf1d715b2aa8b0dd
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:5
msgid ""
"Be careful with numeric fields since this will return True for zero as well "
"as None."
msgstr ""

# 70e084c66e5a4105bcb687a83eab163f
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:8
msgid "Also returns True if the field does not exist."
msgstr ""

# f04e56f8a64f4c139434cf64493f9340
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.deepcopy:1
msgid ""
"Do not use this method unless you know what you are doing, if you want to "
"create a simple clone of this object, use :meth:`deepcopy_metadata` instead."
" Class_generator must be a function that returns an instance of Metadata or "
"a subclass of it."
msgstr ""

# 504b51c4fd524e00a15b453e9013471f
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_identifiers:1
msgid ""
"Return a copy of the identifiers dictionary. The dict is small, and the "
"penalty for using a reference where a copy is needed is large. Also, we "
"don't want any manipulations of the returned dict to show up in the book."
msgstr ""

# 734013c9fa484dcc956a2a24cecebd89
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_identifiers:1
msgid ""
"Set all identifiers. Note that if you previously set ISBN, calling this "
"method will delete it."
msgstr ""

# 3c44f75e63eb4014be71e38d5c182032
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_identifier:1
msgid "If val is empty, deletes identifier of type typ"
msgstr ""

# f04fb444ea544ba4b1e8a63d6537015c
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.standard_field_keys:1
msgid ""
"return a list of all possible keys, even if this book doesn't have them"
msgstr ""

# 808b212001524619837fe469817bbff0
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.custom_field_keys:1
msgid "return a list of the custom fields in this book"
msgstr ""

# d56b63e1359e48e2904b2821f8624cad
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.all_field_keys:1
msgid "All field keys known by this instance, even if their value is None"
msgstr ""

# 5ed074e1a21340a680fc746987c2fb13
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.metadata_for_field:1
msgid "return metadata describing a standard or custom field."
msgstr ""

# 3f66701296e04b968daba0fc806b8e73
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.all_non_none_fields:1
msgid ""
"Return a dictionary containing all non-None metadata fields, including the "
"custom ones."
msgstr ""

# 95147b0c78844061bc31c975e7bbe992
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_standard_metadata:1
msgid ""
"return field metadata from the field if it is there. Otherwise return None. "
"field is the key name, not the label. Return a copy if requested, just in "
"case the user wants to change values in the dict."
msgstr ""

# f8b3ed763bef4e4c9e301583b11319cc
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_all_standard_metadata:1
msgid ""
"return a dict containing all the standard field metadata associated with the"
" book."
msgstr ""

# 459a23bd0f744c62930acfb47b6893f6
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_all_user_metadata:1
msgid ""
"return a dict containing all the custom field metadata associated with the "
"book."
msgstr ""

# a24957e4e94345d7905f799bb3e86ac6
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_user_metadata:1
msgid ""
"return field metadata from the object if it is there. Otherwise return None."
" field is the key name, not the label. Return a copy if requested, just in "
"case the user wants to change values in the dict."
msgstr ""

# 3a63bd35c49446bcbd1ebb8e581f5a8b
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_all_user_metadata:1
msgid ""
"store custom field metadata into the object. Field is the key name not the "
"label"
msgstr ""

# d42c96c7812841f7a90fdfec500d2e61
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_user_metadata:1
msgid ""
"store custom field metadata for one column into the object. Field is the key"
" name not the label"
msgstr ""

# 8fdd95a366124f40bc345f1a41795c09
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.template_to_attribute:1
msgid ""
"Takes a list [(src,dest), (src,dest)], evaluates the template in the context"
" of other, then copies the result to self[dest]. This is on a best-efforts "
"basis. Some assignments can make no sense."
msgstr ""

# fc6a1a73fb1e4a528b9dd769ccc5bd06
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.smart_update:1
msgid ""
"Merge the information in `other` into self. In case of conflicts, the "
"information in `other` takes precedence, unless the information in `other` "
"is NULL."
msgstr ""

# f602e16e622f42a4b66b6c0f0a412543
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.format_field:1
msgid "Returns the tuple (display_name, formatted_value)"
msgstr ""

# 2cde90c779da44d9b360bb0abb3bed29
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.to_html:1
msgid "A HTML representation of this object."
msgstr ""

# cfc148fab7b540f9bde4940584e05658
#: ../../template_ref.rst:417
msgid "The set of standard metadata fields."
msgstr ""
