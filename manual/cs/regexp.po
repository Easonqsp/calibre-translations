# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# Trottel <trottel09@gmail.com>, 2014
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-09-26 10:21+0530\n"
"PO-Revision-Date: 2014-09-26 09:49+0000\n"
"Last-Translator: Trottel <trottel09@gmail.com>\n"
"Language-Team: Czech (http://www.transifex.com/projects/p/calibre/language/cs/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: cs\n"
"Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"

# 070d72942c824fc5a221b729949ee288
#: ../../home/kovid/work/calibre/manual/regexp.rst:5
msgid "All about using regular expressions in |app|"
msgstr "Vše o používání regulárních výrazů v |app|"

# 2104266906e04782ac22c0bd01e43aa6
#: ../../home/kovid/work/calibre/manual/regexp.rst:7
msgid ""
"Regular expressions are features used in many places in |app| to perform "
"sophisticated manipulation of ebook content and metadata. This tutorial is a"
" gentle introduction to getting you started with using regular expressions "
"in |app|."
msgstr "Regulární výrazy jsou funkce používané na mnoha místech v |app| pro provádění propracovaného zpracování obsahu e-knihy a metadat. Tento kurz je mírný úvod do problematiky používání regulárních výrazů v |app|."

# 093dd5aa53074181aef0a45d6b8981f7
#: ../../home/kovid/work/calibre/manual/regexp.rst:0
msgid "Contents"
msgstr "Obsah"

# 3184de26f48e450fb46e6d3a10899eb4
#: ../../home/kovid/work/calibre/manual/regexp.rst:15
msgid "First, a word of warning and a word of courage"
msgstr "Nejdříve malé varování a malé povzbuzení"

# f2e4e1092c0e490bbb499b0e88829b39
#: ../../home/kovid/work/calibre/manual/regexp.rst:17
msgid ""
"This is, inevitably, going to be somewhat technical- after all, regular "
"expressions are a technical tool for doing technical stuff. I'm going to "
"have to use some jargon and concepts that may seem complicated or "
"convoluted. I'm going to try to explain those concepts as clearly as I can, "
"but really can't do without using them at all. That being said, don't be "
"discouraged by any jargon, as I've tried to explain everything new. And "
"while regular expressions themselves may seem like an arcane, black magic "
"(or, to be more prosaic, a random string of mumbo-jumbo letters and signs), "
"I promise that they are not all that complicated. Even those who understand "
"regular expressions really well have trouble reading the more complex ones, "
"but writing them isn't as difficult- you construct the expression step by "
"step. So, take a step and follow me into the rabbit hole."
msgstr "Toto bude nevyhnutelně poněkud technické – ostatně regulární výrazy jsou technickým nástrojem pro to technické záležitosti. Budu muset použít nějaký žargon a pojmy, které se mohou zdát složité a spletité. Budu se snažit vysvětlit tyto pojmy co nejjasněji, ale opravdu není možné obejít se bez jejich použití. Jak již bylo řečeno, nenechte se odradit žádným žargonem, protože se snažím vysvětlit všechno nové. A zatímco samotné regulární výrazy vám můžou připadat jako tajemná, černé magie (nebo, abychom byli prozaičtější, náhodný řetězec nesmyslných písmen a znaků), slibuji, že nejsou vůbec tak složité. Dokonce i ti, kteří pochopili regulární výrazy opravdu dobře, mají problémy se čtením těch složitějších, ale jejich psaní není tak obtížně – vytváříte výraz krok za krokem. Takže vykročte a následujte mě do králičí nory."

# 91b34ab026054b3899a4b88f869ae4a0
#: ../../home/kovid/work/calibre/manual/regexp.rst:20
msgid "Where in |app| can you use regular expressions?"
msgstr "Kde v |app| můžete použít regulární výrazy?"

# c5ae6e38bef84afea6bedb85fa6f010f
#: ../../home/kovid/work/calibre/manual/regexp.rst:22
msgid ""
"There are a few places |app| uses regular expressions. There's the Search & "
"Replace in conversion options, metadata detection from filenames in the "
"import settings and Search & Replace when editing the metadata of books in "
"bulk."
msgstr "Existuje několik míst, kde |app| používá regulární výrazy. Je zde Najít a nahradit ve volbách převodu, detekce metadat z názvů souborů v nastavení importu a Najít a nahradit při hromadné úpravě metadat knih."

# f455c624d3564d3daabdd5b15f3d857f
#: ../../home/kovid/work/calibre/manual/regexp.rst:25
msgid "What on earth *is* a regular expression?"
msgstr "Co to u všech všudy *je* regulární příkaz?"

# 3d2e28c91e2e4aef84bd2b80c825d78e
#: ../../home/kovid/work/calibre/manual/regexp.rst:27
msgid ""
"A regular expression is a way to describe sets of strings. A single regular "
"expression can *match* a number of different strings. This is what makes "
"regular expression so powerful -- they are a concise way of describing a "
"potentially large number of variations."
msgstr "Regulární výraz je způsob, jak popsat sady řetězců. Jeden regulární výraz může *odpovídat* velkému počtu různých řetězců. Proto jsou regulární výrazy tak mocné --  jsou stručným způsobem popisu potenciálně velkého počtu variací."

# 1e3384f145e8460d90f390eb31f67dec
#: ../../home/kovid/work/calibre/manual/regexp.rst:29
msgid ""
"I'm using string here in the sense it is used in programming languages: a "
"string of one or more characters, characters including actual characters, "
"numbers, punctuation and so-called whitespace (linebreaks, tabulators etc.)."
" Please note that generally, uppercase and lowercase characters are not "
"considered the same, thus \"a\" being a different character from \"A\" and "
"so forth. In |app|, regular expressions are case insensitive in the search "
"bar, but not in the conversion options. There's a way to make every regular "
"expression case insensitive, but we'll discuss that later. It gets "
"complicated because regular expressions allow for variations in the strings "
"it matches, so one expression can match multiple strings, which is why "
"people bother using them at all. More on that in a bit."
msgstr "Řetězec zde používám ve smyslu, v jakém se používá v programovacích jazycích: řetězec jednoho nebo více znaků, znaků včetně skutečných znaků, čísel, interpunkčních znamének a takzvaných prázdných znaků (konce řádků, tabulátorů atd). Všimněte si, že velká a malá písmena nejsou obecně považována za stejná, tedy \"a\" je jiný znak než \"A\" a tak dále. V |app| regulární výrazy rozlišují velikost písmen v panelu hledání, ale ne ve volbách převodu. Existuje způsob, aby každý regulární výraz rozlišoval velikost písmen, ale to probereme později. Trochu se to komplikuje, protože regulární výrazy umožňují variace v řetězcích, se kterými se porovnávají, takže jeden výraz může odpovídat více řetězcům, což je důvod, proč se je lidé vůbec obtěžují používat. Více si o tom povíme za chvíli."

# 6213c2e368d64705a92b87a9945f1700
#: ../../home/kovid/work/calibre/manual/regexp.rst:32
msgid "Care to explain?"
msgstr "Zajímá vás vysvětlení?"

# 769e98d3cf724d2e821133eddde7e94f
#: ../../home/kovid/work/calibre/manual/regexp.rst:34
msgid ""
"Well, that's why we're here. First, this is the most important concept in "
"regular expressions: *A string by itself is a regular expression that "
"matches itself*. That is to say, if I wanted to match the string ``\"Hello, "
"World!\"`` using a regular expression, the regular expression to use would "
"be ``Hello, World!``. And yes, it really is that simple. You'll notice, "
"though, that this *only* matches the exact string ``\"Hello, World!\"``, not"
" e.g. ``\"Hello, wOrld!\"`` or ``\"hello, world!\"`` or any other such "
"variation."
msgstr "No, proto jsme tady. Za prvé, toto je nejdůležitější koncept v regulárních výrazech: *Řetězec sám o sobě je regulární výraz, který odpovídá sobě samému*. To znamená, že když chci pomocí regulárního výrazu porovnat řetězec ``\"Hello, World!\"``, použitý regulární výraz by byl ``Hello, World!``. Ano, opravdu je to tak jednoduché. Ale všimněte si, že toto odpovídá *pouze* přesnému řetězci ``\"Hello, World!\"``, ne například ``\"Hello, wOrld!\"`` nebo ``\"hello, world!\"`` nebo jakékoliv jiné takové variaci."

# 4cbf42afa72940bd839e3f3eb0dda7d5
#: ../../home/kovid/work/calibre/manual/regexp.rst:37
msgid "That doesn't sound too bad. What's next?"
msgstr "To nezní tak špatně. Co dál?"

# 2cc281b1dc364567ae79a440adcbb66f
#: ../../home/kovid/work/calibre/manual/regexp.rst:39
msgid ""
"Next is the beginning of the really good stuff. Remember where I said that "
"regular expressions can match multiple strings? This is were it gets a "
"little more complicated. Say, as a somewhat more practical exercise, the "
"ebook you wanted to convert had a nasty footer counting the pages, like "
"\"Page 5 of 423\". Obviously the page number would rise from 1 to 423, thus "
"you'd have to match 423 different strings, right? Wrong, actually: regular "
"expressions allow you to define sets of characters that are matched: To "
"define a set, you put all the characters you want to be in the set into "
"square brackets. So, for example, the set ``[abc]`` would match either the "
"character \"a\", \"b\" or \"c\". *Sets will always only match one of the "
"characters in the set*. They \"understand\" character ranges, that is, if "
"you wanted to match all the lower case characters, you'd use the set "
"``[a-z]`` for lower- and uppercase characters you'd use ``[a-zA-Z]`` and so "
"on. Got the idea? So, obviously, using the expression ``Page [0-9] of 423`` "
"you'd be able to match the first 9 pages, thus reducing the expressions "
"needed to three: The second expression ``Page [0-9][0-9] of 423`` would "
"match all two-digit page numbers, and I'm sure you can guess what the third "
"expression would look like. Yes, go ahead. Write it down."
msgstr "Dál začínají opravdu dobré věci. Pamatujete si, jak jsem říkal, že regulární výrazy mohou odpovídat více řetězcům? Tady to bude trochu složitější. Řekněme, jako poněkud praktičtější cvičení, že e-kniha, kterou chcete převést, má ošklivé zápatí počítající stránky, jako \"Strana 5 z 423\". Je zřejmé, že číslo stránky bude růst od 1 do 423, takže budete muset porovnat 423 různých řetězců, že? Špatně, ve skutečnosti: regulární výrazy vám umožňují definovat sady znaků, které jsou porovnávány. Abyste definovali sadu, dejte všechny znaky, které chcete mít v sadě, do hranatých závorek. Takže například sada ``[abc]`` by odpovídala buď znaku \"a\", \"b\" nebo \"c\". *Sady budou vždy porovnávat pouze jeden ze znaků v sadě*. \"Rozumějí\" rozsahům znaků, takže pokud chcete porovnat všechna malá písmena, použili byste sadu ``[a-z]``, pro malá a velká písmena byste použili ``[a-zA-Z]`` a tak dále. Chápete to? Takže samozřejmě pomocí výrazu ``Strana [0-9] z 423`` byste byli schopni porovnat prvních 9 stránek, čímž se sníží počet potřebných výrazů na tři: Druhý výraz ``Strana [0-9][0-9] z 423`` by porovnal všechna dvojciferná čísla stránek, a jsem si jistý, že umíte odhadnout, jak by vypadal třetí výraz. Ano, do toho. Napište ho."

# 4a177d4fa8204870b4b09ec4e844fbb1
#: ../../home/kovid/work/calibre/manual/regexp.rst:42
msgid "Hey, neat! This is starting to make sense!"
msgstr "Parádní! Začíná to dávat smysl!"

# 833ba68f98704c89866aa79f471d3f9d
#: ../../home/kovid/work/calibre/manual/regexp.rst:44
msgid ""
"I was hoping you'd say that. But brace yourself, now it gets even better! We"
" just saw that using sets, we could match one of several characters at once."
" But you can even repeat a character or set, reducing the number of "
"expressions needed to handle the above page number example to one. Yes, ONE!"
" Excited? You should be! It works like this: Some so-called special "
"characters, \"+\", \"?\" and \"*\", *repeat the single element preceding "
"them*. (Element means either a single character, a character set, an escape "
"sequence or a group (we'll learn about those last two later)- in short, any "
"single entity in a regular expression.) These characters are called "
"wildcards or quantifiers. To be more precise, \"?\" matches *0 or 1* of the "
"preceding element, \"*\" matches *0 or more* of the preceding element and "
"\"+\" matches *1 or more* of the preceding element. A few examples: The "
"expression ``a?`` would match either \"\" (which is the empty string, not "
"strictly useful in this case) or \"a\", the expression ``a*`` would match "
"\"\", \"a\", \"aa\" or any number of a's in a row, and, finally, the "
"expression ``a+`` would match \"a\", \"aa\" or any number of a's in a row "
"(Note: it wouldn't match the empty string!). Same deal for sets: The "
"expression ``[0-9]+`` would match *every integer number there is*! I know "
"what you're thinking, and you're right: If you use that in the above case of"
" matching page numbers, wouldn't that be the single one expression to match "
"all the page numbers? Yes, the expression ``Page [0-9]+ of 423`` would match"
" every page number in that book!"
msgstr "Doufal jsem, že to řeknete. Ale připravte se, teď to bude ještě lepší! Právě jsme viděli, že pomocí sad jsme mohli porovnat jeden z několika znaků najednou. Ale můžete dokonce opakovat znak nebo sadu, čímž snížíte počet výrazů potřebných pro zpracování výše uvedeného příkladu s čísly stránek na jeden. Ano, JEDEN! Jste nadšení? Měli byste být! Funguje to takhle: Některé takzvané speciální znaky, \"+\", \"?\" a \"*\", *opakují jednotlivý  předcházející prvek*. (Prvek znamená buď jeden znak, sadu znaků, řídící sekvenci nebo skupinu (o těch posledních dvou se budeme učit později.) – zkrátka každý jednotlivý prvek v regulárním výrazu) Tyto znaky se nazývají zástupné znaky nebo kvantifikátory. Abychom byli přesnější, \"?\" odpovídá *0 nebo 1* výskytů předcházejícího prvku, \"*\" odpovídá *0 nebo více* výskytů předcházejícího prvku a \"+\" odpovídá *1 nebo více* výskytů předcházejícího prvku. Několik příkladů: Výraz ``a?`` by odpovídal buď \"\" (což je prázdný řetězec, není nezbytně užitečný v tomto případě), nebo \"a\", výraz ``a*`` by odpovídal \"\", \"a\", \"aa\" nebo libovolnému počtu a v řadě, a konečně výraz ``a+`` by odpovídal \"a\", \"aa\" nebo libovolnému počtu a v řadě (Poznámka: neodpovídal by prázdnému řetězci!). To samé pro sady: Výraz ``[0-9]+`` by odpovídal *každému existujícímu celému číslu*! Vím, co si myslíte, a máte pravdu: Když toto použijete ve výše uvedeném případu porovnávání čísel stránek, nebyl by to jediný výraz pro porovnání všech čísel stránek? Ano, výraz ``Strana [0-9]+ z 423`` by porovnal každé číslo stránky v této knize!"

# 35d76095dcd7409bb5591f4b03dee52c
#: ../../home/kovid/work/calibre/manual/regexp.rst:47
msgid ""
"A note on these quantifiers: They generally try to match as much text as "
"possible, so be careful when using them. This is called \"greedy "
"behaviour\"- I'm sure you get why. It gets problematic when you, say, try to"
" match a tag. Consider, for example, the string ``\"<p "
"class=\"calibre2\">Title here</p>\"`` and let's say you'd want to match the "
"opening tag (the part between the first pair of angle brackets, a little "
"more on tags later). You'd think that the expression ``<p.*>`` would match "
"that tag, but actually, it matches the whole string! (The character \".\" is"
" another special character. It matches anything *except* linebreaks, so, "
"basically, the expression ``.*`` would match any single line you can think "
"of.) Instead, try using ``<p.*?>`` which makes the quantifier ``\"*\"`` non-"
"greedy. That expression would only match the first opening tag, as intended."
" There's actually another way to accomplish this: The expression "
"``<p[^>]*>`` will match that same opening tag- you'll see why after the next"
" section. Just note that there quite frequently is more than one way to "
"write a regular expression."
msgstr "Poznámka o těchto kvantifikátorech: Obvykle se snaží porovnat tolik textu, kolik je možné, takže buďte opatrní při jejich použití. Nazývá se to \"chamtivý chování\" – jsem si jistý, že chápete proč. Je to komplikovanější, když, řekněme, chcete porovnat značku. Vezměme například řetězec ``\"<p class=\"calibre2\">Tady je nadpis</p>\"`` a řekněme, že byste chtěli porovnat otevírací značku (část mezi první dvojicí hranatých závorek, značky probereme trochu více později). Mysleli byste si, že by této značce odpovídal výraz ``<p.*>``, ale ve skutečnosti odpovídá celému řetězci! (Znak \".\" je další speciální znak. Odpovídá čemukoliv *kromě* koncům řádků, takže v podstatě výraz ``.*` by odpovídal každičkému řádku, který si dokážete představit.) Místo toho zkuste použít ``<p.*?>``, čímž přestane být kvantifikátor ``\"*\"`` chamtivým. Tento výraz bude odpovídat pouze první otevírací značce, jak bylo zamýšleno. Existuje vlastně další způsob, jak toho dosáhnout: Výraz ``<p[^>]*>`` bude odpovídat té samé otevírací značce – po další části uvidíte proč. Jen vezměte na vědomí, že dost často existuje více než jeden způsob, jak napsat regulární výraz."

# 6b2218cfc2864fedbef607378c3f2e7c
#: ../../home/kovid/work/calibre/manual/regexp.rst:51
msgid ""
"Well, these special characters are very neat and all, but what if I wanted "
"to match a dot or a question mark?"
msgstr "No, tyto speciální znaky jsou velice elegantní a tak, ale co když chci porovnat tečku nebo otazník?"

# 5f51eef849264642bb43343e64879d9a
#: ../../home/kovid/work/calibre/manual/regexp.rst:53
msgid ""
"You can of course do that: Just put a backslash in front of any special "
"character and it is interpreted as the literal character, without any "
"special meaning. This pair of a backslash followed by a single character is "
"called an escape sequence, and the act of putting a backslash in front of a "
"special character is called escaping that character. An escape sequence is "
"interpreted as a single element. There are of course escape sequences that "
"do more than just escaping special characters, for example ``\"\\t\"`` means"
" a tabulator. We'll get to some of the escape sequences later. Oh, and by "
"the way, concerning those special characters: Consider any character we "
"discuss in this introduction as having some function to be special and thus "
"needing to be escaped if you want the literal character."
msgstr "Samozřejmě to můžete udělat: Stačí před jakýkoliv speciální znak vložit zpětné lomítko a je interpretován jako prostý znak bez jakéhokoliv speciálního významu. Tento pár zpětného lomítka následovaného jedním znakem se nazývá řídící sekvence, a vložení zpětného lomítka před speciální znak se nazývá uvozování toho znaku. Řídící sekvence je interpretována jako jeden prvek. Existují samozřejmě řídící sekvence, které dělají více než jen uvozování speciálních znaků, například ``\"\\t\"`` znamená tabulátor. K některým řídícím sekvencím se dostaneme později. Jo a mimochodem, pokud jde o tyto speciální znaky: Uvažujte o kterémkoliv znaku, o kterém se budeme v tomto úvodu bavit, že má nějakou funkci, která je speciální, a tedy musí být uvozen, pokud chcete prostý znak."

# 8b12d7b221154bb3b4cdb25cd2f9cdf6
#: ../../home/kovid/work/calibre/manual/regexp.rst:56
msgid "So, what are the most useful sets?"
msgstr "Takže, jaké jsou nejužitečnější sady?"

# 157616ac9530435c954167930f9bc252
#: ../../home/kovid/work/calibre/manual/regexp.rst:58
msgid ""
"Knew you'd ask. Some useful sets are ``[0-9]`` matching a single number, "
"``[a-z]`` matching a single lowercase letter, ``[A-Z]`` matching a single "
"uppercase letter, ``[a-zA-Z]`` matching a single letter and ``[a-zA-Z0-9]`` "
"matching a single letter or number. You can also use an escape sequence as "
"shorthand::"
msgstr "Věděl jsem, že se zeptáte. Některé užitečné sady jsou ``[0-9]`` odpovídající jednomu číslu, ``[a-z]`` odpovídající jednomu malému písmenu, ``[A-Z]`` odpovídající jednomu velkému písmenu, ``[a-zA-Z]`` odpovídající jednomu písmenu a  ``[a-zA-Z0-9]`` odpovídající jednomu písmenu nebo číslu. Můžete také použít řídící sekvenci jako zjednodušení::"

# e45ce007b6804c6ab13e43246b03572f
#: ../../home/kovid/work/calibre/manual/regexp.rst:65
msgid ""
"\"Whitespace\" is a term for anything that won't be printed. These "
"characters include space, tabulator, line feed, form feed and carriage "
"return."
msgstr "\"Prázdný znak\" je termín pro cokoliv, co nebude vytištěno. Tyto znaky zahrnují mezeru, tabulátor, posun řádku, posun strany a návrat na začátek řádku."

# 9045b3c05b174faba2ffcd50e31d8e01
#: ../../home/kovid/work/calibre/manual/regexp.rst:67
msgid ""
"As a last note on sets, you can also define a set as any character *but* "
"those in the set. You do that by including the character ``\"^\"`` as the "
"*very first character in the set*. Thus, ``[^a]`` would match any character "
"excluding \"a\". That's called complementing the set. Those escape sequence "
"shorthands we saw earlier can also be complemented: ``\"\\D\"`` means any "
"non-number character, thus being equivalent to ``[^0-9]``. The other "
"shorthands can be complemented by, you guessed it, using the respective "
"uppercase letter instead of the lowercase one. So, going back to the example"
" ``<p[^>]*>`` from the previous section, now you can see that the character "
"set it's using tries to match any character except for a closing angle "
"bracket."
msgstr "Jako poslední poznámka o sadách, sadu můžete také definovat jako jakýkoliv znak *kromě* těch v sadě. Uděláte to zahrnutím znaku ``\"^\"`` jako *úplně prvního znaku v sadě*. Takže ``[^a]`` by odpovídalo libovolnému znaku kromě \"a\". Tomu se říká doplňující sada. Zkratky řídící sekvence, které jsme viděli dříve, mohou být také doplněny: ``\"\\D\"`` znamená jakýkoli nečíselný znak, takže je ekvivalentem ``[^0-9]``. Jak už jste asi uhodli, ostatní zkratky mohou být doplněny pomocí příslušného velkého písmena namísto malého. Takže když se vrátíme k příkladu ``<p[^>]*>`` z předchozí části, můžete nyní vidět, že použitá sada znaků se pokusí porovnat jakýkoliv znak kromě uzavírací úhlové závorky."

# 08345d757d144acdbf67d7b579990153
#: ../../home/kovid/work/calibre/manual/regexp.rst:70
msgid ""
"But if I had a few varying strings I wanted to match, things get "
"complicated?"
msgstr "Ale když budu mít několik různých řetězců, které chci porovnat, zkomplikuje se to?"

# 5a39b489ef8c44f98092c7af1324af2b
#: ../../home/kovid/work/calibre/manual/regexp.rst:72
msgid ""
"Fear not, life still is good and easy. Consider this example: The book "
"you're converting has \"Title\" written on every odd page and \"Author\" "
"written on every even page. Looks great in print, right? But in ebooks, it's"
" annoying. You can group whole expressions in normal parentheses, and the "
"character ``\"|\"`` will let you match *either* the expression to its right "
"*or* the one to its left. Combine those and you're done. Too fast for you? "
"Okay, first off, we group the expressions for odd and even pages, thus "
"getting ``(Title)(Author)`` as our two needed expressions. Now we make "
"things simpler by using the vertical bar (``\"|\"`` is called the vertical "
"bar character): If you use the expression ``(Title|Author)`` you'll either "
"get a match for \"Title\" (on the odd pages) or you'd match \"Author\" (on "
"the even pages). Well, wasn't that easy?"
msgstr "Nebojte se, život je pořád jednoduchý. Vezměme si tento příklad: Kniha, kterou převádíte má napsán \"Název\" na každé liché stránce a \"Autor\" na každé sudé stránce. V tisku to vypadá skvěle, že jo? Ale v e-knize je to otravné. Můžete seskupit celé výrazy do normálních závorek a znak ``\"|\"`` vám umožní porovnat *buď* výraz s jeho pravou *nebo* levou stranou. Toto zkombinujte a máte hotovo. Je to na vás příliš? Dobře, nejdříve seskupíme výrazy pro sudé a liché stránky, takže získáme ``(Název)(Autor)`` jako naše dva potřebné výrazy. Nyní věci zjednodušíme pomocí svislé čáry ho pruhu (znak ``\"|\"`` se nazývá svislá čára): Pokud použijete výraz ``(Název|Autor)``, dostanete shodu buď pro \"Název\" (na lichých stránkách), nebo pro \"Autor\" (na sudých stránkách). No, nebylo to jednoduché?"

# d0167a3c04e449ddbe1ce810ca4b115c
#: ../../home/kovid/work/calibre/manual/regexp.rst:74
msgid ""
"You can, of course, use the vertical bar without using grouping parentheses,"
" as well. Remember when I said that quantifiers repeat the element preceding"
" them? Well, the vertical bar works a little differently: The expression "
"\"Title|Author\" will also match either the string \"Title\" or the string "
"\"Author\", just as the above example using grouping. *The vertical bar "
"selects between the entire expression preceding and following it*. So, if "
"you wanted to match the strings \"Calibre\" and \"calibre\" and wanted to "
"select only between the upper- and lowercase \"c\", you'd have to use the "
"expression ``(c|C)alibre``, where the grouping ensures that only the \"c\" "
"will be selected. If you were to use ``c|Calibre``, you'd get a match on the"
" string \"c\" or on the string \"Calibre\", which isn't what we wanted. In "
"short: If in doubt, use grouping together with the vertical bar."
msgstr "Svislou čáru můžete samozřejmě použít také bez použití seskupovacích závorek. Pamatujete, když jsem říkal, že kvantifikátory opakují jim předcházející prvek? No, svislá čára funguje trochu jinak: Výraz \"Název|Autor\" bude také odpovídat buď řetězci \"Název\" nebo řetězci \"Autor\", stejně jako výše uvedený příklad používající seskupování. *Svislá čára vybírá mezi celým výrazem, který ji předchází a následuje*. Takže pokud byste chtěli porovnat řetězce \"Calibre\" a \"calibre\" a chtěli byste vybrat pouze mezi malým a velkým \"c\", museli byste použít výraz ``(c|C)alibre``, kde seskupení zajišťuje, že bude vybráno pouze \"c\". Pokud byste použili ``c|Calibre``, získali byste shodu na řetězec \"c\" nebo na řetězec \"Calibre\", což není to, co jsme chtěli. Stručně řečeno: Pokud si nejste jisti, použijte seskupování společně se svislou čárou."

# 2ea108160742444ba6abfeceaf695104
#: ../../home/kovid/work/calibre/manual/regexp.rst:77
msgid "You missed..."
msgstr "Zapomněl jsi..."

# 78c7fefa4d0e411582143fa9d73dede4
#: ../../home/kovid/work/calibre/manual/regexp.rst:79
msgid ""
"... wait just a minute, there's one last, really neat thing you can do with "
"groups. If you have a group that you previously matched, you can use "
"references to that group later in the expression: Groups are numbered "
"starting with 1, and you reference them by escaping the number of the group "
"you want to reference, thus, the fifth group would be referenced as ``\\5``."
" So, if you searched for ``([^ ]+) \\1`` in the string \"Test Test\", you'd "
"match the whole string!"
msgstr "... počkejte chvilku, je tu ještě jedna poslední, opravdu užitečná věc, kterou můžete dělat se skupinami. Pokud máte skupinu, kterou jste předtím porovnal, můžete použít odkazy na tuto skupinu později ve výrazu: Skupiny jsou číslovány od 1, a odkazujete na ně uvozením čísla skupiny, na kterou chcete odkázat, tedy pátá skupina by byla odkázána ``\\5``. Takže pokud jste hledali ``([^ ]+) \\1`` v řetězci \"Test Test\", porovnali byste celý řetězec!"

# 8c445a3da5144096b710c415e75d4834
#: ../../home/kovid/work/calibre/manual/regexp.rst:83
msgid ""
"In the beginning, you said there was a way to make a regular expression case"
" insensitive?"
msgstr "Na začátku jsi říkal, že existuje způsob, aby regulární výraz nerozlišoval malá a velká písmena?"

# 29be1ec38f854132b1a10db9727a807d
#: ../../home/kovid/work/calibre/manual/regexp.rst:85
msgid ""
"Yes, I did, thanks for paying attention and reminding me. You can tell |app|"
" how you want certain things handled by using something called flags. You "
"include flags in your expression by using the special construct ``(?flags go"
" here)`` where, obviously, you'd replace \"flags go here\" with the specific"
" flags you want. For ignoring case, the flag is ``i``, thus you include "
"``(?i)`` in your expression. Thus, ``test(?i)`` would match \"Test\", "
"\"tEst\", \"TEst\" and any case variation you could think of."
msgstr "Ano, říkal, díky za věnování pozornosti a připomenutí. Můžete říct |app|, jak chcete řešit některé věci pomocí tzv. vlajek. Vlajky zahrnete do svého výrazu pomocí speciální konstrukce ``(?sem přijdou vlajky)``, kde byste samozřejmě nahradili \"sem přijdou vlajky\" konkrétními vlajkami, které chcete. Pro ignorování velikosti písmen je vlajka ``i``, takže zahrnete do svého výrazu ``(?i)``. Takže ``test(?i)`` by porovnal \"Test\", \"tEst\", \"TEst\" a jakýkoliv případ variace si dokážete vymyslet."

# 355b4f94b54346ef92d3c35d3a3ee75c
#: ../../home/kovid/work/calibre/manual/regexp.rst:87
msgid ""
"Another useful flag lets the dot match any character at all, *including* the"
" newline, the flag ``s``. If you want to use multiple flags in an "
"expression, just put them in the same statement: ``(?is)`` would ignore case"
" and make the dot match all. It doesn't matter which flag you state first, "
"``(?si)`` would be equivalent to the above. By the way, good places for "
"putting flags in your expression would be either the very beginning or the "
"very end. That way, they don't get mixed up with anything else."
msgstr "Další užitečná vlajka umožňuje, aby tečka odpovídala všem libovolným znakům, *včetně* nového řádku, a to vlajka ``s``. Pokud chcete použít ve výrazu více vlajek, stačí je dát do stejného zápisu: ``(?is)`` by ignorovalo velikost písmen a tečka by odpovídala všemu. Nezáleží na tom, kterou vlajkou uvedete první, ``(?si)`` by bylo ekvivalentem výše uvedeného. Mimochodem, dobré místo pro uvádění vlajek ve vašem výrazu je buď úplně na začátku nebo úplně na konci. Takto se nezamíchají s ničím jiným."

# 66896505346b497594ae83d4b5e4f3fa
#: ../../home/kovid/work/calibre/manual/regexp.rst:90
msgid ""
"I think I'm beginning to understand these regular expressions now... how do "
"I use them in |app|?"
msgstr "Myslím, že teď už začínám ty regulární výrazy chápat... Jak je použiju v |app|?"

# c6d2768b90af47b7856ba7c83ac45a66
#: ../../home/kovid/work/calibre/manual/regexp.rst:93
msgid "Conversions"
msgstr "Převody"

# 937c678611b14e51897c38c867e49d3e
#: ../../home/kovid/work/calibre/manual/regexp.rst:95
msgid ""
"Let's begin with the conversion settings, which is really neat. In the "
"Search and Replace part, you can input a regexp (short for regular "
"expression) that describes the string that will be replaced during the "
"conversion. The neat part is the wizard. Click on the wizard staff and you "
"get a preview of what |app| \"sees\" during the conversion process. Scroll "
"down to the string you want to remove, select and copy it, paste it into the"
" regexp field on top of the window. If there are variable parts, like page "
"numbers or so, use sets and quantifiers to cover those, and while you're at "
"it, remember to escape special characters, if there are some. Hit the button"
" labeled :guilabel:`Test` and |app| highlights the parts it would replace "
"were you to use the regexp. Once you're satisfied, hit OK and convert. Be "
"careful if your conversion source has tags like this example::"
msgstr "Začněme s nastavením převodu, což je opravdu elegantní. Do části Hledat a nahradit můžete zadat regulární výraz, který popisuje řetězec, který bude při převodu nahrazen. Elegantní na tom je průvodce. Klikněte na kouzelnickou hůlku a získáte náhled toho, co |app| \"vidí\" během procesu převodu. Přejděte dolů na řetězec, který chcete odebrat, vyberte ho a zkopírujte, vložte ho do pole regulárního výrazu v horní části okna. Pokud jsou zde proměnné části, jako jsou čísla stránek nebo tak, použijte pro jejich pokrytí sady a kvantifikátory, a když už jsme u toho, nezapomeňte uvodit speciální znaky, pokud tu nějaké jsou. Stiskněte tlačítko označené :guilabel:`Testovat` a |app| zvýrazní části, které budou nahrazeny, pokud použijete regulární výraz. Jakmile jste spokojeni, klikněte na tlačítko OK a proveďte převod. Buďte opatrní, pokud váš zdroj převodu obsahuje značky, jako tento příklad::"

# a1ad640c84c246a48cc0d407eae47992
#: ../../home/kovid/work/calibre/manual/regexp.rst:105
msgid ""
"(shamelessly ripped out of `this thread "
"<http://www.mobileread.com/forums/showthread.php?t=75594\">`_). You'd have "
"to remove some of the tags as well. In this example, I'd recommend beginning"
" with the tag ``<b class=\"calibre2\">``, now you have to end with the "
"corresponding closing tag (opening tags are ``<tag>``, closing tags are "
"``</tag>``), which is simply the next ``</b>`` in this case. (Refer to a "
"good HTML manual or ask in the forum if you are unclear on this point.) The "
"opening tag can be described using ``<b.*?>``, the closing tag using "
"``</b>``, thus we could remove everything between those tags using "
"``<b.*?>.*?</b>``. But using this expression would be a bad idea, because it"
" removes everything enclosed by <b>- tags (which, by the way, render the "
"enclosed text in bold print), and it's a fair bet that we'll remove portions"
" of the book in this way. Instead, include the beginning of the enclosed "
"string as well, making the regular expression "
"``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` The ``\\s`` with"
" quantifiers are included here instead of explicitly using the spaces as "
"seen in the string to catch any variations of the string that might occur. "
"Remember to check what |app| will remove to make sure you don't remove any "
"portions you want to keep if you test a new expression. If you only check "
"one occurrence, you might miss a mismatch somewhere else in the text. Also "
"note that should you accidentally remove more or fewer tags than you "
"actually wanted to, |app| tries to repair the damaged code after doing the "
"removal."
msgstr "(nestydatě vytrženo z `tohoto vlákna <http://www.mobileread.com/forums/showthread.php?t=75594\">`_). Museli byste také odstranit některé značky. V tomto příkladu bych doporučoval začít značkou ``<b class=\"calibre2\">``, nyní budete muset skončit odpovídající uzavírací značkou (otevírací značky jsou ``<značka>``, uzavírací značky jsou ``</značka>``), což je v tomto případě jednoduše následující ``</b>``. (Podívejte se do dobré příručky k HTML nebo se zeptejte ve fóru, pokud si v tomto bodě nejste jisti.) Počáteční značku lze popsat pomocí ``<b.*?>``, uzavírací značku pomocí ``</b>``, takže bychom mohli odstranit vše mezi těmito značkami pomocí ``<b.*?>.*?</b>``. Ale použití tohoto výrazu by byl špatný nápad, protože odstraňuje vše, co je uzavřeno značkami <b> (který mimochodem vykreslí uzavřený text tučným písmem), a vsaďte se, že tímto způsobem odstraníme části knihy. Místo toho zahrňte i začátek uzavřeného řetězce, takže regulární výraz bude ``<b.*?>\\s*Vygeneroval\\s+ABC\\s+Amber\\s+LIT.*?</b>``.  ``\\s`` s kvantifikátory jsou zde zahrnuty namísto výslovného použití mezer, jak je vidět v řetězci, aby byly zachyceny všechny variace řetězce, které by mohly nastat. Nezapomeňte zkontrolovat, co |app| odstraní, když testuje nový výraz, abyste se ujistili, že neodstraníte žádné části, které chcete zachovat. Pokud zkontrolujete pouze jeden výskyt, může vám uniknout neshoda někde jinde v textu. Všimněte si také, že kdybyste omylem odstranili více nebo méně značek, než jste doopravdy chtěli, |app| se pokusí opravit poškozený kód po provedení odstranění."

# 1010ee85b826402c93a85f4e4d93ddb8
#: ../../home/kovid/work/calibre/manual/regexp.rst:108
msgid "Adding books"
msgstr "Přidávání knih"

# 19a2516e5c3f46eba12c14c01a027381
#: ../../home/kovid/work/calibre/manual/regexp.rst:110
msgid ""
"Another thing you can use regular expressions for is to extract metadata "
"from filenames. You can find this feature in the \"Adding books\" part of "
"the settings. There's a special feature here: You can use field names for "
"metadata fields, for example ``(?P<title>)`` would indicate that calibre "
"uses this part of the string as book title. The allowed field names are "
"listed in the windows, together with another nice test field. An example: "
"Say you want to import a whole bunch of files named like ``Classical Texts: "
"The Divine Comedy by Dante Alighieri.mobi``. (Obviously, this is already in "
"your library, since we all love classical italian poetry) or ``Science "
"Fiction epics: The Foundation Trilogy by Isaac Asimov.epub``. This is "
"obviously a naming scheme that |app| won't extract any meaningful data out "
"of - its standard expression for extracting metadata is ``(?P<title>.+) - "
"(?P<author>[^_]+)``. A regular expression that works here would be "
"``[a-zA-Z]+: (?P<title>.+) by (?P<author>.+)``. Please note that, inside the"
" group for the metadata field, you need to use expressions to describe what "
"the field actually matches. And also note that, when using the test field "
"|app| provides, you need to add the file extension to your testing filename,"
" otherwise you won't get any matches at all, despite using a working "
"expression."
msgstr "Další věc, ke které můžete použít regulární výrazy, je extrahování metadat z názvů souborů. Tuto funkci můžete najít v části nastavení \"Přidávání knih\". Je zde speciální funkce: Můžete použít názvy polí pro pole metadat, například ``(?P<title&gt;)`` by znamenalo, že Calibre použije tuto část řetězce jako název knihy. Povolené názvy polí jsou uvedeny v oknech, společně s dalším pěkným testovacím polem. Příklad: Řekněme, že chcete importovat spoustu souborů s názvem jako je ``Klasické texty: Božská komedie, Dante Alighieri.mobi``. (Samozřejmě, že tu už ve své knihovně máte, protože všichni milujeme klasickou italskou poezii) nebo ``Sci-fi eposy: Trilogie Nadace, Isaac Asimov.epub``. To je samozřejmě schéma názvů, ze kterého by |app| nevyextrahovalo žádná smysluplná data – standardní výraz pro extrahování metadat je ``(?P<title>.+) - (?P,author>[^_]+)``. Regulární výraz, který by tu fungoval, by byl ``[a-zA-Z]+: (?P<title>.+), (?P<author>.+)``. Všimněte si, že uvnitř skupiny pro pole metadat musíte použít výrazy k popisu toho, čemu pole skutečně odpovídá. A také si všimněte, že při použití testovacího pole, které |app| poskytuje, musíte přidat příponu souboru k testovanému souboru, jinak nezískáte vůbec žádnou shodu, i když použijete fungující výraz."

# 45be26d8787a43b78e8921a55a4c7e97
#: ../../home/kovid/work/calibre/manual/regexp.rst:114
msgid "Bulk editing metadata"
msgstr "Hromadná úprava metadat"

# e26d6971600c4b7a96b2438191c3398b
#: ../../home/kovid/work/calibre/manual/regexp.rst:116
msgid ""
"The last part is regular expression search and replace in metadata fields. "
"You can access this by selecting multiple books in the library and using "
"bulk metadata edit. Be very careful when using this last feature, as it can "
"do **Very Bad Things** to your library! Doublecheck that your expressions do"
" what you want them to using the test fields, and only mark the books you "
"really want to change! In the regular expression search mode, you can search"
" in one field, replace the text with something and even write the result "
"into another field. A practical example: Say your library contained the "
"books of Frank Herbert's Dune series, named after the fashion ``Dune 1 - "
"Dune``, ``Dune 2 - Dune Messiah`` and so on. Now you want to get ``Dune`` "
"into the series field. You can do that by searching for ``(.*?) \\d+ - .*`` "
"in the title field and replacing it with ``\\1`` in the series field. See "
"what I did there? That's a reference to the first group you're replacing the"
" series field with. Now that you have the series all set, you only need to "
"do another search for ``.*? -`` in the title field and replace it with "
"``\"\"`` (an empty string), again in the title field, and your metadata is "
"all neat and tidy. Isn't that great? By the way, instead of replacing the "
"entire field, you can also append or prepend to the field, so, if you "
"*wanted* the book title to be prepended with series info, you could do that "
"as well. As you by now have undoubtedly noticed, there's a checkbox labeled "
":guilabel:`Case sensitive`, so you won't have to use flags to select "
"behaviour here."
msgstr "Poslední část je hledání a nahrazování v polích metadat pomocí regulárního výrazu. K tomuto se můžete dostat výběrem více knih v knihovně a použitím hromadné úpravy metadat. Buďte velmi opatrní při používání této poslední funkce, protože může způsobit **velice špatné věci** vaší knihovně! Překontrolujte, že vaše výrazy dělají to, co chcete, pomocí testovacích polí, a označte pouze knihy, které opravdu chcete změnit! V režimu hledání regulárními výrazy můžete hledat v jednom poli, nahradit text něčím a dokonce zapsat výsledek do jiného pole. Praktický příklad: Řekněme, že vaše knihovna obsahuje knihy série Duna Franka Herberta pojmenované po vzoru ``Duna 1 - Duna``, ``Duna 2 - Spasitel Duny`` a tak dále. Nyní chcete dostat ``Duna`` do pole série. Můžete to udělat hledáním ``(.*?) \\d+ - .*`` v poli názvu a nahrazením ``\\1`` v poli série. Vidíte, co jsem udělal? To je odkaz na první skupinu, kterou nahrazujete pole série. Nyní, když máte sérii nastavenou, potřebujete jen provést další vyhledávání ``.*? -`` v poli názvu a nahrazením ``\"\"`` (prázdný řetězec) opět v poli názvu, a vaše metadata jsou jsou pěkně čistá a uklizená. Není to skvělé? Mimochodem, namísto nahrazení celého pole můžete také poli připojit nebo předřadit, takže pokud *chcete*, aby byla názvu knihy předřazena informace o sérii, mohli byste to udělat stejně. Jak jste si už nepochybně všimli, je zde zaškrtávací políčko označené :guilabel:`Rozlišovat malá a velká`, takže zde nebudete muset používat vlajky pro výběr chování."

# 9a3a42d3002a49acad03913d86bfbe12
#: ../../home/kovid/work/calibre/manual/regexp.rst:118
msgid ""
"Well, that just about concludes the very short introduction to regular "
"expressions. Hopefully I'll have shown you enough to at least get you "
"started and to enable you to continue learning by yourself- a good starting "
"point would be the `Python documentation for regexps "
"<http://docs.python.org/library/re.html>`_."
msgstr "No, je asi na čase uzavřít velice krátký úvod do regulárních výrazů. Doufám, že jsem vám ukázal dost, abyste alespoň mohli začít a umožnil vám pokračovat v samostatném učení – dobrým výchozím bodem je `Dokumentace Pythonu pro regulární výrazy <http://docs.python.org/library/re.html>`_."

# 02e166b4f67e4eca8637a8696d4a88bf
#: ../../home/kovid/work/calibre/manual/regexp.rst:120
msgid ""
"One last word of warning, though: Regexps are powerful, but also really easy"
" to get wrong. |app| provides really great testing possibilities to see if "
"your expressions behave as you expect them to. Use them. Try not to shoot "
"yourself in the foot. (God, I love that expression...) But should you, "
"despite the warning, injure your foot (or any other body parts), try to "
"learn from it."
msgstr "Ale ještě jedna poslední varování: Regulární výrazy jsou výkonné, ale také je velice snadné je pokazit. |app| poskytuje opravdu skvělé možnosti pro testování, abyste viděli, jestli se vaše výrazy chovat podle očekávání. Používejte je. Pokuste se nestřelit se do nohy. (Bože, tenhle výraz miluju...) Ale kdybyste si i přes varování poranili nohu (nebo jiné části těla), pokuste se z toho poučit."

# 29ff76f14ed549a2863c8c1ce00be7ca
#: ../../home/kovid/work/calibre/manual/regexp.rst:123
msgid "Credits"
msgstr "Poděkování"

# dddb9efdb1494d8db7b881cbcbd0715a
#: ../../home/kovid/work/calibre/manual/regexp.rst:125
msgid "Thanks for helping with tips, corrections and such:"
msgstr "Díky za pomoc s tipy, opravami a tak:"

# f2d40bfb844f448889ac5657000f31c5
#: ../../home/kovid/work/calibre/manual/regexp.rst:127
msgid "ldolse"
msgstr "ldolse"

# 09720d378b7143458739c135957d63ae
#: ../../home/kovid/work/calibre/manual/regexp.rst:128
msgid "kovidgoyal"
msgstr "kovidgoyal"

# 485b6b734735430e81e38f86207548c2
#: ../../home/kovid/work/calibre/manual/regexp.rst:129
msgid "chaley"
msgstr "chaley"

# fcf4dfa9e9414baea7bbca1b41b8ef76
#: ../../home/kovid/work/calibre/manual/regexp.rst:130
msgid "dwanthny"
msgstr "dwanthny"

# c6eaac14b789492cb4bec776d0602808
#: ../../home/kovid/work/calibre/manual/regexp.rst:131
msgid "kacir"
msgstr "kacir"

# e9415d5e765449e1a71f1418e2d53cf2
#: ../../home/kovid/work/calibre/manual/regexp.rst:132
msgid "Starson17"
msgstr "Starson17"

# bf46d2ccc40e4b9681f0031f965ed55d
#: ../../home/kovid/work/calibre/manual/regexp.rst:134
msgid ""
"For more about regexps see `The Python User Manual "
"<http://docs.python.org/library/re.html>`_."
msgstr "Více o regulárních výrazech najdete v `Uživatelské příručce Pythonu <http://docs.python.org/library/re.html>`_."
