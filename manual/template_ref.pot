# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: calibre 1.48.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-08-08 08:53+0530\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../template_ref.rst:6
# 7aac719b2f224be6a3d3520c8954bd58
msgid "Reference for all built-in template language functions"
msgstr ""

#: ../../template_ref.rst:8
# 5e33301806284322ba15577fc6a84c10
msgid "Here, we document all the built-in functions available in the |app| template language. Every function is implemented as a class in python and you can click the source links to see the source code, in case the documentation is insufficient. The functions are arranged in logical groups by type."
msgstr ""

#: ../../template_ref.rst:17
# faae71e52df04eedb6098d6d6f941881
msgid "Arithmetic"
msgstr ""

#: ../../template_ref.rst:20
# 161a2e38036d41fe8cdd50dd4d25a7d4
msgid "add(x, y)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinAdd:1
# e8c48dd538ee4c528098328367f1a080
msgid "add(x, y) -- returns x + y. Throws an exception if either x or y are not numbers."
msgstr ""

#: ../../template_ref.rst:25
# aca215b0187a41c1962ae8eb07b24e1a
msgid "divide(x, y)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinDivide:1
# 05ef8301c3dc451ca420066e493c5686
msgid "divide(x, y) -- returns x / y. Throws an exception if either x or y are not numbers."
msgstr ""

#: ../../template_ref.rst:30
# a1a49661bc3c487bad148143f0501209
msgid "multiply(x, y)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinMultiply:1
# 2dcd98fc7a414ae0a4c4dfdc9d412139
msgid "multiply(x, y) -- returns x * y. Throws an exception if either x or y are not numbers."
msgstr ""

#: ../../template_ref.rst:35
# 7b28aabe2842445798595c56e3e6f9f6
msgid "subtract(x, y)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinSubtract:1
# 5d813135e49149b98a4d60569c7d7083
msgid "subtract(x, y) -- returns x - y. Throws an exception if either x or y are not numbers."
msgstr ""

#: ../../template_ref.rst:40
# b74c2327d9e94747b40f57b918526413
msgid "Boolean"
msgstr ""

#: ../../template_ref.rst:43
# b31d7186734843c2a2f2b3108ad99b27
msgid "and(value, value, ...)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinAnd:1
# 2fa35e9821824a9e9590657de6e8e6b4
msgid "and(value, value, ...) -- returns the string \"1\" if all values are not empty, otherwise returns the empty string. This function works well with test or first_non_empty. You can have as many values as you want."
msgstr ""

#: ../../template_ref.rst:48
# 0c2d545ef6a44d4baa9057dfbd03b82e
msgid "not(value)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinNot:1
# 6787ef66385546e8970107842e5310dc
msgid "not(value) -- returns the string \"1\" if the value is empty, otherwise returns the empty string. This function works well with test or first_non_empty. You can have as many values as you want."
msgstr ""

#: ../../template_ref.rst:53
# 88ba3fa52e2546f6a002701ae5781d8a
msgid "or(value, value, ...)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinOr:1
# 88e65971df6245a58563b095c8d1ee89
msgid "or(value, value, ...) -- returns the string \"1\" if any value is not empty, otherwise returns the empty string. This function works well with test or first_non_empty. You can have as many values as you want."
msgstr ""

#: ../../template_ref.rst:58
# 7b6a0a15f297449ab402a61caaf3d94f
msgid "Date functions"
msgstr ""

#: ../../template_ref.rst:61
# 1253a27b8f7443149f885495678ecb7f
msgid "days_between(date1, date2)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinDaysBetween:1
# a4273e54ebaf4442817e47eb4cec2c42
msgid "days_between(date1, date2) -- return the number of days between date1 and date2. The number is positive if date1 is greater than date2, otherwise negative. If either date1 or date2 are not dates, the function returns the empty string."
msgstr ""

#: ../../template_ref.rst:66
# 4f0e48fb55764c09ba6d6ddd5b6a0989
msgid "today()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinToday:1
# fe681135d9b643968286a7c2611fb7c1
msgid "today() -- return a date string for today. This value is designed for use in format_date or days_between, but can be manipulated like any other string. The date is in ISO format."
msgstr ""

#: ../../template_ref.rst:71
# 65f4dd9028904afd93c1ecc2b13844b9
msgid "Formatting values"
msgstr ""

#: ../../template_ref.rst:74
# 2011bf940e054300a118b8fa17cdd5d4
msgid "finish_formatting(val, fmt, prefix, suffix)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinFinishFormatting:1
# 50f0807d7dda4ae287221c51f132b48e
msgid "finish_formatting(val, fmt, prefix, suffix) -- apply the format, prefix, and suffix to a value in the same way as done in a template like `{series_index:05.2f| - |- }`. For example, the following program produces the same output as the above template: program: finish_formatting(field(\"series_index\"), \"05.2f\", \" - \", \" - \")"
msgstr ""

#: ../../template_ref.rst:79
# c9ccb810ff554fdda5b6629b0028c5b3
msgid "format_date(val, format_string)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinFormatDate:1
# 30ac0c2aaf7f4f7f990cc8f6112a2a24
msgid "format_date(val, format_string) -- format the value, which must be a date, using the format_string, returning a string. The formatting codes are: d    : the day as number without a leading zero (1 to 31) dd   : the day as number with a leading zero (01 to 31) ddd  : the abbreviated localized day name (e.g. \"Mon\" to \"Sun\"). dddd : the long localized day name (e.g. \"Monday\" to \"Sunday\"). M    : the month as number without a leading zero (1 to 12). MM   : the month as number with a leading zero (01 to 12) MMM  : the abbreviated localized month name (e.g. \"Jan\" to \"Dec\"). MMMM : the long localized month name (e.g. \"January\" to \"December\"). yy   : the year as two digit number (00 to 99). yyyy : the year as four digit number. h    : the hours without a leading 0 (0 to 11 or 0 to 23, depending on am/pm) hh   : the hours with a leading 0 (00 to 11 or 00 to 23, depending on am/pm) m    : the minutes without a leading 0 (0 to 59) mm   : the minutes with a leading 0 (00 to 59) s    : the seconds without a leading 0 (0 to 59) ss   : the seconds with a leading 0 (00 to 59) ap   : use a 12-hour clock instead of a 24-hour clock, with \"ap\" replaced by the localized string for am or pm AP   : use a 12-hour clock instead of a 24-hour clock, with \"AP\" replaced by the localized string for AM or PM iso  : the date with time and timezone. Must be the only format present"
msgstr ""

#: ../../template_ref.rst:84
# 51b1a4a4f3fa4f1087050e9524fdd4f6
msgid "format_number(v, template)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinFormatNumber:1
# 563f257ccb9b4839baf1aad1de8cc2b6
msgid "format_number(v, template) -- format the number v using a python formatting template such as \"{0:5.2f}\" or \"{0:,d}\" or \"${0:5,.2f}\". The field_name part of the template must be a 0 (zero) (the \"{0:\" in the above examples). See the template language and python documentation for more examples. Returns the empty string if formatting fails."
msgstr ""

#: ../../template_ref.rst:89
# 5d6b18912c7e4667a1f460188c6e0da6
msgid "human_readable(v)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinHumanReadable:1
# 8ce00157db6d40dda3c91ba2b3752d9f
msgid "human_readable(v) -- return a string representing the number v in KB, MB, GB, etc."
msgstr ""

#: ../../template_ref.rst:94
# 16dcef32e6ed45eea2ff64371d928592
msgid "Get values from metadata"
msgstr ""

#: ../../template_ref.rst:97
# 478649789b774616bff54f4ebe389cb0
msgid "approximate_formats()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinApproximateFormats:1
# 63f75731f03d43ceb2ac0521897ba265
msgid "approximate_formats() -- return a comma-separated list of formats that at one point were associated with the book. There is no guarantee that this list is correct, although it probably is. This function can be called in template program mode using the template \"{:'approximate_formats()'}\". Note that format names are always uppercase, as in EPUB. This function works only in the GUI. If you want to use these values in save-to-disk or send-to-device templates then you must make a custom \"Column built from other columns\", use the function in that column's template, and use that column's value in your save/send templates"
msgstr ""

#: ../../template_ref.rst:102
# 62dd93987ec146a4aeff7a9587b7b0b6
msgid "author_links(val_separator, pair_separator)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinAuthorLinks:1
# 034b0c7cfb7740489725d0400cd59206
msgid "author_links(val_separator, pair_separator) -- returns a string containing a list of authors and that author's link values in the form author1 val_separator author1link pair_separator author2 val_separator author2link etc. An author is separated from its link value by the val_separator string with no added spaces. author:linkvalue pairs are separated by the pair_separator string argument with no added spaces. It is up to you to choose separator strings that do not occur in author names or links. An author is included even if the author link is empty."
msgstr ""

#: ../../template_ref.rst:107
# 5984448bccbb4997bd8108ca904c4ecd
msgid "booksize()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinBooksize:1
# 5c58f5f359ce4a49b8884304a86ac7fc
msgid "booksize() -- return value of the size field. This function works only in the GUI. If you want to use this value in save-to-disk or send-to-device templates then you must make a custom \"Column built from other columns\", use the function in that column's template, and use that column's value in your save/send templates"
msgstr ""

#: ../../template_ref.rst:112
# d333f30e46ca44d2b0d817ec375cb6e9
msgid "current_library_name()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinCurrentLibraryName:1
# a4e8dd391617426f8bb350abd1af125b
msgid "current_library_name() -- return the last name on the path to the current calibre library. This function can be called in template program mode using the template \"{:'current_library_name()'}\"."
msgstr ""

#: ../../template_ref.rst:117
# c270a34b8fde4c8494d9ad91778fb197
msgid "current_library_path()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinCurrentLibraryPath:1
# 47f3947effb54682a5073936ae6fb95d
msgid "current_library_path() -- return the path to the current calibre library. This function can be called in template program mode using the template \"{:'current_library_path()'}\"."
msgstr ""

#: ../../template_ref.rst:122
# 4306ae1a520844f5982f74f0e99374af
msgid "field(name)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinField:1
# 6a977d0d47e447cf889deb67cd25b6e4
msgid "field(name) -- returns the metadata field named by name"
msgstr ""

#: ../../template_ref.rst:127
# d7787f08e5234581b99b718ee0be51c7
msgid "formats_modtimes(date_format)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinFormatsModtimes:1
# e8511948368140de8ceec0a9416a8265
msgid "formats_modtimes(date_format) -- return a comma-separated list of colon_separated items representing modification times for the formats of a book. The date_format parameter specifies how the date is to be formatted. See the date_format function for details. You can use the select function to get the mod time for a specific format. Note that format names are always uppercase, as in EPUB."
msgstr ""

#: ../../template_ref.rst:132
# b5062e1d1a2643708da41009e2e4e869
msgid "formats_paths()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinFormatsPaths:1
# 921df356623046258bb328f9d74d1e47
msgid "formats_paths() -- return a comma-separated list of colon_separated items representing full path to the formats of a book. You can use the select function to get the path for a specific format. Note that format names are always uppercase, as in EPUB."
msgstr ""

#: ../../template_ref.rst:137
# e741e631c8d64ce3b4adc2c9e8d004e5
msgid "formats_sizes()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinFormatsSizes:1
# 14108a85a84e416e8cddd7f629d2b429
msgid "formats_sizes() -- return a comma-separated list of colon_separated items representing sizes in bytes of the formats of a book. You can use the select function to get the size for a specific format. Note that format names are always uppercase, as in EPUB."
msgstr ""

#: ../../template_ref.rst:142
# 242b8e8a30654c43983041ab484fada6
msgid "has_cover()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinHasCover:1
# 1dabe5a295d742ad80e31c7529b961c6
msgid "has_cover() -- return Yes if the book has a cover, otherwise return the empty string"
msgstr ""

#: ../../template_ref.rst:147
# c8ecb28adb2d441fb65dd954d7f4e2eb
msgid "language_codes(lang_strings)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinLanguageCodes:1
# c8245faa0a354f739cc6da6b22aabd11
msgid "language_codes(lang_strings) -- return the language codes for the strings passed in lang_strings. The strings must be in the language of the current locale. Lang_strings is a comma-separated list."
msgstr ""

#: ../../template_ref.rst:152
# 4d07a94fbb5a422ab9239d29f819928b
msgid "language_strings(lang_codes, localize)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinLanguageStrings:1
# 051c87b0d9394fbc943fbcae4f2391f7
msgid "language_strings(lang_codes, localize) -- return the strings for the language codes passed in lang_codes. If localize is zero, return the strings in English. If localize is not zero, return the strings in the language of the current locale. Lang_codes is a comma-separated list."
msgstr ""

#: ../../template_ref.rst:157
# 0bde2f184fab45d0a925e85f252563f7
msgid "ondevice()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinOndevice:1
# 0b0f0ba301f74538a25cb10435d06e95
msgid "ondevice() -- return Yes if ondevice is set, otherwise return the empty string. This function works only in the GUI. If you want to use this value in save-to-disk or send-to-device templates then you must make a custom \"Column built from other columns\", use the function in that column's template, and use that column's value in your save/send templates"
msgstr ""

#: ../../template_ref.rst:162
# df644a733def4d66b9fc69c5b5982f2b
msgid "raw_field(name)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinRawField:1
# 06b6737e47414ffc8a937dc1013440c5
msgid "raw_field(name) -- returns the metadata field named by name without applying any formatting."
msgstr ""

#: ../../template_ref.rst:167
# b613c972c0b147719066175ab7d40444
msgid "series_sort()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinSeriesSort:1
# cc2a92b4f2fe4728978ebc7895713736
msgid "series_sort() -- return the series sort value"
msgstr ""

#: ../../template_ref.rst:172
# df1bb19a3b414536ae90fcc694c7d4a0
msgid "virtual_libraries()"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinVirtualLibraries:1
# 930660af0ed44dd68d2705225572d4df
msgid "virtual_libraries() -- return a comma-separated list of virtual libraries that contain this book. This function works only in the GUI. If you want to use these values in save-to-disk or send-to-device templates then you must make a custom \"Column built from other columns\", use the function in that column's template, and use that column's value in your save/send templates"
msgstr ""

#: ../../template_ref.rst:177
# e2c98676643942bf8db1070ad656f8c7
msgid "If-then-else"
msgstr ""

#: ../../template_ref.rst:180
# 179b9ac20c164d26aaecfa35c0152c06
msgid "contains(val, pattern, text if match, text if not match)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinContains:1
# 0945dae6cb9e4c6da7c50050a487d39a
msgid "contains(val, pattern, text if match, text if not match) -- checks if field contains matches for the regular expression `pattern`. Returns `text if match` if matches are found, otherwise it returns `text if no match`"
msgstr ""

#: ../../template_ref.rst:185
# f0c45d6f36a743bfb951076a2589f775
msgid "ifempty(val, text if empty)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinIfempty:1
# 80e5d9f995964e678f8262fe5ae8cbc4
msgid "ifempty(val, text if empty) -- return val if val is not empty, otherwise return `text if empty`"
msgstr ""

#: ../../template_ref.rst:190
# b696d6bb7f1f43809998f057e1fe1c3d
msgid "test(val, text if not empty, text if empty)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinTest:1
# 53fb61e3a7b54adfa9a883674cf7fef9
msgid "test(val, text if not empty, text if empty) -- return `text if not empty` if the field is not empty, otherwise return `text if empty`"
msgstr ""

#: ../../template_ref.rst:195
# 17111c12e247482e906dab1f064f7d54
msgid "Iterating over values"
msgstr ""

#: ../../template_ref.rst:198
# 81c28c2b7b204039a6ac914c02f81924
msgid "first_non_empty(value, value, ...)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinFirstNonEmpty:1
# 849784ccbce64969be4c4105397b7fa9
msgid "first_non_empty(value, value, ...) -- returns the first value that is not empty. If all values are empty, then the empty value is returned. You can have as many values as you want."
msgstr ""

#: ../../template_ref.rst:203
# 83474080306943ffaee918f9c829ef44
msgid "lookup(val, pattern, field, pattern, field, ..., else_field)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinLookup:1
# dc19a62c32b3464bbd333135b3eda781
msgid "lookup(val, pattern, field, pattern, field, ..., else_field) -- like switch, except the arguments are field (metadata) names, not text. The value of the appropriate field will be fetched and used. Note that because composite columns are fields, you can use this function in one composite field to use the value of some other composite field. This is extremely useful when constructing variable save paths"
msgstr ""

#: ../../template_ref.rst:208
# 0e9000a8481b4f5b9498074617bc4c79
msgid "switch(val, pattern, value, pattern, value, ..., else_value)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinSwitch:1
# 2e45daec376b4a4a9feaf52951533f3f
msgid "switch(val, pattern, value, pattern, value, ..., else_value) -- for each `pattern, value` pair, checks if the field matches the regular expression `pattern` and if so, returns that `value`. If no pattern matches, then else_value is returned. You can have as many `pattern, value` pairs as you want"
msgstr ""

#: ../../template_ref.rst:213
# 3ad43b97504e4935959daf89b42a04d2
msgid "List lookup"
msgstr ""

#: ../../template_ref.rst:216
# 0df326ffc872451f8842671f31c9d709
msgid "identifier_in_list(val, id, found_val, not_found_val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinIdentifierInList:1
# 80b02b7f92194e94a8c190f63f2858a0
msgid "identifier_in_list(val, id, found_val, not_found_val) -- treat val as a list of identifiers separated by commas, comparing the string against each value in the list. An identifier has the format \"identifier:value\". The id parameter should be either \"id\" or \"id:regexp\". The first case matches if there is any identifier with that id. The second case matches if the regexp matches the identifier's value. If there is a match, return found_val, otherwise return not_found_val."
msgstr ""

#: ../../template_ref.rst:221
# 635a0420a89b4027afcf248dfe18c60b
msgid "in_list(val, separator, pattern, found_val, not_found_val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinInList:1
# 7ddc879f4e3448579d1dcacf3787a698
msgid "in_list(val, separator, pattern, found_val, not_found_val) -- treat val as a list of items separated by separator, comparing the pattern against each value in the list. If the pattern matches a value, return found_val, otherwise return not_found_val."
msgstr ""

#: ../../template_ref.rst:226
# 0bff3de398e6489eac9e6e3c98410820
msgid "list_item(val, index, separator)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinListitem:1
# 18d176a9f6b345bcaa7e6d7bbc84e6e4
msgid "list_item(val, index, separator) -- interpret the value as a list of items separated by `separator`, returning the `index`th item. The first item is number zero. The last item can be returned using `list_item(-1,separator)`. If the item is not in the list, then the empty value is returned. The separator has the same meaning as in the count function."
msgstr ""

#: ../../template_ref.rst:231
# f1ec26b96b5a4362b7dfb66366cb0593
msgid "select(val, key)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinSelect:1
# 0d0d1fa208d74c638c3a121db82ba684
msgid "select(val, key) -- interpret the value as a comma-separated list of items, with the items being \"id:value\". Find the pair with the id equal to key, and return the corresponding value."
msgstr ""

#: ../../template_ref.rst:236
# e9e409e0013d4b30af6943df4ead3d4d
msgid "str_in_list(val, separator, string, found_val, not_found_val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinStrInList:1
# 74c78e1d3cb144e9b3960a6b363b830e
msgid "str_in_list(val, separator, string, found_val, not_found_val) -- treat val as a list of items separated by separator, comparing the string against each value in the list. If the string matches a value, return found_val, otherwise return not_found_val. If the string contains separators, then it is also treated as a list and each value is checked."
msgstr ""

#: ../../template_ref.rst:241
# 4ccddc5e4de7434e81adec531de91d58
msgid "List manipulation"
msgstr ""

#: ../../template_ref.rst:244
# 99175fd3b2c54067b26d8959e2ea0085
msgid "count(val, separator)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinCount:1
# e7006f17d2794b9ea826d387d387ae3f
msgid "count(val, separator) -- interprets the value as a list of items separated by `separator`, returning the number of items in the list. Most lists use a comma as the separator, but authors uses an ampersand. Examples: {tags:count(,)}, {authors:count(&)}"
msgstr ""

#: ../../template_ref.rst:249
# 0df423f941014ba89aa3e487e5e417b2
msgid "list_difference(list1, list2, separator)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinListDifference:1
# e20ecf96a2704323a0f71df4b9c49abe
msgid "list_difference(list1, list2, separator) -- return a list made by removing from list1 any item found in list2, using a case-insensitive compare. The items in list1 and list2 are separated by separator, as are the items in the returned list."
msgstr ""

#: ../../template_ref.rst:254
# f77a88c83ceb4913bddc908dc0541d0c
msgid "list_equals(list1, sep1, list2, sep2, yes_val, no_val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinListEquals:1
# 1174917b0e4d4e4fb7f284a186f32fd4
msgid "list_equals(list1, sep1, list2, sep2, yes_val, no_val) -- return yes_val if list1 and list2 contain the same items, otherwise return no_val. The items are determined by splitting each list using the appropriate separator character (sep1 or sep2). The order of items in the lists is not relevant. The compare is case insensitive."
msgstr ""

#: ../../template_ref.rst:259
# fbb89c38ea25437982d87ab61fa9451a
msgid "list_intersection(list1, list2, separator)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinListIntersection:1
# d9d8cbb4b6b04b0bb046210df18f5b3a
msgid "list_intersection(list1, list2, separator) -- return a list made by removing from list1 any item not found in list2, using a case-insensitive compare. The items in list1 and list2 are separated by separator, as are the items in the returned list."
msgstr ""

#: ../../template_ref.rst:264
# 8a6a1f2a03e14f5694807e0964dc0e6f
msgid "list_re(src_list, separator, include_re, opt_replace)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinListRe:1
# 03dc418765354fbdb917678d5843962a
msgid "list_re(src_list, separator, include_re, opt_replace) -- Construct a list by first separating src_list into items using the separator character. For each item in the list, check if it matches include_re. If it does, then add it to the list to be returned. If opt_replace is not the empty string, then apply the replacement before adding the item to the returned list."
msgstr ""

#: ../../template_ref.rst:269
# a81ff9a5eed14f48bae0c1c18fb89b0e
msgid "list_re_group(src_list, separator, include_re, search_re, group_1_template, ...)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinListReGroup:1
# 0ef641c8e0f4436dbed7d05d95dda814
msgid "list_re_group(src_list, separator, include_re, search_re, group_1_template, ...) -- Like list_re except replacements are not optional. It uses re_group(list_item, search_re, group_1_template, ...) when doing the replacements on the resulting list."
msgstr ""

#: ../../template_ref.rst:274
# 853045c7be814f9ca85735dd0f8b9e39
msgid "list_sort(list, direction, separator)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinListSort:1
# 5d781f191cdb4e9b9e5984c5c70729e2
msgid "list_sort(list, direction, separator) -- return list sorted using a case-insensitive sort. If direction is zero, the list is sorted ascending, otherwise descending. The list items are separated by separator, as are the items in the returned list."
msgstr ""

#: ../../template_ref.rst:279
# 8196412fa91d4c24bc379e83e9ca29ec
msgid "list_union(list1, list2, separator)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinListUnion:1
# c2ae9b628d8a4b92b9e69e10c7952101
msgid "list_union(list1, list2, separator) -- return a list made by merging the items in list1 and list2, removing duplicate items using a case-insensitive compare. If items differ in case, the one in list1 is used. The items in list1 and list2 are separated by separator, as are the items in the returned list."
msgstr ""

#: ../../template_ref.rst:284
# 491cb329b2d1433c9da6a851b45d3a8d
msgid "subitems(val, start_index, end_index)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinSubitems:1
# ff2567b480584c639d63606519b357bb
msgid "subitems(val, start_index, end_index) -- This function is used to break apart lists of items such as genres. It interprets the value as a comma-separated list of items, where each item is a period-separated list. Returns a new list made by first finding all the period-separated items, then for each such item extracting the `start_index` to the `end_index` components, then combining the results back together. The first component in a period-separated list has an index of zero. If an index is negative, then it counts from the end of the list. As a special case, an end_index of zero is assumed to be the length of the list. Example using basic template mode and assuming a #genre value of \"A.B.C\": {#genre:subitems(0,1)} returns \"A\". {#genre:subitems(0,2)} returns \"A.B\". {#genre:subitems(1,0)} returns \"B.C\". Assuming a #genre value of \"A.B.C, D.E.F\", {#genre:subitems(0,1)} returns \"A, D\". {#genre:subitems(0,2)} returns \"A.B, D.E\""
msgstr ""

#: ../../template_ref.rst:289
# adbdee1de2824797b0acfab42e9e3392
msgid "sublist(val, start_index, end_index, separator)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinSublist:1
# f02b301e9e024dc3b04cfef7e8966d5f
msgid "sublist(val, start_index, end_index, separator) -- interpret the value as a list of items separated by `separator`, returning a new list made from the `start_index` to the `end_index` item. The first item is number zero. If an index is negative, then it counts from the end of the list. As a special case, an end_index of zero is assumed to be the length of the list. Examples using basic template mode and assuming that the tags column (which is comma-separated) contains \"A, B, C\": {tags:sublist(0,1,\\,)} returns \"A\". {tags:sublist(-1,0,\\,)} returns \"C\". {tags:sublist(0,-1,\\,)} returns \"A, B\"."
msgstr ""

#: ../../template_ref.rst:294
# 2a8fa95ea13b4a889fb1e7f293d3bfcf
msgid "Other"
msgstr ""

#: ../../template_ref.rst:297
# 5a412c057daf44b2a257f58b2e4c8332
msgid "assign(id, val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinAssign:1
# ec38043e2b364c9b84334e99a90db9a3
msgid "assign(id, val) -- assigns val to id, then returns val. id must be an identifier, not an expression"
msgstr ""

#: ../../template_ref.rst:302
# ca26dac330244c8face271daf0722cd2
msgid "print(a, b, ...)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinPrint:1
# 3edfc90f549e40e59aa0ef02cd2c46ea
msgid "print(a, b, ...) -- prints the arguments to standard output. Unless you start calibre from the command line (calibre-debug -g), the output will go to a black hole."
msgstr ""

#: ../../template_ref.rst:307
# b28133dad1dd41048bf04f0325c98b75
msgid "Recursion"
msgstr ""

#: ../../template_ref.rst:310
# b36d44e8bb6249d9868270f259aa08db
msgid "eval(template)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinEval:1
# 56b9f79dcf71496e9567d992567c3140
msgid "eval(template) -- evaluates the template, passing the local variables (those 'assign'ed to) instead of the book metadata.  This permits using the template processor to construct complex results from local variables. Because the { and } characters are special, you must use [[ for the { character and ]] for the } character; they are converted automatically. Note also that prefixes and suffixes (the `|prefix|suffix` syntax) cannot be used in the argument to this function when using template program mode."
msgstr ""

#: ../../template_ref.rst:315
# 96e3780989fb49a8a98e95543dae578f
msgid "template(x)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinTemplate:1
# 4b630147000e449591560f50ad988077
msgid "template(x) -- evaluates x as a template. The evaluation is done in its own context, meaning that variables are not shared between the caller and the template evaluation. Because the { and } characters are special, you must use [[ for the { character and ]] for the } character; they are converted automatically. For example, template('[[title_sort]]') will evaluate the template {title_sort} and return its value. Note also that prefixes and suffixes (the `|prefix|suffix` syntax) cannot be used in the argument to this function when using template program mode."
msgstr ""

#: ../../template_ref.rst:320
# d14dbbd3097d4a12a11788017a094486
msgid "Relational"
msgstr ""

#: ../../template_ref.rst:323
# 737c03e77fcd4d34ab7aa4381ee24caa
msgid "cmp(x, y, lt, eq, gt)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinCmp:1
# 50aaeb3cda504c099fd3a947dc7bd7b3
msgid "cmp(x, y, lt, eq, gt) -- compares x and y after converting both to numbers. Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr ""

#: ../../template_ref.rst:328
# 31672f824a2c4cb8b6a145c3312a39cc
msgid "first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinFirstMatchingCmp:1
# d5d320bc38eb4d8dabf0873a39169741
msgid "first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result) -- compares \"val < cmpN\" in sequence, returning resultN for the first comparison that succeeds. Returns else_result if no comparison succeeds. Example: first_matching_cmp(10,5,\"small\",10,\"middle\",15,\"large\",\"giant\") returns \"large\". The same example with a first value of 16 returns \"giant\"."
msgstr ""

#: ../../template_ref.rst:333
# 96159778e5b444c1bce59cbd0254b2f4
msgid "strcmp(x, y, lt, eq, gt)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinStrcmp:1
# 7a5876d42dd94f25ab6d532cf4dc6d76
msgid "strcmp(x, y, lt, eq, gt) -- does a case-insensitive comparison of x and y as strings. Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr ""

#: ../../template_ref.rst:338
# 4bd07fb858504bf4ae5842c212491507
msgid "String case changes"
msgstr ""

#: ../../template_ref.rst:341
# e0931fe55c114babbdc239b77bcca503
msgid "capitalize(val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinCapitalize:1
# ab445587e4684972877d770d2181906b
msgid "capitalize(val) -- return value of the field capitalized"
msgstr ""

#: ../../template_ref.rst:346
# ae4492b7cb374bf2b33292c12d761414
msgid "lowercase(val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinLowercase:1
# 242261876a6847d193ef32b48f272143
msgid "lowercase(val) -- return value of the field in lower case"
msgstr ""

#: ../../template_ref.rst:351
# 57d4009b9aa248229cf5c1c41b18651a
msgid "titlecase(val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinTitlecase:1
# c2ab4cfbdbac4b36a4394c4492612488
msgid "titlecase(val) -- return value of the field in title case"
msgstr ""

#: ../../template_ref.rst:356
# dbc66f0963564991bf2a92ec4076b4e3
msgid "uppercase(val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinUppercase:1
# 7e55f27cd69a4bf0803e2b21580763ef
msgid "uppercase(val) -- return value of the field in upper case"
msgstr ""

#: ../../template_ref.rst:361
# a602d705ff2a4f2192827b8dcb394e98
msgid "String manipulation"
msgstr ""

#: ../../template_ref.rst:364
# 41dc489a6dc347169b03cdcdeaa98642
msgid "re(val, pattern, replacement)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinRe:1
# 407a3debba8d439aaa78a194afae15df
msgid "re(val, pattern, replacement) -- return the field after applying the regular expression. All instances of `pattern` are replaced with `replacement`. As in all of calibre, these are python-compatible regular expressions"
msgstr ""

#: ../../template_ref.rst:369
# 01f2023a57d4419f85e18744058d75fd
msgid "re_group(val, pattern, template_for_group_1, for_group_2, ...)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinReGroup:1
# d523934338db453392cedea7f1b32d15
msgid "re_group(val, pattern, template_for_group_1, for_group_2, ...) -- return a string made by applying the reqular expression pattern to the val and replacing each matched instance with the string computed by replacing each matched group by the value returned by the corresponding template. The original matched value for the group is available as $. In template program mode, like for the template and the eval functions, you use [[ for { and ]] for }. The following example in template program mode looks for series with more than one word and uppercases the first word: {series:'re_group($, \"(\\S* )(.*)\", \"[[$:uppercase()]]\", \"[[$]]\")'}"
msgstr ""

#: ../../template_ref.rst:374
# 761ea46d217d45bd8e3c95f8ab5e0c9a
msgid "shorten(val, left chars, middle text, right chars)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinShorten:1
# 8038808c9e2149a78eae683c6e037f89
msgid "shorten(val, left chars, middle text, right chars) -- Return a shortened version of the field, consisting of `left chars` characters from the beginning of the field, followed by `middle text`, followed by `right chars` characters from the end of the string. `Left chars` and `right chars` must be integers. For example, assume the title of the book is `Ancient English Laws in the Times of Ivanhoe`, and you want it to fit in a space of at most 15 characters. If you use {title:shorten(9,-,5)}, the result will be `Ancient E-nhoe`. If the field's length is less than left chars + right chars + the length of `middle text`, then the field will be used intact. For example, the title `The Dome` would not be changed."
msgstr ""

#: ../../template_ref.rst:379
# 050dcd91f2e14dbfb30aee40af978cf4
msgid "strcat(a, b, ...)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinStrcat:1
# 4e7bf836b8b84ec09d6ffdfab5f241ae
msgid "strcat(a, b, ...) -- can take any number of arguments. Returns a string formed by concatenating all the arguments"
msgstr ""

#: ../../template_ref.rst:384
# b5c58f94f2464baea0aeafdbe0c265d8
msgid "strcat_max(max, string1, prefix2, string2, ...)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinStrcatMax:1
# 792426e778ee4ab7833a24373bf2a06b
msgid "strcat_max(max, string1, prefix2, string2, ...) -- Returns a string formed by concatenating the arguments. The returned value is initialized to string1. `Prefix, string` pairs are added to the end of the value as long as the resulting string length is less than `max`. String1 is returned even if string1 is longer than max. You can pass as many `prefix, string` pairs as you wish."
msgstr ""

#: ../../template_ref.rst:389
# 1699c971fc49422b9b36c0ffd717b910
msgid "strlen(a)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinStrlen:1
# d23ce45383d142849407cbe64e3c5b72
msgid "strlen(a) -- Returns the length of the string passed as the argument"
msgstr ""

#: ../../template_ref.rst:394
# 1c5ba1267c24481ca515213d73d657e6
msgid "substr(str, start, end)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinSubstr:1
# 02ca4e43292c42a2ac6ae0e565848619
msgid "substr(str, start, end) -- returns the start'th through the end'th characters of str. The first character in str is the zero'th character. If end is negative, then it indicates that many characters counting from the right. If end is zero, then it indicates the last character. For example, substr('12345', 1, 0) returns '2345', and substr('12345', 1, -1) returns '234'."
msgstr ""

#: ../../template_ref.rst:399
# be9afddd290446a9afbb76d914324950
msgid "swap_around_comma(val)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinSwapAroundComma:1
# cd3eff0f41a9434482033ff026466a49
msgid "swap_around_comma(val) -- given a value of the form \"B, A\", return \"A B\". This is most useful for converting names in LN, FN format to FN LN. If there is no comma, the function returns val unchanged"
msgstr ""

#: ../../template_ref.rst:404
# be1b7703f0574984b259babd03a15d4e
msgid "transliterate(a)"
msgstr ""

#: ../../../src/calibre/utils/formatter_functions.py:docstring of calibre.utils.formatter_functions.BuiltinTransliterate:1
# ddf48add58844a90b70de72a96763d1d
msgid "transliterate(a) -- Returns a string in a latin alphabet formed by approximating the sound of the words in the source string. For example, if the source is \"Фёдор Миха́йлович Достоевский\" the function returns \"Fiodor Mikhailovich Dostoievskii\"."
msgstr ""

#: ../../template_ref.rst:410
# 3730f1d6f10f428489fcf9fad6343cb5
msgid "API of the Metadata objects"
msgstr ""

#: ../../template_ref.rst:412
# 9e340b074de64dcaaaa96d6ad14471c6
msgid "The python implementation of the template functions is passed in a Metadata object. Knowing it's API is useful if you want to define your own template functions."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata:1
# 889f15c9b11e4704ab97682ab4e0bd41
msgid "A class representing all the metadata for a book. The various standard metadata fields are available as attributes of this object. You can also stick arbitrary attributes onto this object."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata:5
# 56216d40eea3459bac3ef53d19a18bf0
msgid "Metadata from custom columns should be accessed via the get() method, passing in the lookup name for the column, for example: \"#mytags\"."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata:8
# 029f4fe21c6d439db66c142cd0e58108
msgid "Use the :meth:`is_null` method to test if a field is null."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata:10
# afa5ca7e971944d3a903ca707be818bd
msgid "This object also has functions to format fields into strings."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata:12
# ee10e28ff97640a8a8d31dd825d0c86a
msgid "The list of standard metadata fields grows with time is in :data:`STANDARD_METADATA_FIELDS`."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata:15
# 26f80927a91c47ae9a733a515a0be64c
msgid "Please keep the method based API of this class to a minimum. Every method becomes a reserved field name."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.is_null:1
# e70218551cc947a6bcac4760659f3066
msgid "Return True if the value of field is null in this object. 'null' means it is unknown or evaluates to False. So a title of _('Unknown') is null or a language of 'und' is null."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.is_null:5
# 28f735a193e44c35a875892535458eac
msgid "Be careful with numeric fields since this will return True for zero as well as None."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.is_null:8
# bda6b3c6a91e4e8c9076cbda5dbb50ca
msgid "Also returns True if the field does not exist."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.deepcopy:1
# 33d2606768744d5bb9561dc3ee1b91cc
msgid "Do not use this method unless you know what you are doing, if you want to create a simple clone of this object, use :meth:`deepcopy_metadata` instead. Class_generator must be a function that returns an instance of Metadata or a subclass of it."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.get_identifiers:1
# c77abcbf59be42f1aeef71dd94ea96e2
msgid "Return a copy of the identifiers dictionary. The dict is small, and the penalty for using a reference where a copy is needed is large. Also, we don't want any manipulations of the returned dict to show up in the book."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.set_identifiers:1
# 4c47ad05ce7b455a9bf774657ef0e612
msgid "Set all identifiers. Note that if you previously set ISBN, calling this method will delete it."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.set_identifier:1
# cea17a2a65964bdab556f60edb354048
msgid "If val is empty, deletes identifier of type typ"
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.standard_field_keys:1
# 13155eba1eae408ca116757c52b31a52
msgid "return a list of all possible keys, even if this book doesn't have them"
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.custom_field_keys:1
# 3d0394a5fb25432784506bf1eb0f99e0
msgid "return a list of the custom fields in this book"
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.all_field_keys:1
# 4c4c239fbdbc4644b4c33cb100447b33
msgid "All field keys known by this instance, even if their value is None"
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.metadata_for_field:1
# c8319b13e1794a279b727b83c3390700
msgid "return metadata describing a standard or custom field."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.all_non_none_fields:1
# b162a718491f4028ba98e09597a8c5f7
msgid "Return a dictionary containing all non-None metadata fields, including the custom ones."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.get_standard_metadata:1
# 50037ed46ec14e188dcc883264cdb634
msgid "return field metadata from the field if it is there. Otherwise return None. field is the key name, not the label. Return a copy if requested, just in case the user wants to change values in the dict."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.get_all_standard_metadata:1
# 94f0019a5e164a38a1586dc8db5b513e
msgid "return a dict containing all the standard field metadata associated with the book."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.get_all_user_metadata:1
# 6deff1d2995646c38c43d1a27eeb8dd4
msgid "return a dict containing all the custom field metadata associated with the book."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.get_user_metadata:1
# abf875d2ce1e4af88f56f4c49d81b992
msgid "return field metadata from the object if it is there. Otherwise return None. field is the key name, not the label. Return a copy if requested, just in case the user wants to change values in the dict."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.set_all_user_metadata:1
# 88ad0c6e07404588b07da20e44c22c25
msgid "store custom field metadata into the object. Field is the key name not the label"
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.set_user_metadata:1
# a8b21701379044e787a6508c1d32b177
msgid "store custom field metadata for one column into the object. Field is the key name not the label"
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.template_to_attribute:1
# d331a3c5198c4db8a1fcc773687f81fe
msgid "Takes a list [(src,dest), (src,dest)], evaluates the template in the context of other, then copies the result to self[dest]. This is on a best-efforts basis. Some assignments can make no sense."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.smart_update:1
# f328117aff554bb89db71bdd17e5f07a
msgid "Merge the information in `other` into self. In case of conflicts, the information in `other` takes precedence, unless the information in `other` is NULL."
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.format_field:1
# e43f4700407a465c9df0c6a7ba47d642
msgid "Returns the tuple (display_name, formatted_value)"
msgstr ""

#: ../../../src/calibre/ebooks/metadata/book/base.py:docstring of calibre.ebooks.metadata.book.base.Metadata.to_html:1
# c70460c9741b4b2cb2ce46d007303a02
msgid "A HTML representation of this object."
msgstr ""

#: ../../template_ref.rst:422
# 17218141e5854e46b08a72ad0b14b3cb
msgid "The set of standard metadata fields."
msgstr ""

