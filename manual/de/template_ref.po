# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# Ettore Atalan <atalanttore@googlemail.com>, 2014
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-08-01 08:15+0530\n"
"PO-Revision-Date: 2014-08-01 02:47+0000\n"
"Last-Translator: Kovid Goyal <kovid@kovidgoyal.net>\n"
"Language-Team: German (http://www.transifex.com/projects/p/calibre/language/de/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: de\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# c5f00e307a014018a955879150ccef26
#: ../../template_ref.rst:6
msgid "Reference for all built-in template language functions"
msgstr ""

# 2f2cc5f057e14ef9a06c46103f78474c
#: ../../template_ref.rst:8
msgid ""
"Here, we document all the built-in functions available in the |app| template"
" language. Every function is implemented as a class in python and you can "
"click the source links to see the source code, in case the documentation is "
"insufficient. The functions are arranged in logical groups by type."
msgstr ""

# 358bd9d700584a7488aa19f5dcf4be45
#: ../../template_ref.rst:17
msgid "Arithmetic"
msgstr "Arithmetik"

# 8ed9d99d8d3f455b9641d405ef165d6d
#: ../../template_ref.rst:20
msgid "add(x, y)"
msgstr ""

# ebbf41872093401f81a5a05230b9fee9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAdd:1
msgid ""
"add(x, y) -- returns x + y. Throws an exception if either x or y are not "
"numbers."
msgstr "add(x, y) -- Rückgabewert ist x + y. Eine Exception wird ausgelöst, wenn x und/oder y keine Zahl ist."

# 678b924ab4d847a382ee26db741ad21b
#: ../../template_ref.rst:25
msgid "divide(x, y)"
msgstr ""

# 88f74a7037e54268bc5aecb1c2be98c9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinDivide:1
msgid ""
"divide(x, y) -- returns x / y. Throws an exception if either x or y are not "
"numbers."
msgstr "divide(x, y) -- Rückgabewert ist x / y. Eine Exception wird ausgelöst, wenn x und/oder y keine Zahl ist."

# 8a8d99e8263a4804b6b9894ffec20213
#: ../../template_ref.rst:30
msgid "multiply(x, y)"
msgstr ""

# ec43379c67604aab95d17c38279ae028
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinMultiply:1
msgid ""
"multiply(x, y) -- returns x * y. Throws an exception if either x or y are "
"not numbers."
msgstr "multiply(x, y) -- Rückgabewert ist x * y. Eine Exception wird ausgelöst, wenn x und/oder y keine Zahl ist."

# 7f7bc8d6cf94447ab0d00be071add591
#: ../../template_ref.rst:35
msgid "subtract(x, y)"
msgstr ""

# 1530bfb3a2284ce6820937a9bb9defbc
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubtract:1
msgid ""
"subtract(x, y) -- returns x - y. Throws an exception if either x or y are "
"not numbers."
msgstr "subtract(x, y) -- Rückgabwert ist x - y. Eine Exception wird ausgelöst, wenn x und/oder y keine Zahl ist."

# c357796249314495a9f4f65c45ef7025
#: ../../template_ref.rst:40
msgid "Boolean"
msgstr "Boolesch"

# ff56a90e08c5423ab1e58b84b8180a7a
#: ../../template_ref.rst:43
msgid "and(value, value, ...)"
msgstr ""

# 290fea00d6724d66bd3bee8327543547
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAnd:1
msgid ""
"and(value, value, ...) -- returns the string \"1\" if all values are not "
"empty, otherwise returns the empty string. This function works well with "
"test or first_non_empty. You can have as many values as you want."
msgstr "and(value, value, ...) -- gibt den String \"1\" aus, wenn alle Werte nicht empty ist, ansonsten wird retuder empty String ausgegeben. Diese Funktion arbeitet gut mit test oder first_non_empty Werten. Die Anzahl der Werte ist beliebig."

# 1d7bdff099eb438ea991367f3a58a500
#: ../../template_ref.rst:48
msgid "not(value)"
msgstr ""

# 654ec7079fd447038f2c0d8f2ed62e66
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinNot:1
msgid ""
"not(value) -- returns the string \"1\" if the value is empty, otherwise "
"returns the empty string. This function works well with test or "
"first_non_empty. You can have as many values as you want."
msgstr "not(value) -- gibt den String \"1\" aus,  wenn  der Wert empty ist, ansonsten wird ein leerer String ausgegeben. Diese Funktion arbeitet gut mit test oder first_non_empty zusammen. Die Anzahl der Werte ist beliebig."

# 9bd1ca01a560409e86d38cba9a9a7b0e
#: ../../template_ref.rst:53
msgid "or(value, value, ...)"
msgstr "or(value, value, ...)"

# 4bf83c4a9c27413b8decfbaaecf621f3
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinOr:1
msgid ""
"or(value, value, ...) -- returns the string \"1\" if any value is not empty,"
" otherwise returns the empty string. This function works well with test or "
"first_non_empty. You can have as many values as you want."
msgstr "or(value, value, ...) -- gibt den String \"1\" aus,  wenn jeder Wert nicht empty ist, otherwise returns the empty string. Diese Funktion arbeitet gut mit test oder first_non_empty zusammen. Die Anzahl der Werte ist beliebig."

# 309dfd994c284a109a935f7dcd7c085a
#: ../../template_ref.rst:58
msgid "Date functions"
msgstr "Datumsfunktionen"

# 842a45f8cfb6423bbd0df045278eb0c7
#: ../../template_ref.rst:61
msgid "days_between(date1, date2)"
msgstr ""

# 171ccb5e47654a5095009d5879c7b530
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinDaysBetween:1
msgid ""
"days_between(date1, date2) -- return the number of days between date1 and "
"date2. The number is positive if date1 is greater than date2, otherwise "
"negative. If either date1 or date2 are not dates, the function returns the "
"empty string."
msgstr "days_between(date1, date2) -- liefert die Anzahl der Tage zwischen date1 und date2. Die Zahl ist positiv, wenn date1 größer als date2 ist, andernfalls negativ. Falls einer der beiden Werte date1 und date2 kein Datum ist, wird ein leerer String zurückgeliefert."

# e14e203bde044ea1a2a728a39eb50501
#: ../../template_ref.rst:66
msgid "today()"
msgstr ""

# 1407eab1b3d147caa89981c27352363d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinToday:1
msgid ""
"today() -- return a date string for today. This value is designed for use in"
" format_date or days_between, but can be manipulated like any other string. "
"The date is in ISO format."
msgstr "today() -- gibt einen Datum-String für den aktuellen Tag aus. Dieser Wert ist für den Einsatz in format_date oder days_between gedacht, kann aber wie jeder andere String verändert werden. Das Datum wird im ISO Format ausgegeben."

# 4035aaf2800945e2aa3a7f4850a13911
#: ../../template_ref.rst:71
msgid "Formatting values"
msgstr "Formatierungswerte"

# 469ee8da215441a487d393c51bceab77
#: ../../template_ref.rst:74
msgid "finish_formatting(val, fmt, prefix, suffix)"
msgstr ""

# 56621f08228e48e8b2768947735969f5
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFinishFormatting:1
msgid ""
"finish_formatting(val, fmt, prefix, suffix) -- apply the format, prefix, and"
" suffix to a value in the same way as done in a template like "
"`{series_index:05.2f| - |- }`. For example, the following program produces "
"the same output as the above template: program: "
"finish_formatting(field(\"series_index\"), \"05.2f\", \" - \", \" - \")"
msgstr "finish_formatting(val, fmt, prefix, suffix) -- anwenden des Formats, Präfix, und Suffix zu einem Wert in der gleichen Art und Weise wie mit dem Template  `{series_index:05.2f| - |- }`. Das folgende Programm produziert die gleiche Ausgabe, wie das obere Template: Program: finish_formatting(field(\"series_index\"), \"05.2f\", \" - \", \" - \")"

# 9d58eead70534d44a5976838fd6cedfb
#: ../../template_ref.rst:79
msgid "format_date(val, format_string)"
msgstr ""

# f10597dd793c4c69870daa900be35ccb
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatDate:1
msgid ""
"format_date(val, format_string) -- format the value, which must be a date, "
"using the format_string, returning a string. The formatting codes are: d    "
": the day as number without a leading zero (1 to 31) dd   : the day as "
"number with a leading zero (01 to 31) ddd  : the abbreviated localized day "
"name (e.g. \"Mon\" to \"Sun\"). dddd : the long localized day name (e.g. "
"\"Monday\" to \"Sunday\"). M    : the month as number without a leading zero"
" (1 to 12). MM   : the month as number with a leading zero (01 to 12) MMM  :"
" the abbreviated localized month name (e.g. \"Jan\" to \"Dec\"). MMMM : the "
"long localized month name (e.g. \"January\" to \"December\"). yy   : the "
"year as two digit number (00 to 99). yyyy : the year as four digit number. h"
"    : the hours without a leading 0 (0 to 11 or 0 to 23, depending on am/pm)"
" hh   : the hours with a leading 0 (00 to 11 or 00 to 23, depending on "
"am/pm) m    : the minutes without a leading 0 (0 to 59) mm   : the minutes "
"with a leading 0 (00 to 59) s    : the seconds without a leading 0 (0 to 59)"
" ss   : the seconds with a leading 0 (00 to 59) ap   : use a 12-hour clock "
"instead of a 24-hour clock, with \"ap\" replaced by the localized string for"
" am or pm AP   : use a 12-hour clock instead of a 24-hour clock, with \"AP\""
" replaced by the localized string for AM or PM iso  : the date with time and"
" timezone. Must be the only format present"
msgstr "format_date(val, format_string) - angegebenen Wert, der Datum sein muss, entsprechend dem Formatstring formatieren; liefert einen String zurück. Die einzelnen Codes des Formatstrings sind: d: der Tag als Zahl ohne führende Null (1 bis 31). dd: der Tag als Zahl mit führender Null (01 bis 31). ddd: der abgekürzte, lokalisierte, Name des Wochentags (z.B. \"Mon\" bis \"Son\"). dddd: der lange, lokalisierte Name des Wochentags (z.B.: \"Montag\" bis \"Sonntag\"). M: der Monat als Zahl ohne führende Null (1 bis 12). MM: der Monat als Zahl mit führender Null (01 bis 12). MMM: der abgekürzte, lokalisierte Name des Monats (z.B. \"Jan\" bis \"Dez\"). MMMM: der lange, lokalisierte Name des Monats (z.B. \"Januar\" bis \"Dezember\"). yy: das Jahr als zweistellige Zahl (00 bis 99). yyyy: das Jahr als vierstellige Zahl. h: die Stunden ohne führende Null (0 bis 11, bzw.  0 bis 23). hh: die Stunden mit führender Null (00 bis 12, bzw. 00 bis 23). m: die Minuten ohne führende Null (0 bis 59). mm: die Minuten mit führender Null (00 bis 59). s: die Sekunden ohne führende Null (0 bis 59). ss: die Sekunden mit führender Null (00 bis 59). am oder pm: 12-Stunden Uhr benutzen. AM oder PM: 24-Stunden Uhr benutzen. iso: das Datum mit Zeit und Zeitzone (muss die einzige Formatangabe sein)"

# ee79a2d8ec3e495fb4c06ae075cd3956
#: ../../template_ref.rst:84
msgid "format_number(v, template)"
msgstr ""

# 0fe99d00fbaf4a55b9042b8de2e31fe8
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatNumber:1
msgid ""
"format_number(v, template) -- format the number v using a python formatting "
"template such as \"{0:5.2f}\" or \"{0:,d}\" or \"${0:5,.2f}\". The "
"field_name part of the template must be a 0 (zero) (the \"{0:\" in the above"
" examples). See the template language and python documentation for more "
"examples. Returns the empty string if formatting fails."
msgstr "format_number(v, template) -- Formatiert die Zahl v unter Verwendung eines Python Formatierungs-Template wie \"{0:5.2f}\" oder \"{0:,d}\" oder \"${0:5,.2f}\". Der field_name (Feld_Name) Teil des Templates muss eine 0 (Null) sein (die \"{0:\" im o.g. Bsp.). Lesen Sie das Handbuch zu der Template Sprache und Python für weitere Beispiele. Gibt den leeren String aus, wenn die Formatierung nicht funktioniert."

# d551c0f947694260b4dd94cd5599f11b
#: ../../template_ref.rst:89
msgid "human_readable(v)"
msgstr ""

# a57e7ccd7f0648e5ac8f0683e50ce0f4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinHumanReadable:1
msgid ""
"human_readable(v) -- return a string representing the number v in KB, MB, "
"GB, etc."
msgstr "human_readable(v) -- gibt einen String zurück der die Zahl v in KB, MB, GB, etc. ausdrückt."

# 5cd1b8d5d5994ed2bb711cbe2b4a3a23
#: ../../template_ref.rst:94
msgid "Get values from metadata"
msgstr ""

# 140931bcf09f432f8e63a5270624df27
#: ../../template_ref.rst:97
msgid "approximate_formats()"
msgstr ""

# d467ff46996c4d5684d602edf5997bec
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinApproximateFormats:1
msgid ""
"approximate_formats() -- return a comma-separated list of formats that at "
"one point were associated with the book. There is no guarantee that this "
"list is correct, although it probably is. This function can be called in "
"template program mode using the template \"{:'approximate_formats()'}\". "
"Note that format names are always uppercase, as in EPUB. This function works"
" only in the GUI. If you want to use these values in save-to-disk or send-"
"to-device templates then you must make a custom \"Column built from other "
"columns\", use the function in that column's template, and use that column's"
" value in your save/send templates"
msgstr "approximate_formats() -- gibt eine durch Kommas getrennte Liste von Formaten zurück, die mit dem Buch gespeichert wurden. Es gibt keine Garantie, dass diese Liste stimmt, obwohl es wahrscheinlich ist. Diese Funktion wird als Vorlage im Programm-Modus mithilfe der Vorlage \"{program:'approximate_formats()'}\" aufgerufen. Die Namen der Formate sind immer in Großschrift geschrieben, wie z. B. EPUB. Diese Funktion funktioniert nur auf der Benutzeroberfläche. Wenn Sie die Werte in den Vorlagen für \"Bücher auf Datenträger speichern\" oder \"Bücher auf Gerät übertragen\" verwenden wollen, müssen Sie mit dieser Funktion eine benutzerdefinierte Spalte des Typs \"Aus anderen Spalten zusammengesetzte Spalte\" erstellen und deren Werte im Template verwenden"

# c00aaf8459fd473d8aa85e10dd91707f
#: ../../template_ref.rst:102
msgid "author_links(val_separator, pair_separator)"
msgstr ""

# fa13bc4ae7894954b70bdd0f4738609a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAuthorLinks:1
msgid ""
"author_links(val_separator, pair_separator) -- returns a string containing a"
" list of authors and that author's link values in the form author1 "
"val_separator author1link pair_separator author2 val_separator author2link "
"etc. An author is separated from its link value by the val_separator string "
"with no added spaces. author:linkvalue pairs are separated by the "
"pair_separator string argument with no added spaces. It is up to you to "
"choose separator strings that do not occur in author names or links. An "
"author is included even if the author link is empty."
msgstr ""

# 4650dfad7955466cb3df2f63700120a2
#: ../../template_ref.rst:107
msgid "booksize()"
msgstr ""

# 44728e95953b410cbfb59d28376244d2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinBooksize:1
msgid ""
"booksize() -- return value of the size field. This function works only in "
"the GUI. If you want to use this value in save-to-disk or send-to-device "
"templates then you must make a custom \"Column built from other columns\", "
"use the function in that column's template, and use that column's value in "
"your save/send templates"
msgstr "booksize() -- Gibt den Wert des Feldes size zurück. Diese Funktion funktioniert nur auf der Benutzeroberfläche. Wenn Sie die Werte in den Vorlagen für \"Bücher auf Datenträger speichern\" oder \"Bücher auf Gerät übertragen\" verwenden wollen, müssen Sie eine benutzerdefinierte Spalte des Typs \"aus anderen Spalten zusammengesetzte Spalte\" erstellen, deren Werte im Template verwenden und den Wert der Spalte im Speichern/Senden Template angeben"

# d7f5fe27904f4d4e863c188241f6103e
#: ../../template_ref.rst:112
msgid "current_library_name()"
msgstr ""

# 6ac78cebe4ae47a8a321ead817979f3d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCurrentLibraryName:1
msgid ""
"current_library_name() -- return the last name on the path to the current "
"calibre library. This function can be called in template program mode using "
"the template \"{:'current_library_name()'}\"."
msgstr "current_library_name() -- gibt den letzten Namen das Pfades zur aktuellen-Calibre Bibliothek aus. Diese Funktion kann im Vorlagen-Programmmodus durch die Vorlage \"{:'current_library_name()'}\" geladen werden."

# 0c3c5dabee1e4d5c99459a7fc4219081
#: ../../template_ref.rst:117
msgid "current_library_path()"
msgstr ""

# 57b580028623498db633b10bd403df0a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCurrentLibraryPath:1
msgid ""
"current_library_path() -- return the path to the current calibre library. "
"This function can be called in template program mode using the template "
"\"{:'current_library_path()'}\"."
msgstr "current_library_path() -- gibt den Pfad der aktuellen calibe-Datenbank zurück. Diese Funktion dann im Vorlagen Programmiermodus verwendet werden: \"{:'current_library_path()'}\"."

# 16d763d980ba4cdfb313ff99b174279f
#: ../../template_ref.rst:122
msgid "field(name)"
msgstr ""

# 651281a2e2234660a03ffb19be2f3da5
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinField:1
msgid "field(name) -- returns the metadata field named by name"
msgstr "field(name) -- gibt das Feld Metadaten, das durch name bezeichnet ist, zurück"

# b6bca1e3d6b54408b934df327cd9a2da
#: ../../template_ref.rst:127
msgid "formats_modtimes(date_format)"
msgstr ""

# 87e210a01f7a4ef6a843750619c24806
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsModtimes:1
msgid ""
"formats_modtimes(date_format) -- return a comma-separated list of "
"colon_separated items representing modification times for the formats of a "
"book. The date_format parameter specifies how the date is to be formatted. "
"See the date_format function for details. You can use the select function to"
" get the mod time for a specific format. Note that format names are always "
"uppercase, as in EPUB."
msgstr "formats_modtimes(date_format) -- liefert eine kommaseparierte Liste von Doppelpunkt getrennten Inhalten, die die Änderungszeitpunkte für das Format eines Buches wiedergeben. Der Parameter date_format legt fest, nach welcher Art ein  Datum zu formatieren ist. Lesen Sie mehr in der date_format Funktionsaufruf-Beschreibung. Sie können die Auswahlfunktion benutzen, um den Änderungszeitpunkt für ein bestimmtes Format zu erhalten. Bitte beachten Sie, dass Format Bezeichnungen immer in Großbuchstaben zu erfolgen haben, z.B. wie in EPUB."

# 0292f0e5c0524fb78ce8ab65f52c4152
#: ../../template_ref.rst:132
msgid "formats_paths()"
msgstr ""

# 0aeddcdcf4b54b429f61b6e96ddeaf65
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsPaths:1
msgid ""
"formats_paths() -- return a comma-separated list of colon_separated items "
"representing full path to the formats of a book. You can use the select "
"function to get the path for a specific format. Note that format names are "
"always uppercase, as in EPUB."
msgstr "formats_paths() -- gibt eine durch Komma getrennte Liste von colon_separated Elementen aus, welche den vollen Pfad zu dem Format eines eBooks darstellen. Sie können die Wählen-Funktion nutzen, um den Pfad eines bestimmten Formates zu bekommen.\r\nBeachten Sie, dass die Format-Namen immer in Großbuchstaben angegeben werden, wie bei EPUB."

# cc576976b0504fbb95ebd931a31cb4dd
#: ../../template_ref.rst:137
msgid "formats_sizes()"
msgstr ""

# 4ff1c4478c6947ada46d3ac7f0d2f83e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsSizes:1
msgid ""
"formats_sizes() -- return a comma-separated list of colon_separated items "
"representing sizes in bytes of the formats of a book. You can use the select"
" function to get the size for a specific format. Note that format names are "
"always uppercase, as in EPUB."
msgstr "formats_sizes() -- gibt eine, durch ein Komma getrennte Liste von colon_separated Elementen aus, welche die Größe eines Buches in Bytes angibt. Sie können die Auswählen- Funktion nutzen, um die Größe eines bestimmten Formates zu erhalten.\r\nBeachten Sie, dass Formatnamen immer in Großbuchstaben (z.B. EPUB) angegeben werden."

# 21b12499b18d44e4a91e2fc9f7895c72
#: ../../template_ref.rst:142
msgid "has_cover()"
msgstr ""

# e5ae05f8452b438494855f3b02496eb8
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinHasCover:1
msgid ""
"has_cover() -- return Yes if the book has a cover, otherwise return the "
"empty string"
msgstr "has_cover() -- gibt Yes zurück, wenn das Buch einen Coverbild hat, andernfalls einen leeren String"

# 3d350cf65557416fb8a0e11c028ed383
#: ../../template_ref.rst:147
msgid "language_codes(lang_strings)"
msgstr ""

# b7ce23aec6ae4ef796021c511799c40f
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLanguageCodes:1
msgid ""
"language_codes(lang_strings) -- return the language codes for the strings "
"passed in lang_strings. The strings must be in the language of the current "
"locale. Lang_strings is a comma-separated list."
msgstr "language_codes(lang_strings) -- gibt den Sprachcode für die Strings übergeben in lang_strings aus. Die Strings müssen in der Sprache des aktuellen Gebietsschemas sein. Die Liste der Lang_strings wird durch Kommata getrennt."

# 15b3b5ec6b82429e99cadfcbd45cdf49
#: ../../template_ref.rst:152
msgid "language_strings(lang_codes, localize)"
msgstr ""

# bcdf497ea8bb4aa9bebb339c32034222
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLanguageStrings:1
msgid ""
"language_strings(lang_codes, localize) -- return the strings for the "
"language codes passed in lang_codes. If localize is zero, return the strings"
" in English. If localize is not zero, return the strings in the language of "
"the current locale. Lang_codes is a comma-separated list."
msgstr "language_strings(lang_codes, localize) -- gibt die Strings für die Sprachcodes übergeben in lang_codes an. Wenn Null lokalisiert wird, dann werden die Strings in Englisch ausgegeben. Wenn Null nicht Lokalisiert wird, dann werden die Strings in der  Sprache das aktuellen Gebietsschemas ausgegeben. Die Liste der Lang_codes wird durch Kommata getrennt."

# de533eaa8e404b928f35db3d9eaa4c6e
#: ../../template_ref.rst:157
msgid "ondevice()"
msgstr ""

# 5d3d5cabdb9244d0aa6f4bd63931880b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinOndevice:1
msgid ""
"ondevice() -- return Yes if ondevice is set, otherwise return the empty "
"string. This function works only in the GUI. If you want to use this value "
"in save-to-disk or send-to-device templates then you must make a custom "
"\"Column built from other columns\", use the function in that column's "
"template, and use that column's value in your save/send templates"
msgstr "ondevice() -- gibt ein Ja bzw. Yes aus, wenn ondevice gesetzt ist, ansonsten wird ein leerer String ausgegeben. Diese Funktion funktioniert nur auf der Benutzeroberfläche. Wenn Sie die Werte in den Vorlagen für \"Bücher auf Datenträger speichern\" oder \"Bücher auf Gerät übertragen\" verwenden wollen, müssen Sie eine benutzerdefinierte Spalte des Typs \"aus anderen Spalten zusammengesetzte Spalte\" erstellen, deren Werte im Template verwenden und den Wert der Spalte im Speichern/Senden Template angeben"

# 48d378cd7b3a4e2d83f4bf85c7a79d49
#: ../../template_ref.rst:162
msgid "raw_field(name)"
msgstr ""

# 222ee9704bf84cae9a13d7507440c795
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinRawField:1
msgid ""
"raw_field(name) -- returns the metadata field named by name without applying"
" any formatting."
msgstr "raw_field(name) -- gibt das Feld Metadaten, das durch name bezeichnet ist, ohne jegliche Formatierung zurück."

# 4c04e9644f174debb29fd58e376eb39c
#: ../../template_ref.rst:167
msgid "series_sort()"
msgstr ""

# f4a98fd76cb6447396732f7ac8775284
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSeriesSort:1
msgid "series_sort() -- return the series sort value"
msgstr "series_sort() -- gibt den Sortierschlüssel der Serie zurück"

# 31783e5a82fa4588b170cb7820cb025d
#: ../../template_ref.rst:172
msgid "virtual_libraries()"
msgstr ""

# ded852e8a9e94db5a689a5891454ef8e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinVirtualLibraries:1
msgid ""
"virtual_libraries() -- return a comma-separated list of virtual libraries "
"that contain this book. This function works only in the GUI. If you want to "
"use these values in save-to-disk or send-to-device templates then you must "
"make a custom \"Column built from other columns\", use the function in that "
"column's template, and use that column's value in your save/send templates"
msgstr "virtual_libraries() -- gibt eine durch Kommas getrennte Liste der virtuellen Bibliotheken zurück, welche dieses Buch enthalten. Diese Funktion funktioniert nur auf der Benutzeroberfläche. Wenn Sie die Werte in den Vorlagen für \"Bücher auf Datenträger speichern\" oder \"Bücher auf Gerät übertragen\" verwenden wollen, müssen Sie mit dieser Funktion eine benutzerdefinierte Spalte des Typs \"Aus anderen Spalten zusammengesetzte Spalte\" erstellen und deren Werte im Template verwenden"

# dd6b410798fb41f4b39710b040eb36a2
#: ../../template_ref.rst:177
msgid "If-then-else"
msgstr ""

# aa1c6023117d41568900de39a088e4d1
#: ../../template_ref.rst:180
msgid "contains(val, pattern, text if match, text if not match)"
msgstr ""

# 87ff56d215964dbd9ad3353687570b77
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinContains:1
msgid ""
"contains(val, pattern, text if match, text if not match) -- checks if field "
"contains matches for the regular expression `pattern`. Returns `text if "
"match` if matches are found, otherwise it returns `text if no match`"
msgstr "contains(val, pattern, text if match, text if not match) -- prüft, ob das Feld Treffer für allgemeine Ausdrücke `pattern`enthält. Gibt `text if match` aus, wenn keine Treffer gefunden werden, ansonsten `text if no match`"

# b10af075f70a423799302d2f96097ed8
#: ../../template_ref.rst:185
msgid "ifempty(val, text if empty)"
msgstr ""

# b4bb1edc7f094daf9e831678424aad33
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinIfempty:1
msgid ""
"ifempty(val, text if empty) -- return val if val is not empty, otherwise "
"return `text if empty`"
msgstr "ifempty(val, text if empty) -- gibt val aus wenn val nicht leer ist, ansonsten `text if empty`"

# d4107038e4cf48d7a6e6563a9cc2c8d9
#: ../../template_ref.rst:190
msgid "test(val, text if not empty, text if empty)"
msgstr ""

# 65289dea7ed445b5990cd106143c6001
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTest:1
msgid ""
"test(val, text if not empty, text if empty) -- return `text if not empty` if"
" the field is not empty, otherwise return `text if empty`"
msgstr "test(val, text if not empty, text if empty) -- gibt `text if not empty` aus, wenn das Feld nicht leer ist, ansonsten `text if empty`"

# 60c4792791a74094b2dfeae556aeea02
#: ../../template_ref.rst:195
msgid "Iterating over values"
msgstr ""

# 69f6ae9c5f9f4a08933f3bedc464a678
#: ../../template_ref.rst:198
msgid "first_non_empty(value, value, ...)"
msgstr ""

# f363a0e9141c48cebd6a84bb2a0a2eed
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFirstNonEmpty:1
msgid ""
"first_non_empty(value, value, ...) -- returns the first value that is not "
"empty. If all values are empty, then the empty value is returned. You can "
"have as many values as you want."
msgstr "first_non_empty(value, value, ...) -- gibt den ersten Wert aus, der nicht empty ist. Wenn alle Werte empty sind, dann kommt der empty Wert wieder. Die Anzahl der Werte ist beliebig."

# 3defe89bcb0c409ab751ebfa1ff8f2c1
#: ../../template_ref.rst:203
msgid "lookup(val, pattern, field, pattern, field, ..., else_field)"
msgstr ""

# 4dd8d93ab747436da541b9bb59b1b860
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLookup:1
msgid ""
"lookup(val, pattern, field, pattern, field, ..., else_field) -- like switch,"
" except the arguments are field (metadata) names, not text. The value of the"
" appropriate field will be fetched and used. Note that because composite "
"columns are fields, you can use this function in one composite field to use "
"the value of some other composite field. This is extremely useful when "
"constructing variable save paths"
msgstr "lookup(val, pattern, field, pattern, field, ..., else_field) -- wie switch, außer dass die Argumente  Feld (Metadaten) Namen sind, kein Text. Der Wert des entsprechenden Feldes wird ausgelesen und verwendet.  Beachten Sie das, da zusammengesetzte Spalten Felder sind. Sie können die Funktion eines zusammengesetzten Feldes verwenden, um den Wert eines Anderen zusammengesetzten Feldes zu nutzen. Das ist sehr nützlich bei der Konstruktion von variablen Speicherpfaden"

# 0c9cedf0aaf940ab837a518050063ef6
#: ../../template_ref.rst:208
msgid "switch(val, pattern, value, pattern, value, ..., else_value)"
msgstr ""

# 88e526255f204a649510df8f36c9617b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSwitch:1
msgid ""
"switch(val, pattern, value, pattern, value, ..., else_value) -- for each "
"`pattern, value` pair, checks if the field matches the regular expression "
"`pattern` and if so, returns that `value`. If no pattern matches, then "
"else_value is returned. You can have as many `pattern, value` pairs as you "
"want"
msgstr "switch(val, pattern, value, pattern, value, ..., else_value) -- für jedes `pattern, value` Paar, prüft, ob das Feld den regulären Ausdruck `pattern` enthält und wenn, dann wird `value` ausgegeben. Wenn keine pattern zutreffen, dann wird else_value ausgegeben. Es können beliebig viele `pattern, value` Paare angegeben werden"

# 3f8da75a656d4053812ea55e5e725ecb
#: ../../template_ref.rst:213
msgid "List lookup"
msgstr ""

# 26b53af4015d4fd8a4a3232b1cee90c6
#: ../../template_ref.rst:216
msgid "identifier_in_list(val, id, found_val, not_found_val)"
msgstr ""

# d6430da43c2c48c5889fe62bc1ad8670
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinIdentifierInList:1
msgid ""
"identifier_in_list(val, id, found_val, not_found_val) -- treat val as a list"
" of identifiers separated by commas, comparing the string against each value"
" in the list. An identifier has the format \"identifier:value\". The id "
"parameter should be either \"id\" or \"id:regexp\". The first case matches "
"if there is any identifier with that id. The second case matches if the "
"regexp matches the identifier's value. If there is a match, return "
"found_val, otherwise return not_found_val."
msgstr "identifier_in_list(val, id, found_val, not_found_val) -- behandelt val wie eine durch Kommata getrennte Liste von Kennungen (IDs) und vergleicht die Strings mit jedem Wert in der Liste. Eine Kennung hat das Format \"identifier:value\", Die ID Parameter sollten entweder \"id\" oder \"id:regexp\" sein. Der erste Fall stimmt überein, wenn jede Kennung mit der ID übereinstimmt. Es entspricht dem zweiten Fall, wenn das regexp mit dem Kennungs-Wert übereinstimmt. Wenn es eine Übereinstimmung gibt, wird found_val ausgegeben, ansonsten not_found_val."

# eddfdce3fbdf425d90f2a9c02305c9cf
#: ../../template_ref.rst:221
msgid "in_list(val, separator, pattern, found_val, not_found_val)"
msgstr ""

# 1e226ebed6004d0dbe205533d5ffc10d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinInList:1
msgid ""
"in_list(val, separator, pattern, found_val, not_found_val) -- treat val as a"
" list of items separated by separator, comparing the pattern against each "
"value in the list. If the pattern matches a value, return found_val, "
"otherwise return not_found_val."
msgstr "in_list(val, separator, pattern, found_val, not_found_val) -- val wird als Liste von Werten, welche durch ein Trennzeichen getrennt werden behandelt. Das Pattern wird mit jedem dieser Werte verglichen. Wenn eine Übereinstimmung auftritt, wird found_val zurückgegeben, sonst not_found_val."

# fd7d018424124f299e66b9ccfa11cc1b
#: ../../template_ref.rst:226
msgid "list_item(val, index, separator)"
msgstr ""

# e4914bdea49e4f079f7e74cd1d601230
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListitem:1
msgid ""
"list_item(val, index, separator) -- interpret the value as a list of items "
"separated by `separator`, returning the `index`th item. The first item is "
"number zero. The last item can be returned using `list_item(-1,separator)`. "
"If the item is not in the list, then the empty value is returned. The "
"separator has the same meaning as in the count function."
msgstr "list_item(val, index, separator) -- Interpretiert den Wert als eine Liste von Elementen, getrennt durch `separator` (Trennzeichen, wobei das `index`te Element ausgegeben wird. Das erste Element ist die Zahl Null. Das Letzte Element kann durch `list_item(-1,separator)` wiedergegeben werden. Wenn das Element nicht in der Liste ist, dann wied ein leerer Wert ausgegeben. Das Trennzeichen hat die gleiche Bedeutung, wie die Zähl-Funktion."

# c39286aa6cf44ebead9346f84aaf924c
#: ../../template_ref.rst:231
msgid "select(val, key)"
msgstr ""

# e85ce73114f842869ee3537029ea77bb
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSelect:1
msgid ""
"select(val, key) -- interpret the value as a comma-separated list of items, "
"with the items being \"id:value\". Find the pair with the id equal to key, "
"and return the corresponding value."
msgstr "select(val, key) -- Interpretiert den Wert (value) als eine durch Komma getrennte Liste von Elementen, wobei die Elemente \"id:value\" sind. Findet das Paar, bei dem die id gleich key ist, und gibt den entsprechenden Wert zurück."

# ea0f040238be41739e931f02b2b824ea
#: ../../template_ref.rst:236
msgid "str_in_list(val, separator, string, found_val, not_found_val)"
msgstr ""

# 0674745a8e954c51b2ede764917826cd
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrInList:1
msgid ""
"str_in_list(val, separator, string, found_val, not_found_val) -- treat val "
"as a list of items separated by separator, comparing the string against each"
" value in the list. If the string matches a value, return found_val, "
"otherwise return not_found_val. If the string contains separators, then it "
"is also treated as a list and each value is checked."
msgstr "str_in_list(val, separator, string, found_val, not_found_val) -- behandelt \"val\" als eine Liste von Elementen, durch ein Trennzeichen getrennt. Der String wird mit jedem Wert in der Liste verglichen. Wenn der String mit dem Wert übereinstimmt, wird \"found_val\" ausgegeben, andernfalls \"not_found_val\". Wenn der String Trennzeichnen enthält, dann wird er so behandelt wie eine Liste und jeder Wert wird überprüft."

# 99f8ed20d3f34b208899b18fb91623c0
#: ../../template_ref.rst:241
msgid "List manipulation"
msgstr ""

# 8dcf974621304691924d98ba81eeb449
#: ../../template_ref.rst:244
msgid "count(val, separator)"
msgstr ""

# 3726c6fa3ac74ea8a641523833511474
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCount:1
msgid ""
"count(val, separator) -- interprets the value as a list of items separated "
"by `separator`, returning the number of items in the list. Most lists use a "
"comma as the separator, but authors uses an ampersand. Examples: "
"{tags:count(,)}, {authors:count(&)}"
msgstr "count(val, separator) -- 'val' wird als Liste von Werten interpretiert, welche alle durch 'separator' voneinander getrennt sind. Die Anzahl der Items wird zurückgegeben. In den meisten Listen wird ein Komma (,) verwendet. Allerdings wird zum Beispiel in der Liste der Autoren ein kaufmännisches Und (&) genutzt. Beispiel: {tags:count(,)}, {authors:count(&)}"

# 3360403b99a74b26a0077c94c322ad39
#: ../../template_ref.rst:249
msgid "list_difference(list1, list2, separator)"
msgstr ""

# 4e90fd0d8900415bb2aa89b0eaa5f187
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListDifference:1
msgid ""
"list_difference(list1, list2, separator) -- return a list made by removing "
"from list1 any item found in list2, using a case-insensitive compare. The "
"items in list1 and list2 are separated by separator, as are the items in the"
" returned list."
msgstr "list_difference(list1, list2, separator) -- gibt eine Liste aus, bei der jedes Element aus list1 entfernt wird, dass in list2 gefunden wird, wobei die Groß- und Kleinschreibung verglichen wird. Die Elemente, in list1 und list2 werden durch ein Trennzeichen getrennt, ebenso wie die Elemente der ausgegebenen Liste."

# d82dc5fa31d24cd7b7969da751950aad
#: ../../template_ref.rst:254
msgid "list_equals(list1, sep1, list2, sep2, yes_val, no_val)"
msgstr ""

# db9f51553b12475691160a61423beb4b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListEquals:1
msgid ""
"list_equals(list1, sep1, list2, sep2, yes_val, no_val) -- return yes_val if "
"list1 and list2 contain the same items, otherwise return no_val. The items "
"are determined by splitting each list using the appropriate separator "
"character (sep1 or sep2). The order of items in the lists is not relevant. "
"The compare is case insensitive."
msgstr "list_equals(list1, sep1, list2, sep2, yes_val, no_val) -- liefert 'yes_val' zurück, falls 'list1' und 'list2' die gleichen Elemente enthalten, andernfalls 'no_val'. Die Elemente werden durch Zerlegung jeder Liste durch das entsprechende Trennzeichen (sep1 oder sep2) bestimmt. Die Reihenfolge der Elemente spielt keine Rolle. Der Vergleich ignoriert die Groß/Kleinschreibung."

# 27a36faf4fea4036b41417441ca1d820
#: ../../template_ref.rst:259
msgid "list_intersection(list1, list2, separator)"
msgstr ""

# da1fe981f2cb4b8e960dfa55f656f30e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListIntersection:1
msgid ""
"list_intersection(list1, list2, separator) -- return a list made by removing"
" from list1 any item not found in list2, using a case-insensitive compare. "
"The items in list1 and list2 are separated by separator, as are the items in"
" the returned list."
msgstr "list_intersection(list1, list2, separator) -- gibt eine Liste aus, bei der jedes Element aus list1 entfernt wird, dass <nicht> in list2 gefunden wird, wobei die Groß- und Kleinschreibung verglichen wird. Die Elemente, in list1 und list2 werden durch ein Trennzeichen getrennt, ebenso wie die Elemente der ausgegebenen Liste."

# c63b4793cc49412b83dc1ef8fd662cbe
#: ../../template_ref.rst:264
msgid "list_re(src_list, separator, include_re, opt_replace)"
msgstr ""

# 17a253b13ceb4a24a8e470fc7f976785
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListRe:1
msgid ""
"list_re(src_list, separator, include_re, opt_replace) -- Construct a list by"
" first separating src_list into items using the separator character. For "
"each item in the list, check if it matches include_re. If it does, then add "
"it to the list to be returned. If opt_replace is not the empty string, then "
"apply the replacement before adding the item to the returned list."
msgstr "list_re(src_list, separator, include_re, opt_replace) -- Erstellt aus src_list eine Liste, indem zuerst die einzelnen Elemente durch das Trennzeichen separator getrennt werden. Für jedes Element in der Liste wird überprüft, ob es mit include_re übereinstimmt. Wenn das der Fall ist, wird es zur Liste hinzugefügt, die zurückgegeben werden soll. Wenn opt_replace keine leere Zeichenkette ist, wird das Element vor dem Hinzufügen in die Ausgabeliste ersetzt"

# 7974ab88e1c94a07b5cc8e7f783e97b4
#: ../../template_ref.rst:269
msgid ""
"list_re_group(src_list, separator, include_re, search_re, group_1_template, "
"...)"
msgstr ""

# 4977ab4349db4fb8bac770b47608539f
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListReGroup:1
msgid ""
"list_re_group(src_list, separator, include_re, search_re, group_1_template, "
"...) -- Like list_re except replacements are not optional. It uses "
"re_group(list_item, search_re, group_1_template, ...) when doing the "
"replacements on the resulting list."
msgstr ""

# 09103b6d7ca749dabcf5c14bb025cab8
#: ../../template_ref.rst:274
msgid "list_sort(list, direction, separator)"
msgstr ""

# 867cd18cb4c84354946327d053d30387
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListSort:1
msgid ""
"list_sort(list, direction, separator) -- return list sorted using a case-"
"insensitive sort. If direction is zero, the list is sorted ascending, "
"otherwise descending. The list items are separated by separator, as are the "
"items in the returned list."
msgstr "list_sort(list, direction, separator) -- liefert eine sortierte Liste ohne Berücksichtigung von Groß/Kleinschreibung zurück. Falls 'direction' Null ist, wird die Liste aufsteigend sortiert, andernfalls absteigend. Die Elemente der Liste sind durch 'separator' getrennt, genauso, wie die Ergebnisliste."

# 9d1dc556760c4ab4939a38c00d003c63
#: ../../template_ref.rst:279
msgid "list_union(list1, list2, separator)"
msgstr ""

# e99c3003b773491b9985cb9494a9e0e6
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListUnion:1
msgid ""
"list_union(list1, list2, separator) -- return a list made by merging the "
"items in list1 and list2, removing duplicate items using a case-insensitive "
"compare. If items differ in case, the one in list1 is used. The items in "
"list1 and list2 are separated by separator, as are the items in the returned"
" list."
msgstr "list_union(list1, list2, separator) -- gibt eine Liste mit den zusammengeführten Elementen aus list1 und list2 zurück, wobei Duplikate durch schreibungsunabhängigen Vergleich entfernt werden. Wenn Elemente sich in der Schreibweise unterscheiden, dann wird das aus list1 verwendet. Die Elemente in list1 und list2 werden durch den separator getrennt."

# c169a171f8724e238d642ae7d3ea442c
#: ../../template_ref.rst:284
msgid "subitems(val, start_index, end_index)"
msgstr ""

# b6de6e9088734f028dc34f6d5384487c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubitems:1
msgid ""
"subitems(val, start_index, end_index) -- This function is used to break "
"apart lists of items such as genres. It interprets the value as a comma-"
"separated list of items, where each item is a period-separated list. Returns"
" a new list made by first finding all the period-separated items, then for "
"each such item extracting the `start_index` to the `end_index` components, "
"then combining the results back together. The first component in a period-"
"separated list has an index of zero. If an index is negative, then it counts"
" from the end of the list. As a special case, an end_index of zero is "
"assumed to be the length of the list. Example using basic template mode and "
"assuming a #genre value of \"A.B.C\": {#genre:subitems(0,1)} returns \"A\". "
"{#genre:subitems(0,2)} returns \"A.B\". {#genre:subitems(1,0)} returns "
"\"B.C\". Assuming a #genre value of \"A.B.C, D.E.F\", {#genre:subitems(0,1)}"
" returns \"A, D\". {#genre:subitems(0,2)} returns \"A.B, D.E\""
msgstr "subitems(val, start_index, end_index) -- Diese Funktion wird verwendet, um Listen aus Elementen zu trennen, wie z.B. Genres. Es interpretiert den Wert als \"Komma-getrennte\" Liste von Elementen, wobei jedes Element eine periodisch-getrennte Liste ist.\nGibt eine neue Liste aus, indem zuerst alle gefundenen periodisch-getrennte Elemente, dann für jedes dieser Element der `start_index` zur `end_index` Komponente extrahiert wird. Die erste Komponente ist eine periodisch-getrennte Liste mit einem Index von Null. Wenn der Index negativ ist, dann wird vom Ende der Liste gezählt. Im Sonderfall, wenn ein end_index Null ist, wird er als Länge der Liste angenommen. \nBeispiel: bei Verwendung des Basis-Template Modus und unter der Annahme von #genre value gleich  \"A.B.C\"gibt {#genre:subitems(0,1)} den Wert \"A\" aus, {#genre:subitems(0,2)} gibt \"A.B\" aus,  {#genre:subitems(1,0)} gibt \"B.C\".\n Bei #genre value von \"A.B.C, D.E.F\",  {#genre:subitems(0,1)} gibt \"A, D\" aus, {#genre:subitems(0,2)} gibt \"A.B, D.E\" aus"

# 6ad8cc69dcd942339d4e7de91ba44856
#: ../../template_ref.rst:289
msgid "sublist(val, start_index, end_index, separator)"
msgstr ""

# 70185a71ff7844768d3a7a39a52202d0
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSublist:1
msgid ""
"sublist(val, start_index, end_index, separator) -- interpret the value as a "
"list of items separated by `separator`, returning a new list made from the "
"`start_index` to the `end_index` item. The first item is number zero. If an "
"index is negative, then it counts from the end of the list. As a special "
"case, an end_index of zero is assumed to be the length of the list. Examples"
" using basic template mode and assuming that the tags column (which is "
"comma-separated) contains \"A, B, C\": {tags:sublist(0,1,\\,)} returns "
"\"A\". {tags:sublist(-1,0,\\,)} returns \"C\". {tags:sublist(0,-1,\\,)} "
"returns \"A, B\"."
msgstr "sublist(val, start_index, end_index, separator) -- interpretiert den Wert als eine Liste von Elementen, getrennt durch ein `separator` (Trennzeichen). Gibt eine neue Liste, erstellt aus dem `start_index` zum `end_index` Element aus. Das erste Element hat die Zahl Null. Wenn eine Index negativ ist, dann zählt er vom Ende der Liste. Im Sonderfall, wenn end_index  Null ist, wird es als Länge der Liste angenommen. Beispielsweise verwenden wir ein Basis-Template Modus und nehmen an, dass die Schlagwörter-Spalte (die durch Kommata getrennt ist)  \"A, B, C\": {tags:sublist(0,1,\\,)} enthält, dann gibt \"A\". {tags:sublist(-1,0,\\,)} gibt \"C\". {tags:sublist(0,-1,\\,)} gibt \"A, B\" aus."

# d314ed639bd1457a8df3016c156a6644
#: ../../template_ref.rst:294
msgid "Other"
msgstr "Andere"

# 1f5d0cc6a9814eb2b365c62a7c4393b5
#: ../../template_ref.rst:297
msgid "assign(id, val)"
msgstr ""

# 9006740ddd354e8f97bdf10b0c806696
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAssign:1
msgid ""
"assign(id, val) -- assigns val to id, then returns val. id must be an "
"identifier, not an expression"
msgstr "assign(id, val) -- Zuweisung von val zu id, gibt val zurück. id muss ein Bezeichner sein, kein Ausdruck"

# faa9228f17d248b89455ef674462353d
#: ../../template_ref.rst:302
msgid "print(a, b, ...)"
msgstr ""

# 851a643681ab460d908b7823131b2832
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinPrint:1
msgid ""
"print(a, b, ...) -- prints the arguments to standard output. Unless you "
"start calibre from the command line (calibre-debug -g), the output will go "
"to a black hole."
msgstr "print(a, b, ...) -- gibt die Argumente auf der Standard-Ausgabe aus. Wenn Sie Calibre nicht über die Befehlszeile gestartet haben (calibre-debug -g), landet die Ausgabe in einem schwarzen Loch."

# b47b723945224f9bafdf168624555696
#: ../../template_ref.rst:307
msgid "Recursion"
msgstr "Rekursion"

# e14abe3c77e042a8bf9e3e7ee36f6354
#: ../../template_ref.rst:310
msgid "eval(template)"
msgstr ""

# 35465b8165134f3c8fe33d10efadbec8
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinEval:1
msgid ""
"eval(template) -- evaluates the template, passing the local variables (those"
" 'assign'ed to) instead of the book metadata.  This permits using the "
"template processor to construct complex results from local variables. "
"Because the { and } characters are special, you must use [[ for the { "
"character and ]] for the } character; they are converted automatically. Note"
" also that prefixes and suffixes (the `|prefix|suffix` syntax) cannot be "
"used in the argument to this function when using template program mode."
msgstr "eval(template) - Überprüft die Vorlage, die lokalen Variablen (jene die 'eingebunden wurden) anstelle der Buchmetadaten. Dies hat zur Folge, dass der Vorlagenprozessor komplexe Ergebnisse von lokalen Variablen erzeugt. Weil die Zeichen { und } spezielle Funktion haben, musst du für { die Zeichen [[ und für } die Zeichen ]] verwenden; sie werden automatisch umgewandelt. Beachten Sie, dass Vor- und Nachzeiten (die Vorzeichen '|prefix|suffix' Syntax) nicht für diese Funktionen verwendet werden kann, dass der Vorlagenprogrammiermodus verwendet wird."

# dee842e761d647038b4797b965b9231d
#: ../../template_ref.rst:315
msgid "template(x)"
msgstr ""

# 5b8eaa67d571487795d9a6575bcf9557
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTemplate:1
msgid ""
"template(x) -- evaluates x as a template. The evaluation is done in its own "
"context, meaning that variables are not shared between the caller and the "
"template evaluation. Because the { and } characters are special, you must "
"use [[ for the { character and ]] for the } character; they are converted "
"automatically. For example, template('[[title_sort]]') will evaluate the "
"template {title_sort} and return its value. Note also that prefixes and "
"suffixes (the `|prefix|suffix` syntax) cannot be used in the argument to "
"this function when using template program mode."
msgstr "template(x) -- wertet \"x\" als eine Vorlage. Die Beurteilung geschieht in eigener Umgebung, das heißt, dass Variablen nicht zwischen dem Aufrufer und der Vorlagenbewertung geteilt werden. Da das \"{\" und das \"}\" Zeichen besonders sind, müssen sie \"[[\" für \"{\" und \"]]\" für \"}\" verwenden; Diese werden automatisch umgewandelt. Zum Beispiel: template('[[title_sort]]') bewertet die Vorlage \"{title_sort}\" und gibt deren Wert zurück. Präfixe und Suffixe in der Notation `|prefix|suffix` können nicht als Argument für diese funktion benutzt werden, wenn der Vorlagen-Programmmodus benutzt wird."

# 98a83cf03bbf42f19f95f0a0b353a3fd
#: ../../template_ref.rst:320
msgid "Relational"
msgstr ""

# 8b279332aebf4ac5a53ba2b7cf1481b9
#: ../../template_ref.rst:323
msgid "cmp(x, y, lt, eq, gt)"
msgstr ""

# ed99e711c2dc41d8b1796784f2ebc7a7
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCmp:1
msgid ""
"cmp(x, y, lt, eq, gt) -- compares x and y after converting both to numbers. "
"Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr "cmp(x, y, lt, eq, gt) -- Vergleich von x und y nachdem diese zu Zahlenwerten konvertiert wurden. Der Rückgabewert ist lt wenn x < y, eq wenn x == y und andernfalls gt."

# 893a111e850e4fe1ba5f882e0e2985f5
#: ../../template_ref.rst:328
msgid "first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result)"
msgstr ""

# 9b33556f41ae4ccbb695c2707e6902c3
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFirstMatchingCmp:1
msgid ""
"first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result) -- "
"compares \"val < cmpN\" in sequence, returning resultN for the first "
"comparison that succeeds. Returns else_result if no comparison succeeds. "
"Example: "
"first_matching_cmp(10,5,\"small\",10,\"middle\",15,\"large\",\"giant\") "
"returns \"large\". The same example with a first value of 16 returns "
"\"giant\"."
msgstr "first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result) -- vergleicht nacheinander \"val < cmpN\" und gibt als Ergebnis \"resultN\" für den ersten erfolgreichen Vergleich zurück. Bei einem nicht erfolgreichen Vergleich wird \"else_result\" zurückgegeben. Beispiel: first_matching_cmp(10,5,\"small\",10,\"middle\",15,\"large\",\"giant\") gibt \"large\" zurück. Das gleiche Beispiel mit dem ersten Wert von 16 gibt \"giant\" zurück. Erklärung: Weil der letzte Wert else_result entspricht und 16 nicht in der Liste enthalten ist."

# 2b57ad2f7ae2453fae46e66be8e177af
#: ../../template_ref.rst:333
msgid "strcmp(x, y, lt, eq, gt)"
msgstr ""

# 4e0a4dc0e78042828d1ed62e079a53e9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcmp:1
msgid ""
"strcmp(x, y, lt, eq, gt) -- does a case-insensitive comparison of x and y as"
" strings. Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr "strcmp(x, y, lt, eq, gt) -- führt einen Case-insensitiven Vergleich der Zeichenketten x und y durch. Der Rückgabewert ist lt wenn x < y, eq wenn x == y und andernfalls gt."

# be09ffe825384911a6022e29ca3d6615
#: ../../template_ref.rst:338
msgid "String case changes"
msgstr ""

# 37fd0131d5074698bddcbf3382d284a9
#: ../../template_ref.rst:341
msgid "capitalize(val)"
msgstr ""

# baf304bf16a64d87a6d07f6b26262fd3
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCapitalize:1
msgid "capitalize(val) -- return value of the field capitalized"
msgstr "capitalize(val) -- gibt den Wert des Feldes val mit großen Anfangsbuchstaben zurück"

# 1b04a2a3c1de416f8b86e69019e2e62f
#: ../../template_ref.rst:346
msgid "lowercase(val)"
msgstr ""

# c568e5e55bc640b19806c1d28ca2f584
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLowercase:1
msgid "lowercase(val) -- return value of the field in lower case"
msgstr "lowercase(val) -- gibt den Wert des Feldes val in Kleinbuchstaben zurück"

# 18d5d354d4a341f0b9edf12d010a425e
#: ../../template_ref.rst:351
msgid "titlecase(val)"
msgstr ""

# 34f2f028ce73408496a54d27aacf63c7
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTitlecase:1
msgid "titlecase(val) -- return value of the field in title case"
msgstr "titlecase(val) -- gibt den Wert des Feldes val im Überschriftenstil zurück"

# 9d0bccca9a504b54b1f569c0fc83d352
#: ../../template_ref.rst:356
msgid "uppercase(val)"
msgstr ""

# 0e8b8b6fda074654adfe88d9a5657960
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinUppercase:1
msgid "uppercase(val) -- return value of the field in upper case"
msgstr "uppercase(val) -- gibt den Wert des Feldes val in Großbuchstaben zurück"

# 69e70c57951840eda7232db202495921
#: ../../template_ref.rst:361
msgid "String manipulation"
msgstr ""

# 15e6181db51d4354a1c173cb4aad21e3
#: ../../template_ref.rst:364
msgid "re(val, pattern, replacement)"
msgstr ""

# 0d408751985d481593580629f313c080
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinRe:1
msgid ""
"re(val, pattern, replacement) -- return the field after applying the regular"
" expression. All instances of `pattern` are replaced with `replacement`. As "
"in all of calibre, these are python-compatible regular expressions"
msgstr "re(val, pattern, replacement) -- Ersetzt alle Teile von val, auf die das Pattern 'pattern' zutrifft mit 'replacement' und gibt das Ergebnis zurück.  Der reguläre Ausdruck des Patterns muss, wie alles bei Calibre, Python Komptaibel sein"

# 20435d38740d49879e185fac8c2ecab7
#: ../../template_ref.rst:369
msgid "re_group(val, pattern, template_for_group_1, for_group_2, ...)"
msgstr ""

# 9a473052f37941048204d9981f356b33
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinReGroup:1
msgid ""
"re_group(val, pattern, template_for_group_1, for_group_2, ...) -- return a "
"string made by applying the reqular expression pattern to the val and "
"replacing each matched instance with the string computed by replacing each "
"matched group by the value returned by the corresponding template. The "
"original matched value for the group is available as $. In template program "
"mode, like for the template and the eval functions, you use [[ for { and ]] "
"for }. The following example in template program mode looks for series with "
"more than one word and uppercases the first word: {series:'re_group($, "
"\"(\\S* )(.*)\", \"[[$:uppercase()]]\", \"[[$]]\")'}"
msgstr ""

# 7e8028f304874c0b83e4e62dc45bd861
#: ../../template_ref.rst:374
msgid "shorten(val, left chars, middle text, right chars)"
msgstr ""

# d011d3349d7549cab4f85f8cc68ca4e6
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinShorten:1
msgid ""
"shorten(val, left chars, middle text, right chars) -- Return a shortened "
"version of the field, consisting of `left chars` characters from the "
"beginning of the field, followed by `middle text`, followed by `right chars`"
" characters from the end of the string. `Left chars` and `right chars` must "
"be integers. For example, assume the title of the book is `Ancient English "
"Laws in the Times of Ivanhoe`, and you want it to fit in a space of at most "
"15 characters. If you use {title:shorten(9,-,5)}, the result will be "
"`Ancient E-nhoe`. If the field's length is less than left chars + right "
"chars + the length of `middle text`, then the field will be used intact. For"
" example, the title `The Dome` would not be changed."
msgstr "shorten(val, left chars, middle text, right chars) -- Gibt eine gekürzte Version des Feldes aus, bestehend aus den Zeichen: `left chars` (linke Zeichen) vom Anfang des Feldes, gefolgt vom `middle text` (Mitteltext), gefolgt von `right chars` (rechte Zeichen) vom Ende des Feldes. `Left chars` und `right chars` müssen ganze Zahlen sein. Nehmen wir beispielsweise an, der Titel eines Buches ist `Ancient English Laws in the Times of Ivanhoe` und Sie möchten, dass es in einen Raum von maximal 15 Zeichen passt. Wenn Sie {title:shorten(9,-,5)} verwenden, wird das Ergebnis `Ancient E-nhoe` sein. Wenn die Feldlänge kürzer als die linken Zeichen + rechte Zeichen + Länge des `middle text` ist, dann wird das Feld unverändert verwendet."

# 5a7aaed665b04e868ca4538c27fcfa4c
#: ../../template_ref.rst:379
msgid "strcat(a, b, ...)"
msgstr ""

# 9a61685272684f16a01a1c02094dd60a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcat:1
msgid ""
"strcat(a, b, ...) -- can take any number of arguments. Returns a string "
"formed by concatenating all the arguments"
msgstr "strcat(a, b, ...) -- kann eine beliebige Anzahl von Argumenten verarbeiten. Der Rückgabewert ist eine Zeichenkette, die eine Verkettung aller Argumente darstellt"

# 398edfb7c360474e8feabd2373967b2e
#: ../../template_ref.rst:384
msgid "strcat_max(max, string1, prefix2, string2, ...)"
msgstr ""

# 6034f00df8d948a0a35abb28a273c4f9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcatMax:1
msgid ""
"strcat_max(max, string1, prefix2, string2, ...) -- Returns a string formed "
"by concatenating the arguments. The returned value is initialized to "
"string1. `Prefix, string` pairs are added to the end of the value as long as"
" the resulting string length is less than `max`. String1 is returned even if"
" string1 is longer than max. You can pass as many `prefix, string` pairs as "
"you wish."
msgstr "strcat_max(max, string1, prefix2, string2, ...) -- Liefert einen String zurück, der durch Aneinanderhängen der Argumente gebildet wird. Der Rückgabewert wird mit string1 initialisiert. `Prefix, string`-Paare werden an das Ende des Strings angehängt,  solange das Ergebnis kürzer als 'max' ist. String1 wird auch dann zurückggeben, wenn er länger als 'max' ist. Sie können soviele 'prefix, string'-Paare angeben wie sie wollen."

# a5ba097599bb4a17aae4be8d4b3b2e6f
#: ../../template_ref.rst:389
msgid "strlen(a)"
msgstr ""

# f2729de7847149119f0eb04ded5a6768
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrlen:1
msgid "strlen(a) -- Returns the length of the string passed as the argument"
msgstr "strlen(a) -- Rückgabewert ist die Länge der Zeichenkette die als Argument übergeben wurde"

# fb875ef6d9604e279c86330734b4878a
#: ../../template_ref.rst:394
msgid "substr(str, start, end)"
msgstr ""

# 904f8dd7d91748039ead736de4001afa
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubstr:1
msgid ""
"substr(str, start, end) -- returns the start'th through the end'th "
"characters of str. The first character in str is the zero'th character. If "
"end is negative, then it indicates that many characters counting from the "
"right. If end is zero, then it indicates the last character. For example, "
"substr('12345', 1, 0) returns '2345', and substr('12345', 1, -1) returns "
"'234'."
msgstr "substr(str, start, ende) -- gibt das start'te bis ende'te Zeichen von \"str\" zurück. Das erste Zeichen in \"str\" ist das 0te Zeichen, also s. Es hat den Index von 0. Wenn \"ende\" ein negativer Wert ist, heißt das, dass die Rückgabe beim ende-letzten Zeichen aufhört. Wenn ende 0 ist, heißt das, dass die Rückgabe alle Zeichen von \"start\" bis zum Ende von \"str\" umfasst. Zum Beispiel: \"substr('12345', 1, 0)\" gibt '2345', zurück und \"substr('12345', 1, -1)\" gibt '234' zurück."

# 60338eec6aa4430089003dc766434ea9
#: ../../template_ref.rst:399
msgid "swap_around_comma(val)"
msgstr ""

# 3b711c0ddf2e4746850b6874cbf33e5c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSwapAroundComma:1
msgid ""
"swap_around_comma(val) -- given a value of the form \"B, A\", return \"A "
"B\". This is most useful for converting names in LN, FN format to FN LN. If "
"there is no comma, the function returns val unchanged"
msgstr "swap_around_comma(val) -- ist ein Wert in der Form \"B, A\" gegeben, gib \"A B\" aus. Das ist sehr nützlich, um Namen im Format LN, FN in FN LN zu konvertieren. Wenn dort kein Komma steht, bleibt die Funktion val unverändert"

# 60901a0a46784dfe9ffdae8e9396a22d
#: ../../template_ref.rst:404
msgid "transliterate(a)"
msgstr ""

# 1716e9f249484c1b8a501d846e70b929
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTransliterate:1
msgid ""
"transliterate(a) -- Returns a string in a latin alphabet formed by "
"approximating the sound of the words in the source string. For example, if "
"the source is \"Фёдор Миха́йлович Достоевский\" the function returns "
"\"Fiodor Mikhailovich Dostoievskii\"."
msgstr ""

# cd696f48c3fc4aa0b02a24ad38bd674b
#: ../../template_ref.rst:410
msgid "API of the Metadata objects"
msgstr "API der Metadatenobjekte"

# 4b318d488aed4d788877dbdf10e0c558
#: ../../template_ref.rst:412
msgid ""
"The python implementation of the template functions is passed in a Metadata "
"object. Knowing it's API is useful if you want to define your own template "
"functions."
msgstr ""

# a38a4b81409b4a069ac8d1d510b5ce8c
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:1
msgid ""
"A class representing all the metadata for a book. The various standard "
"metadata fields are available as attributes of this object. You can also "
"stick arbitrary attributes onto this object."
msgstr ""

# fc2f0594f81444b0bee93c10dd66548e
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:5
msgid ""
"Metadata from custom columns should be accessed via the get() method, "
"passing in the lookup name for the column, for example: \"#mytags\"."
msgstr ""

# ad5b9de131e343b1863b9a4f24736bfc
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:8
msgid "Use the :meth:`is_null` method to test if a field is null."
msgstr ""

# bcf8efd0fe23425ebfe834cf9e359967
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:10
msgid "This object also has functions to format fields into strings."
msgstr ""

# f7c60e8ea54143b6be8a7f556a67c4d7
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:12
msgid ""
"The list of standard metadata fields grows with time is in "
":data:`STANDARD_METADATA_FIELDS`."
msgstr ""

# 1959c4680c904e50bff79a5fa597898a
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:15
msgid ""
"Please keep the method based API of this class to a minimum. Every method "
"becomes a reserved field name."
msgstr ""

# 7a20395f645c4ab883bde70bbec9b1f0
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:1
msgid ""
"Return True if the value of field is null in this object. 'null' means it is"
" unknown or evaluates to False. So a title of _('Unknown') is null or a "
"language of 'und' is null."
msgstr ""

# fb4a3242a6b74bd78976076be1786fe9
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:5
msgid ""
"Be careful with numeric fields since this will return True for zero as well "
"as None."
msgstr ""

# ec21bfabe9284f048afcd1c2b960b080
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:8
msgid "Also returns True if the field does not exist."
msgstr ""

# 555ae53d70da4fe193c6c2a4f71fd1d3
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.deepcopy:1
msgid ""
"Do not use this method unless you know what you are doing, if you want to "
"create a simple clone of this object, use :meth:`deepcopy_metadata` instead."
" Class_generator must be a function that returns an instance of Metadata or "
"a subclass of it."
msgstr ""

# 3821875e0d6b41a187168b5df6b2eb58
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_identifiers:1
msgid ""
"Return a copy of the identifiers dictionary. The dict is small, and the "
"penalty for using a reference where a copy is needed is large. Also, we "
"don't want any manipulations of the returned dict to show up in the book."
msgstr ""

# 529155b545de46f7ab564e0a73866576
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_identifiers:1
msgid ""
"Set all identifiers. Note that if you previously set ISBN, calling this "
"method will delete it."
msgstr ""

# 4c1ce6a5aa10467b8503141cae276fed
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_identifier:1
msgid "If val is empty, deletes identifier of type typ"
msgstr ""

# 9da95cf228a74b1983eda7856f368be5
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.standard_field_keys:1
msgid ""
"return a list of all possible keys, even if this book doesn't have them"
msgstr ""

# 140fb95e4f644d878bbd630e61d671fb
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.custom_field_keys:1
msgid "return a list of the custom fields in this book"
msgstr ""

# 2296d27f8a5a4189a427c58192502616
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.all_field_keys:1
msgid "All field keys known by this instance, even if their value is None"
msgstr ""

# 13702d64b8ab416e899bf4cff9d87426
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.metadata_for_field:1
msgid "return metadata describing a standard or custom field."
msgstr ""

# 8e655d65232e41c0abb855e4a6b017ef
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.all_non_none_fields:1
msgid ""
"Return a dictionary containing all non-None metadata fields, including the "
"custom ones."
msgstr ""

# 15b15c0c16004272bb35f3b57d893c00
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_standard_metadata:1
msgid ""
"return field metadata from the field if it is there. Otherwise return None. "
"field is the key name, not the label. Return a copy if requested, just in "
"case the user wants to change values in the dict."
msgstr ""

# 6a2984b464d1434fbeb3efe17e1ff3da
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_all_standard_metadata:1
msgid ""
"return a dict containing all the standard field metadata associated with the"
" book."
msgstr ""

# a5629429fab44741b349f4d74bdcc3fd
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_all_user_metadata:1
msgid ""
"return a dict containing all the custom field metadata associated with the "
"book."
msgstr ""

# efee57d8583f443c82541e60425978a1
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_user_metadata:1
msgid ""
"return field metadata from the object if it is there. Otherwise return None."
" field is the key name, not the label. Return a copy if requested, just in "
"case the user wants to change values in the dict."
msgstr ""

# 088f90cbefdc455a928b73f103444ab2
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_all_user_metadata:1
msgid ""
"store custom field metadata into the object. Field is the key name not the "
"label"
msgstr ""

# 884f44e8c87149949605cb855caeb16a
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_user_metadata:1
msgid ""
"store custom field metadata for one column into the object. Field is the key"
" name not the label"
msgstr ""

# 5d77bb69778541f88f5649b452e56dce
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.template_to_attribute:1
msgid ""
"Takes a list [(src,dest), (src,dest)], evaluates the template in the context"
" of other, then copies the result to self[dest]. This is on a best-efforts "
"basis. Some assignments can make no sense."
msgstr ""

# ca053e4eae8d401881b74a9a1818fa9b
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.smart_update:1
msgid ""
"Merge the information in `other` into self. In case of conflicts, the "
"information in `other` takes precedence, unless the information in `other` "
"is NULL."
msgstr ""

# 3475b66425a143d3aa2400aee42c7a1b
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.format_field:1
msgid "Returns the tuple (display_name, formatted_value)"
msgstr ""

# 266b3796ac954fa59a8a881dafb706d7
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.to_html:1
msgid "A HTML representation of this object."
msgstr ""

# 2ac0327fa4a24c3aa7971ca4793636c5
#: ../../template_ref.rst:422
msgid "The set of standard metadata fields."
msgstr ""
