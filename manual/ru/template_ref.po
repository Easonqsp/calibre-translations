# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-06-17 18:11+0530\n"
"PO-Revision-Date: 2014-06-18 03:43+0000\n"
"Last-Translator: Kovid Goyal <kovid@kovidgoyal.net>\n"
"Language-Team: Russian (http://www.transifex.com/projects/p/calibre/language/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

# 6efec453731240908f167641cd0c7338
#: ../../template_ref.rst:6
msgid "Reference for all built-in template language functions"
msgstr ""

# 6523ce6c80f442e8acf955bcd2a599ef
#: ../../template_ref.rst:8
msgid ""
"Here, we document all the built-in functions available in the |app| template"
" language. Every function is implemented as a class in python and you can "
"click the source links to see the source code, in case the documentation is "
"insufficient. The functions are arranged in logical groups by type."
msgstr ""

# bd004eea62854d6fb9f5443acc5a6502
#: ../../template_ref.rst:17
msgid "Arithmetic"
msgstr ""

# 000f754700ef45b6b414f5c565681713
#: ../../template_ref.rst:20
msgid "add(x, y)"
msgstr ""

# 9df6c2211d4044c08f357c84348f14d1
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAdd:1
msgid ""
"add(x, y) -- returns x + y. Throws an exception if either x or y are not "
"numbers."
msgstr "add(x, y) -- возвращает x + y. Выдает exception, если х или у не числа."

# 81f5f4ec24cd43fd9686b66c82aba53a
#: ../../template_ref.rst:25
msgid "divide(x, y)"
msgstr ""

# 2f435944f0bb48dfbb902c378d211a79
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinDivide:1
msgid ""
"divide(x, y) -- returns x / y. Throws an exception if either x or y are not "
"numbers."
msgstr "divide(x, y) -- возвращает x / y. Выдает exception, если х или у не числа."

# 0c331537b81a41168655faf4f5a1e91a
#: ../../template_ref.rst:30
msgid "multiply(x, y)"
msgstr ""

# 286fa57cbe4f49ab8849f50ab776d245
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinMultiply:1
msgid ""
"multiply(x, y) -- returns x * y. Throws an exception if either x or y are "
"not numbers."
msgstr "multiply(x, y) -- возвращает x * y. Выдает exception, если х или у не числа."

# 05c7b9ea4f394387962a5219d41f302b
#: ../../template_ref.rst:35
msgid "subtract(x, y)"
msgstr ""

# 1709bf4f84d44d47bb91d2c47f5fe3e0
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubtract:1
msgid ""
"subtract(x, y) -- returns x - y. Throws an exception if either x or y are "
"not numbers."
msgstr "subtract(x, y) -- возвращает x - y. Выдает exception, если х или у не числа."

# 4a563aaf293749d1bde8388cf4b0bc67
#: ../../template_ref.rst:40
msgid "Boolean"
msgstr ""

# ffeb42d9f9334813977295cfd3ed2fac
#: ../../template_ref.rst:43
msgid "and(value, value, ...)"
msgstr ""

# 460f42bc0dd9433f93108080378d03b1
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAnd:1
msgid ""
"and(value, value, ...) -- returns the string \"1\" if all values are not "
"empty, otherwise returns the empty string. This function works well with "
"test or first_non_empty. You can have as many values as you want."
msgstr "and(значение, значение, ...) -- возвращает строку \"1\" если все значения не пустые, иначе возвращает пустую строку. Эту функцию удобно использовать с функциями test или first_non_empty. Количество значений не ограничено."

# 2e32489318e946eda70b1d8976eb286a
#: ../../template_ref.rst:48
msgid "not(value)"
msgstr ""

# c2cfbfbd69e64cab8c2bfe024c290cd9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinNot:1
msgid ""
"not(value) -- returns the string \"1\" if the value is empty, otherwise "
"returns the empty string. This function works well with test or "
"first_non_empty. You can have as many values as you want."
msgstr "not(значение) -- возвращает строку \"1\" если значение пусто, иначе возвращает пустую строку. Эту функцию удобно использовать с функциями test или first_non_empty. Количество значений не ограничено."

# abdef009167947df95aa9779ed58c758
#: ../../template_ref.rst:53
msgid "or(value, value, ...)"
msgstr ""

# e88d2626115f4340b933ca3cf2952d7c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinOr:1
msgid ""
"or(value, value, ...) -- returns the string \"1\" if any value is not empty,"
" otherwise returns the empty string. This function works well with test or "
"first_non_empty. You can have as many values as you want."
msgstr "or(значение, значение, ...) -- возвращает строку \"1\" если есть хотя бы одно непустое значение, иначе возвращает пустую строку. Эту функцию удобно использовать с функциями test или first_non_empty. Количество значений не ограничено."

# b15f94963c474e1498f9cf8c3ddb9668
#: ../../template_ref.rst:58
msgid "Date functions"
msgstr ""

# fbfb42bea98b4cad927052cbf9e65862
#: ../../template_ref.rst:61
msgid "days_between(date1, date2)"
msgstr ""

# 3b29ad94cc53484cb56f4a4c660d1c7a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinDaysBetween:1
msgid ""
"days_between(date1, date2) -- return the number of days between date1 and "
"date2. The number is positive if date1 is greater than date2, otherwise "
"negative. If either date1 or date2 are not dates, the function returns the "
"empty string."
msgstr "days_between (дата1, дата2) - возвращает количество дней между дата1 и дата2. Число положительно, если дата1 больше дата2, в противном случае отрицательно. Если дата1 или дата2 не даты, функция возвращает пустую строку."

# 54ea38bbef6f4816a6351e00ae7d1f48
#: ../../template_ref.rst:66
msgid "today()"
msgstr ""

# dcd1cf7fd0d048e49efaa3e1c9a66b00
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinToday:1
msgid ""
"today() -- return a date string for today. This value is designed for use in"
" format_date or days_between, but can be manipulated like any other string. "
"The date is in ISO format."
msgstr "today() -- возвращает текущий день в виде строки. Это значение предназначено для использования в format_date или days_between, но можно использовать как и любую другую строку. Дата в формате ISO."

# 004fa17c02684cd19277bec2e38dc616
#: ../../template_ref.rst:71
msgid "Formatting values"
msgstr ""

# 3b4942dc5992491894ad3e0c61295260
#: ../../template_ref.rst:74
msgid "finish_formatting(val, fmt, prefix, suffix)"
msgstr ""

# 67b91c66948a42d18c0045ca1f8fa732
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFinishFormatting:1
msgid ""
"finish_formatting(val, fmt, prefix, suffix) -- apply the format, prefix, and"
" suffix to a value in the same way as done in a template like "
"`{series_index:05.2f| - |- }`. For example, the following program produces "
"the same output as the above template: program: "
"finish_formatting(field(\"series_index\"), \"05.2f\", \" - \", \" - \")"
msgstr "finish_formatting(значение, формат, префикс, суффикс) -- применяет формат, префикс и суффикс к значению так же, как в шаблоне вроде `{series_index:05.2f| - |- }`. Например, слудующая программа делает то же, что и указанный шаблон: program: finish_formatting(field(\"series_index\"), \"05.2f\", \" - \", \" - \")"

# 1cc1bd8bb7514908bf7f0e7a101c2442
#: ../../template_ref.rst:79
msgid "format_date(val, format_string)"
msgstr ""

# d63408dfafdf4985852d5f51e73519d4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatDate:1
msgid ""
"format_date(val, format_string) -- format the value, which must be a date, "
"using the format_string, returning a string. The formatting codes are: d    "
": the day as number without a leading zero (1 to 31) dd   : the day as "
"number with a leading zero (01 to 31) ddd  : the abbreviated localized day "
"name (e.g. \"Mon\" to \"Sun\"). dddd : the long localized day name (e.g. "
"\"Monday\" to \"Sunday\"). M    : the month as number without a leading zero"
" (1 to 12). MM   : the month as number with a leading zero (01 to 12) MMM  :"
" the abbreviated localized month name (e.g. \"Jan\" to \"Dec\"). MMMM : the "
"long localized month name (e.g. \"January\" to \"December\"). yy   : the "
"year as two digit number (00 to 99). yyyy : the year as four digit number. h"
"    : the hours without a leading 0 (0 to 11 or 0 to 23, depending on am/pm)"
" hh   : the hours with a leading 0 (00 to 11 or 00 to 23, depending on "
"am/pm) m    : the minutes without a leading 0 (0 to 59) mm   : the minutes "
"with a leading 0 (00 to 59) s    : the seconds without a leading 0 (0 to 59)"
" ss   : the seconds with a leading 0 (00 to 59) ap   : use a 12-hour clock "
"instead of a 24-hour clock, with \"ap\" replaced by the localized string for"
" am or pm AP   : use a 12-hour clock instead of a 24-hour clock, with \"AP\""
" replaced by the localized string for AM or PM iso  : the date with time and"
" timezone. Must be the only format present"
msgstr "format_date(значение, формат_строки) -- форматирует значение, которое должно быть датой, используя формат_строки. Возвращает строку. Коды форматирования следующие: d    : номер дня месяца без первого нуля (от 1 до 31) dd   : номер дня месяца с нулём (от 01 до 31) ddd  : сокращённое локализованное название дня недели (от \"Пн\" до \"Вс\"). dddd : полное локализованное название дня недели (от \"Понедельник\" до \"Воскресенье\"). M    : номер месяца в году без первого нуля (от 1 до 12). MM   : номер месяца в году с нулём (от 01 до 12) MMM  : сокращённое локализованное название месяца (от \"Янв\" до \"Дек\"). MMMM : полное локализованное название месяца (от \"Январь\" до \"Декабрь\"). yy   : две последние цифры года (от 00 до 99). yyyy : полный номер года из четырёх цифр. h    : часы без первого 0 (от 0 до 11 или от 0 до 23, в зависимости от am/pm (12/24) формата времени) hh   : часы с первым 0 (от 00 до 11 или от  00 до 23, в зависимости от am/pm) m    : минуты без первого 0 (от 0 до 59) mm   : минуты с 0 (от 00 до 59) s    : секунды без первого 0 (от 0 до 59) ss   : секунды с 0 (от 00 до 59) ap   :использовать 12-часовой формат вместо 24-часового, с \"ap\" заменённым на локализованную строку для am или pm AP   : использовать 12-часовой формат вместо 24-часового, с \"AP\"  заменённым на локализованную строку для AM или PM iso  : дата, время и временная зона. Должен быть только текущий формат"

# 1b6f70c05940466f946c8879bd253e9f
#: ../../template_ref.rst:84
msgid "format_number(v, template)"
msgstr ""

# 82c732926ac64a7b8240cf55179ccbc2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatNumber:1
msgid ""
"format_number(v, template) -- format the number v using a python formatting "
"template such as \"{0:5.2f}\" or \"{0:,d}\" or \"${0:5,.2f}\". The "
"field_name part of the template must be a 0 (zero) (the \"{0:\" in the above"
" examples). See the template language and python documentation for more "
"examples. Returns the empty string if formatting fails."
msgstr "format_number(значение, шаблон) -- форматирует число \"значение\" используя \"шаблон\" форматирования Python вроде \"{0:5.2f}\" или \"{0:,d}\" или \"${0:5,.2f}\". Часть шаблона \"Название поля\" (field_name part) должна быть 0 (ноль) (\"{0:\" в приведённых выше примерах). Ищите больше примеров в описании языка шаблонов или документации python. Если форматирование не удалось, то возвращается пустая строка."

# 1be5a800766443fbb5d0c40cdf741201
#: ../../template_ref.rst:89
msgid "human_readable(v)"
msgstr ""

# cc406c30e1d149debd8afb08188c494e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinHumanReadable:1
msgid ""
"human_readable(v) -- return a string representing the number v in KB, MB, "
"GB, etc."
msgstr "human_readable(v) -- возвращает строку, представляющюю число v в виде KB, MB, GB, и т.д."

# 8b1fc7a43be947debeff0d0c6751c99e
#: ../../template_ref.rst:94
msgid "Get values from metadata"
msgstr ""

# 3331c442eaf44f06a9836e609d2e24ad
#: ../../template_ref.rst:97
msgid "approximate_formats()"
msgstr ""

# 9abe5fe6d31442a08a384d9e3d4828f1
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinApproximateFormats:1
msgid ""
"approximate_formats() -- return a comma-separated list of formats that at "
"one point were associated with the book. There is no guarantee that this "
"list is correct, although it probably is. This function can be called in "
"template program mode using the template \"{:'approximate_formats()'}\". "
"Note that format names are always uppercase, as in EPUB. This function works"
" only in the GUI. If you want to use these values in save-to-disk or send-"
"to-device templates then you must make a custom \"Column built from other "
"columns\", use the function in that column's template, and use that column's"
" value in your save/send templates"
msgstr "approximate_formats() -- возвращает разделённый запятыми список форматов которые в какой то момент были связаны с книгой. Нет гарантий что список будет правильным, хотя скорее всего. Эта функция может быть вызвана из режима выполнения программы через шаблон \"{:'approximate_formats()'}\". Помните, что названия форматов всегда в верхнем регистре, например как EPUB. Эта функция работает только с графическим интерфейсом. Если вы желаете использовать эти значения в шаблоне для сохранения на диск или отправки на устройство, то вам следует создать пользовательский столбец типа \"Столбец состоящий из других столбцов\" и использовать функцию в нём, а затем использовать значение этого столбца в ваших шаблонах сохранения/отправки."

# 777450b87610421cb704e10bf3de76b3
#: ../../template_ref.rst:102
msgid "booksize()"
msgstr ""

# 1d4ab3b49f3a420ca493355c49c1fe45
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinBooksize:1
msgid ""
"booksize() -- return value of the size field. This function works only in "
"the GUI. If you want to use this value in save-to-disk or send-to-device "
"templates then you must make a custom \"Column built from other columns\", "
"use the function in that column's template, and use that column's value in "
"your save/send templates"
msgstr "booksize() -- возвращает значение поля размер. Эта функция работает только в графическом интерфейсе. Если вы желаете использовать её значение в шаблоне для сохранения на диск или отправки на устройство, то вам следует создать пользовательский столбец типа \"Столбец состоящий из других столбцов\" и использовать функцию в нём, а затем использовать значение этого столбца в ваших шаблонах сохранения/отправки."

# 5895083e9e834d499fa1e27fbee1d764
#: ../../template_ref.rst:107
msgid "current_library_name()"
msgstr ""

# f9461dc008cd408a902f5747adcc098b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCurrentLibraryName:1
msgid ""
"current_library_name() -- return the last name on the path to the current "
"calibre library. This function can be called in template program mode using "
"the template \"{:'current_library_name()'}\"."
msgstr "current_library_name() -- возвращает последнее имя в пути к текущей библиотеке. Эта функция может быть вызвана в режиме программирования шаблона с помощью шаблона \"{:'current_library_name()'}\"."

# 9f6bf5836b744f51b3f32e85b34a7637
#: ../../template_ref.rst:112
msgid "current_library_path()"
msgstr ""

# baff53eb0be840e7853655851b14eac3
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCurrentLibraryPath:1
msgid ""
"current_library_path() -- return the path to the current calibre library. "
"This function can be called in template program mode using the template "
"\"{:'current_library_path()'}\"."
msgstr "current_library_path() -- возвращает путь к текущей библиотеке calibre. Эта функция может быть вызвана в режиме создания шаблона с помощью шаблона \"{:'current_library_path()'}\"."

# 8821e40b3f954017a8ca21cde20082ff
#: ../../template_ref.rst:117
msgid "field(name)"
msgstr ""

# 17edf073a1ba4050a37fc1b1615dafcc
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinField:1
msgid "field(name) -- returns the metadata field named by name"
msgstr "field(название) -- возвращает поле метаданных с указанным названием"

# 4fb82b9a5963438ca1ac6aebaa92cf57
#: ../../template_ref.rst:122
msgid "formats_modtimes(date_format)"
msgstr ""

# fbeb78434f314d65b8cb8728689cfb45
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsModtimes:1
msgid ""
"formats_modtimes(date_format) -- return a comma-separated list of "
"colon_separated items representing modification times for the formats of a "
"book. The date_format parameter specifies how the date is to be formatted. "
"See the date_format function for details. You can use the select function to"
" get the mod time for a specific format. Note that format names are always "
"uppercase, as in EPUB."
msgstr "formats_modtimes(date_format) -- возвращает список элементов представляющих время изменения форматов книги. Список разделяется запятыми, элементы разделяются двоеточиями. Параметр date_format указывает как дата должна быть форматирована. Смотрите подробности в описании функции date_format. Вы можете использовать функцию select что бы получить время модификации определённого формата. Помните, что названия форматов всегда в верхнем регистре, например EPUB."

# 2356f5942f9546a086b3bab5640c8de5
#: ../../template_ref.rst:127
msgid "formats_paths()"
msgstr ""

# 48017182f6ba404faea851dbe528d639
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsPaths:1
msgid ""
"formats_paths() -- return a comma-separated list of colon_separated items "
"representing full path to the formats of a book. You can use the select "
"function to get the path for a specific format. Note that format names are "
"always uppercase, as in EPUB."
msgstr "formats_paths() -- возвращает список элементов, означающих полный путь к форматам книги. Список разделяется запятыми, элементы разделяются двоеточиями. Вы можете использовать функцию select что бы получить путь для конкретного формата. Помните, что имена форматов всегда в верхнем регистре, как например EPUB."

# 05465c0966e94c92a7b0a96b20adcaeb
#: ../../template_ref.rst:132
msgid "formats_sizes()"
msgstr ""

# 95931191391e462892c35c98f9b1b856
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFormatsSizes:1
msgid ""
"formats_sizes() -- return a comma-separated list of colon_separated items "
"representing sizes in bytes of the formats of a book. You can use the select"
" function to get the size for a specific format. Note that format names are "
"always uppercase, as in EPUB."
msgstr "formats_sizes() -- возвращает список элементов представляющих размеры форматов книг в байтах. Список разделяется запятыми, элементы разделяются двоеточиями. Вы можете использовать функцию select что бы получить размер отдельного формата. Помните, что названия форматов всегда в верхнем регистре, например EPUB."

# b00d02e1795b4fbe90ea5776475a761e
#: ../../template_ref.rst:137
msgid "has_cover()"
msgstr ""

# 781a5894bd5b4856a7f8dcbcda7d94e1
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinHasCover:1
msgid ""
"has_cover() -- return Yes if the book has a cover, otherwise return the "
"empty string"
msgstr "has_cover() -- вовзращает Да, если у книги есть обложка, иначе возвращает пустую строку"

# b75a10a1450a4cb2b6c16ec56322e3c1
#: ../../template_ref.rst:142
msgid "language_codes(lang_strings)"
msgstr ""

# f785f599cbf54d6f974473c93563da3b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLanguageCodes:1
msgid ""
"language_codes(lang_strings) -- return the language codes for the strings "
"passed in lang_strings. The strings must be in the language of the current "
"locale. Lang_strings is a comma-separated list."
msgstr "language_codes(строки языка) -- вовращает коды языка для строк, взятых из \"строки языка\". Строки должны быть на языке текущей локализации. \"Строки языка\" - это список разделённый запятыми."

# b025efd1986e43f3b0ce733c4623f097
#: ../../template_ref.rst:147
msgid "language_strings(lang_codes, localize)"
msgstr ""

# a276fb070f274000a47e6b3f2856edfe
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLanguageStrings:1
msgid ""
"language_strings(lang_codes, localize) -- return the strings for the "
"language codes passed in lang_codes. If localize is zero, return the strings"
" in English. If localize is not zero, return the strings in the language of "
"the current locale. Lang_codes is a comma-separated list."
msgstr "language_strings(коды языка, локализация) -- вовращает строку состоящую из кодов языка, взятых из \"коды языка\". Если \"локализация\" равна нулю, то возвращается строка на Английском. Если \"локализация\" не равна нулю, то возвращается строка на языке текущей локализации. \"Коды языка\" - это список разделённый запятыми."

# bf4424a72334459aa952e96615dc3191
#: ../../template_ref.rst:152
msgid "ondevice()"
msgstr ""

# d2ea6ba2636a40eabb3275042efbc30a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinOndevice:1
msgid ""
"ondevice() -- return Yes if ondevice is set, otherwise return the empty "
"string. This function works only in the GUI. If you want to use this value "
"in save-to-disk or send-to-device templates then you must make a custom "
"\"Column built from other columns\", use the function in that column's "
"template, and use that column's value in your save/send templates"
msgstr "ondevice() -- возвращает Yes если параметр ondevice, иначе возвращает пустую строку. Эта функция работает только в графическом интерфейсе. Если вы желаете использовать её значение в шаблоне для сохранения на диск или отправки на устройство, то вам следует создать пользовательский столбец типа \"Столбец состоящий из других столбцов\" и использовать функцию в нём, а затем использовать значение этого столбца в ваших шаблонах сохранения/отправки."

# 2b756531a0bb44fc88e2c5132fe763b4
#: ../../template_ref.rst:157
msgid "raw_field(name)"
msgstr ""

# a8f2d1343f7b47178c82ec69d4a2655e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinRawField:1
msgid ""
"raw_field(name) -- returns the metadata field named by name without applying"
" any formatting."
msgstr "raw_field(название) -- возвращает поле метаданных с указанным названием без применения форматирования."

# 2bbf6f206c3d429bb6b7916a889c625e
#: ../../template_ref.rst:162
msgid "series_sort()"
msgstr ""

# 9d966ac3732842b1afb4b6504580592d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSeriesSort:1
msgid "series_sort() -- return the series sort value"
msgstr "series_sort() -- возвращает сортировочное значение серии"

# c6812768bbd4466f88bdc1d1721c6ce1
#: ../../template_ref.rst:167
msgid "virtual_libraries()"
msgstr ""

# ab46577e080840178dde8de00517047e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinVirtualLibraries:1
msgid ""
"virtual_libraries() -- return a comma-separated list of virtual libraries "
"that contain this book. This function works only in the GUI. If you want to "
"use these values in save-to-disk or send-to-device templates then you must "
"make a custom \"Column built from other columns\", use the function in that "
"column's template, and use that column's value in your save/send templates"
msgstr "virtual_libraries() -- возвращает разделённый запятыми список виртуальных библиотек, которые содержат эту книгу. Эта функция работает только в графическом интерфейсе. Если вы желаете использовать её значение в шаблоне для сохранения на диск или отправки на устройство, то вам следует создать пользовательский столбец типа \"Столбец состоящий из других столбцов\" и использовать функцию в нём, а затем использовать значение этого столбца в ваших шаблонах сохранения/отправки."

# 008daa4646b44e318266a356cf7f0444
#: ../../template_ref.rst:172
msgid "If-then-else"
msgstr ""

# 03440f763d8a420da913fb8c70aeaa5a
#: ../../template_ref.rst:175
msgid "contains(val, pattern, text if match, text if not match)"
msgstr ""

# bbc0becf60fd453588955fad57d30bd0
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinContains:1
msgid ""
"contains(val, pattern, text if match, text if not match) -- checks if field "
"contains matches for the regular expression `pattern`. Returns `text if "
"match` if matches are found, otherwise it returns `text if no match`"
msgstr "contains(значение, шаблон, текст при совпадении, текст при несовпадении) -- проверяет поле на совпадения с регулярным выражением \"шаблон\" и возвращает текст в зависимости от результата."

# 7d84358453e24a94b1cd68a45cea1347
#: ../../template_ref.rst:180
msgid "ifempty(val, text if empty)"
msgstr ""

# 4ffc93cd686148e297833674e4aa4c54
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinIfempty:1
msgid ""
"ifempty(val, text if empty) -- return val if val is not empty, otherwise "
"return `text if empty`"
msgstr "ifempty(значение, текст если пусто) -- возвращает значение, если оно не является пустым, иначе возвращает \"текст если пусто\""

# f2aa4f636a4648a19802dd43fba9f8e1
#: ../../template_ref.rst:185
msgid "test(val, text if not empty, text if empty)"
msgstr ""

# 8c0a050303d04feeb534ac1be35ac8fa
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTest:1
msgid ""
"test(val, text if not empty, text if empty) -- return `text if not empty` if"
" the field is not empty, otherwise return `text if empty`"
msgstr "test(значение, текст если не пусто, текст если пусто) -- возвращает текст в зависимости от того пустое или нет значение поля"

# 7a77a4d33b21429f842a55d1a0be45f6
#: ../../template_ref.rst:190
msgid "Iterating over values"
msgstr ""

# 063f17dbb6ae403caab0ebbd2df35f00
#: ../../template_ref.rst:193
msgid "first_non_empty(value, value, ...)"
msgstr ""

# 47242b2974734833adc1f6fbfeef4e7d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFirstNonEmpty:1
msgid ""
"first_non_empty(value, value, ...) -- returns the first value that is not "
"empty. If all values are empty, then the empty value is returned. You can "
"have as many values as you want."
msgstr "first_non_empty(значение, значение, ...) -- возвращает первое значение которое не пусто. Если все значения пусты, то возвращается пустое значение. Количество значений не ограничено."

# 65a9dc195e304e349f6f724ba84c95f7
#: ../../template_ref.rst:198
msgid "lookup(val, pattern, field, pattern, field, ..., else_field)"
msgstr ""

# f4e5ced8eed74fce88802ad2194ad8a7
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLookup:1
msgid ""
"lookup(val, pattern, field, pattern, field, ..., else_field) -- like switch,"
" except the arguments are field (metadata) names, not text. The value of the"
" appropriate field will be fetched and used. Note that because composite "
"columns are fields, you can use this function in one composite field to use "
"the value of some other composite field. This is extremely useful when "
"constructing variable save paths"
msgstr "lookup(значение, шаблон1, поле1, шаблон2, поле2, ..., иначе_поле) -- как switch, за тем исключением что аргументы - это названия полей метаданных а не текст. Значение соответствующего поля извлекается и используется. Помните, что изза того, что составные столбцы тоже поля, вы можете использовать эту функцию в одном составном поле, что бы использовать данные другого составного поля. Это очень полезно при создании различных путей сохранения"

# 81382ed56c9d4ef0bff0e626a19e7e2b
#: ../../template_ref.rst:203
msgid "switch(val, pattern, value, pattern, value, ..., else_value)"
msgstr ""

# ebe66236c16a44c18e48116f1572f00f
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSwitch:1
msgid ""
"switch(val, pattern, value, pattern, value, ..., else_value) -- for each "
"`pattern, value` pair, checks if the field matches the regular expression "
"`pattern` and if so, returns that `value`. If no pattern matches, then "
"else_value is returned. You can have as many `pattern, value` pairs as you "
"want"
msgstr "switch(значение, шаблон1, значение1, шаблон2, значение2, ..., иначе_значение) -- для каждой пары \"шаблон, значение\" проверяет совпадение поля с регулярным выражением \"шаблон\" и если да, то возвращает \"значение\". Если нет совпадающих шаблонов, то возвращается значение \"иначе_значение\". Количество пар \"шаблон, значение\" не ограничено."

# b7e63762e0b94b149353432e2bbfc817
#: ../../template_ref.rst:208
msgid "List lookup"
msgstr ""

# b0519240a97844b8bbf808ef3d09abe8
#: ../../template_ref.rst:211
msgid "identifier_in_list(val, id, found_val, not_found_val)"
msgstr ""

# ef833871df7648f295044d287c4cc045
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinIdentifierInList:1
msgid ""
"identifier_in_list(val, id, found_val, not_found_val) -- treat val as a list"
" of identifiers separated by commas, comparing the string against each value"
" in the list. An identifier has the format \"identifier:value\". The id "
"parameter should be either \"id\" or \"id:regexp\". The first case matches "
"if there is any identifier with that id. The second case matches if the "
"regexp matches the identifier's value. If there is a match, return "
"found_val, otherwise return not_found_val."
msgstr "identifier_in_list(значение, идентификатор, значение если найдено, значение если не найдено) -- Обрабатывает значение как список идентификаторов разделённых запятой, сравнивая \"идентификатор\" с каждым элементом списка. Идентификатор имеет формат \"идентификатор:значение\". Параметр \"идентификатор\" должен иметь формат \"идентификатор\" или \"идентификатор:регулярное выражение\". В первом случае будет искаться совпадение с любым элементом списка содержащим соответствующий идентификационный ключ. Во втором случае будет искаться совпадение значения идентификатора с регулярным выражением. Если найдено совпадение, то возвращается \"начение если найдено\" а иначе \"значение если не найдено\"."

# 7a76a931f6a84fb29fb3aad768c930ad
#: ../../template_ref.rst:216
msgid "in_list(val, separator, pattern, found_val, not_found_val)"
msgstr ""

# e00c93a3d4454aa2827e9f1509c681ab
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinInList:1
msgid ""
"in_list(val, separator, pattern, found_val, not_found_val) -- treat val as a"
" list of items separated by separator, comparing the pattern against each "
"value in the list. If the pattern matches a value, return found_val, "
"otherwise return not_found_val."
msgstr "in_list(значение, разделитель, шаблон, значение если найдено, значение если не найдено) -- обрабатывает значение как список элементов разделённых \"разделителем\", сравнивая с \"шаблоном\" каждый элемент списка. Если шаблон соответствует одному из значений, то возвращается \"начение если найдено\" а иначе \"значение если не найдено\"."

# 35a2521b89994869abe8aba908b8a3e6
#: ../../template_ref.rst:221
msgid "list_item(val, index, separator)"
msgstr ""

# 2893b066bbd84addacbd16830729fd1c
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListitem:1
msgid ""
"list_item(val, index, separator) -- interpret the value as a list of items "
"separated by `separator`, returning the `index`th item. The first item is "
"number zero. The last item can be returned using `list_item(-1,separator)`. "
"If the item is not in the list, then the empty value is returned. The "
"separator has the same meaning as in the count function."
msgstr "list_item(значение, индекс, разделитель) -- обрабатывает значение как список элементов разделённых \"разделителем\", возвращая элемент с номером \"индекс\". Первый элемент имеет номер ноль. Последний элемент может быть получен выражением \"list_item(-1,разделитель)\". Если элемент не в списке, то возвращается пустое значение. Разделитель работает так же как и в функции count."

# 8a81519cfeb84e628be943f330f363f2
#: ../../template_ref.rst:226
msgid "select(val, key)"
msgstr ""

# ea68c1fdb12b440cabcce2bdd404a32d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSelect:1
msgid ""
"select(val, key) -- interpret the value as a comma-separated list of items, "
"with the items being \"id:value\". Find the pair with the id equal to key, "
"and return the corresponding value."
msgstr "select(значение, ключ) -- интерпретирует значение как список элементов разделённых запятой, элементы имеют формат \"идентификатор:значение\". Ищет пару с идентификатором равным ключу и возвращает соответствующее значение."

# 90b4d21d6e514347b21a2c7618417966
#: ../../template_ref.rst:231
msgid "str_in_list(val, separator, string, found_val, not_found_val)"
msgstr ""

# 43c1423cbedb408ca75cf7cadbb2b7bc
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrInList:1
msgid ""
"str_in_list(val, separator, string, found_val, not_found_val) -- treat val "
"as a list of items separated by separator, comparing the string against each"
" value in the list. If the string matches a value, return found_val, "
"otherwise return not_found_val. If the string contains separators, then it "
"is also treated as a list and each value is checked."
msgstr "str_in_list(значение, разделитель, строка, значение если найдено, значение если не найдено) -- обрабатывает значение как список элементов разделённых \"разделителем\", сравнивая со \"строкой\" каждый элемент списка. Если строка соответствует одному из значений, то возвращается \"начение если найдено\" а иначе \"значение если не найдено\". Если строка содержит разделители, то она тоже разделяется как список и каждое значение проверяется."

# 528b96c84d9742428ecc53535b61f646
#: ../../template_ref.rst:236
msgid "List manipulation"
msgstr ""

# 6095515bcdca429e95151005f50decfb
#: ../../template_ref.rst:239
msgid "count(val, separator)"
msgstr ""

# aa87da5e3fad4845a55b4cc569cd01d4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCount:1
msgid ""
"count(val, separator) -- interprets the value as a list of items separated "
"by `separator`, returning the number of items in the list. Most lists use a "
"comma as the separator, but authors uses an ampersand. Examples: "
"{tags:count(,)}, {authors:count(&)}"
msgstr "count(значение, разделитель) -- интерпретирует значение как список элементов, разделенных \"разделителем\", возвращая количество элементов в списке. Большинство списков использует запятую в качестве разделителя, но для авторов используют амперсанд. Примеры: {tags:count(,)}, {authors:count(&)}"

# 7fd83219f5a7434684694527d8d42165
#: ../../template_ref.rst:244
msgid "list_difference(list1, list2, separator)"
msgstr ""

# 21c8195b9bfd41838fec187bfa05fd7a
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListDifference:1
msgid ""
"list_difference(list1, list2, separator) -- return a list made by removing "
"from list1 any item found in list2, using a case-insensitive compare. The "
"items in list1 and list2 are separated by separator, as are the items in the"
" returned list."
msgstr "list_difference(список1, список2, разделитель) -- возвращает список полученный удалением из списка1 любых совпадающих элементов из списка2 без учёта регистра. Элементы в списке1 и списке2 разделены \"разделителем\", как и элементы в возвращаемом списке."

# 4676aa2851b34a61b53a05f6ce69e40b
#: ../../template_ref.rst:249
msgid "list_equals(list1, sep1, list2, sep2, yes_val, no_val)"
msgstr ""

# 0e24b0fada7f4ccd887d143f134ca378
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListEquals:1
msgid ""
"list_equals(list1, sep1, list2, sep2, yes_val, no_val) -- return yes_val if "
"list1 and list2 contain the same items, otherwise return no_val. The items "
"are determined by splitting each list using the appropriate separator "
"character (sep1 or sep2). The order of items in the lists is not relevant. "
"The compare is case insensitive."
msgstr "list_equals(список1, разделитель1, список2, разделитель2, да значение, нет значение) -- возвращает \"да значение\" если список1 и список2 содержат одинаковые элементы, иначе возвращает \"нет значение\". Элементы определяются разделением списка по указанному разделителю для каждого списка. Порядок элементов в списке и регистр символов не учитываются."

# e1273a3a78d6449bbaec067787a22e67
#: ../../template_ref.rst:254
msgid "list_intersection(list1, list2, separator)"
msgstr ""

# 984fb9da3d6e4d78b799cc01453feef9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListIntersection:1
msgid ""
"list_intersection(list1, list2, separator) -- return a list made by removing"
" from list1 any item not found in list2, using a case-insensitive compare. "
"The items in list1 and list2 are separated by separator, as are the items in"
" the returned list."
msgstr "list_intersection(список1, список2, разделитель) -- возвращает список полученный удалением из списка1 любых элементов не совпадающих со списком2 без учёта регистра. Элементы в списке1 и списке2 разделены \"разделителем\", как и элементы в возвращаемом списке."

# 7fb1e208f67e4682977448adc852ca3f
#: ../../template_ref.rst:259
msgid "list_re(src_list, separator, search_re, opt_replace)"
msgstr ""

# 549313286d1b4cf6a4d9da8c7e1356bf
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListRe:1
msgid ""
"list_re(src_list, separator, search_re, opt_replace) -- Construct a list by "
"first separating src_list into items using the separator character. For each"
" item in the list, check if it matches search_re. If it does, then add it to"
" the list to be returned. If opt_replace is not the empty string, then apply"
" the replacement before adding the item to the returned list."
msgstr "list_re(исходный список, разделитель, поисковое выражение, возможная замена) -- Строит список вначале разделяя \"исходный список\" на элементы используя символ \"разделителя\". Каждый элемент в списке проверяется на совпадение с \"поисковым выражением\". Если совпадает, то элемент добавляется в возвращаемый список. Если \"возможная замена\" - не пустая строка, то перед добавлением в новый список происходит замена."

# f5931ae9a10949139ae6eefd72c3c9bd
#: ../../template_ref.rst:264
msgid "list_sort(list, direction, separator)"
msgstr ""

# 4a06e8b1a36045b4b07e0ed449d89005
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListSort:1
msgid ""
"list_sort(list, direction, separator) -- return list sorted using a case-"
"insensitive sort. If direction is zero, the list is sorted ascending, "
"otherwise descending. The list items are separated by separator, as are the "
"items in the returned list."
msgstr "list_sort(список, направление, разделитель) -- возвращает отсортированный список без учёта регистра. Если \"направление\" равно нулю, лист сортируется по возрастанию, иначе по убыванию. Элементы в списке разделены \"разделителем\", как и элементы в возвращаемом списке."

# e5b0a088b7734b59a970c3df0cb8d714
#: ../../template_ref.rst:269
msgid "list_union(list1, list2, separator)"
msgstr ""

# d49bb9de35c440338ce4bd32aeec660d
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinListUnion:1
msgid ""
"list_union(list1, list2, separator) -- return a list made by merging the "
"items in list1 and list2, removing duplicate items using a case-insensitive "
"compare. If items differ in case, the one in list1 is used. The items in "
"list1 and list2 are separated by separator, as are the items in the returned"
" list."
msgstr "list_union(список1, список2, разделитель) -- возвращает список полученный объединением элементов списка1 и списка2, исключая повторяющиеся элементы без учёта регистра. Если элементы отличаются регистром, то будет взят элемент из списка1. Элементы в списке1 и списке2 разделены \"разделителем\", как и элементы в возвращаемом списке."

# 5969a773ad0c465ca27bcf6d420ca277
#: ../../template_ref.rst:274
msgid "subitems(val, start_index, end_index)"
msgstr ""

# db9ae387ba6940bb90a0958ca1531800
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubitems:1
msgid ""
"subitems(val, start_index, end_index) -- This function is used to break "
"apart lists of items such as genres. It interprets the value as a comma-"
"separated list of items, where each item is a period-separated list. Returns"
" a new list made by first finding all the period-separated items, then for "
"each such item extracting the `start_index` to the `end_index` components, "
"then combining the results back together. The first component in a period-"
"separated list has an index of zero. If an index is negative, then it counts"
" from the end of the list. As a special case, an end_index of zero is "
"assumed to be the length of the list. Example using basic template mode and "
"assuming a #genre value of \"A.B.C\": {#genre:subitems(0,1)} returns \"A\". "
"{#genre:subitems(0,2)} returns \"A.B\". {#genre:subitems(1,0)} returns "
"\"B.C\". Assuming a #genre value of \"A.B.C, D.E.F\", {#genre:subitems(0,1)}"
" returns \"A, D\". {#genre:subitems(0,2)} returns \"A.B, D.E\""
msgstr "subitems(значение, начальный_номер, конечный_номер) -- Эта функция используется для того, что бы разбить список элементов, таких как жанры. Она принимает значение в виде списка элементов разделённых запятой, где каждый элемент - это список элементов разделённых по периоду. Возвращает новый список следующим образом: вначале находятся все периодичные элементы, затем для каждого такого элемента извлекаются компонеты с 'начального_номера' по 'конечный_номер', затем объединённый результат возвращается вместе. Первый компонент в периодичном списке имеет номер ноль. Если номер отриццательный, то счёт идёт с конца списка. Если конечный_номер равен нулю, то обработка идёт до конца списка. Например, используя основной режим шаблона и присвоив #genre (жанру) значение \"A.B.C\" используя: {#genre:subitems(0,1)} получим \"A\". {#genre:subitems(0,2)} получим \"A.B\". {#genre:subitems(1,0)} получим \"B.C\". Присвоив #genre (жанру) значение \"A.B.C, D.E.F\", {#genre:subitems(0,1)} получим \"A, D\". {#genre:subitems(0,2)} получим \"A.B, D.E\""

# f6172e2faf5b4bcb9c1a4f7a1939f161
#: ../../template_ref.rst:279
msgid "sublist(val, start_index, end_index, separator)"
msgstr ""

# ad3cafc60fe144c583aeb8eb73a25db4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSublist:1
msgid ""
"sublist(val, start_index, end_index, separator) -- interpret the value as a "
"list of items separated by `separator`, returning a new list made from the "
"`start_index` to the `end_index` item. The first item is number zero. If an "
"index is negative, then it counts from the end of the list. As a special "
"case, an end_index of zero is assumed to be the length of the list. Examples"
" using basic template mode and assuming that the tags column (which is "
"comma-separated) contains \"A, B, C\": {tags:sublist(0,1,\\,)} returns "
"\"A\". {tags:sublist(-1,0,\\,)} returns \"C\". {tags:sublist(0,-1,\\,)} "
"returns \"A, B\"."
msgstr "sublist(значение, начальный индекс, конечный индекс, разделитель) -- рассматривает значение как список элементов разделённых \"разделителем\", возвращая новый список, составленный из элементов старого, начиная с \"начального индекса\" и заканчивая \"конечным индексом\". Первый элемент имеет номер (индекс) ноль. Если индекс отриццательный, то он отсчитывается с конца списка. В особом случае, когда конечный индекс равен нулю это означает что будет обработан весь список. Примеры использования основного режима шаблона, предпологая обработку колонки тэгов, (которые разделены запятой) включающей \"A, B, C\": {tags:sublist(0,1,\\,)} возвращает \"A\". {tags:sublist(-1,0,\\,)} возвращает \"C\". {tags:sublist(0,-1,\\,)} возвращает \"A, B\"."

# 4af0e11897c343d8ab044d73ebb6198b
#: ../../template_ref.rst:284
msgid "Other"
msgstr "Другое"

# 1f8092065f404a909829a36ad9039c16
#: ../../template_ref.rst:287
msgid "assign(id, val)"
msgstr ""

# f679fabdc4954b4989fe18db3fffb9f2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinAssign:1
msgid ""
"assign(id, val) -- assigns val to id, then returns val. id must be an "
"identifier, not an expression"
msgstr "assign(идентификатор, значение) -- присваивает значение идентификатору и возвращает значение. Идентификатор должен быть идентификактором а не выражением."

# 9f321e30070d40d5903b906c241d85f6
#: ../../template_ref.rst:292
msgid "print(a, b, ...)"
msgstr ""

# 41c72d75ece84d06854e3d5146f93b82
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinPrint:1
msgid ""
"print(a, b, ...) -- prints the arguments to standard output. Unless you "
"start calibre from the command line (calibre-debug -g), the output will go "
"to a black hole."
msgstr "print(a, b, ...) -- выводит аргументы в стандартный вывод. Если вы запускаете calibre из командной строки (calibre-debug -g), вывод будет происходить впустую."

# 8084a527323f4fd19406077fe481a702
#: ../../template_ref.rst:297
msgid "Recursion"
msgstr ""

# ed7fc41b41a748aa95cf874945c4ffe7
#: ../../template_ref.rst:300
msgid "eval(template)"
msgstr ""

# 7ced77fce4224b79b3801a490f7abc9e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinEval:1
msgid ""
"eval(template) -- evaluates the template, passing the local variables (those"
" 'assign'ed to) instead of the book metadata.  This permits using the "
"template processor to construct complex results from local variables. "
"Because the { and } characters are special, you must use [[ for the { "
"character and ]] for the } character; they are converted automatically. Note"
" also that prefixes and suffixes (the `|prefix|suffix` syntax) cannot be "
"used in the argument to this function when using template program mode."
msgstr "eval(шаблон) -- обрабатывает шаблон, пропуская локальные переменные (которые 'assign'ed) вместо метаданных книги. Это позволяет использовать обработчик шаблонов для построения сооставных результатов из локальных переменных. Так как символы { и } специальные, вы должны использовать [[ вместо { и ]] вместо }; они преобразуются автоматически. Например, шаблон ('[[title_sort]]') будет опознан как {title_sort} и будет возвращено его значение. Помните также, что префиксы и суффиксы (синтаксис `|prefix|suffix`) не могут быть использованы в аргументе этой функции в режиме создания шаблона."

# dbd5e40f7a25445ab3c4d81554f0ae73
#: ../../template_ref.rst:305
msgid "template(x)"
msgstr ""

# 16864689a8a44ac48f50ca8bdc26b794
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTemplate:1
msgid ""
"template(x) -- evaluates x as a template. The evaluation is done in its own "
"context, meaning that variables are not shared between the caller and the "
"template evaluation. Because the { and } characters are special, you must "
"use [[ for the { character and ]] for the } character; they are converted "
"automatically. For example, template('[[title_sort]]') will evaluate the "
"template {title_sort} and return its value. Note also that prefixes and "
"suffixes (the `|prefix|suffix` syntax) cannot be used in the argument to "
"this function when using template program mode."
msgstr "template(x) -- обрабатывает x как шаблон. Сравнение выполняется в контексте, тоесть переменные не передаются между вызовом и обрабатываемым шаблоном. Так как символы { и } специальные, вы должны использовать [[ вместо { и ]] вместо }; они преобразуются автоматически. Например, шаблон ('[[title_sort]]') будет опознан как {title_sort} и будет возвращено его значение. Помните также, что префиксы и суффиксы (синтаксис `|prefix|suffix`) не могут быть использованы в аргументе этой функции в режиме создания шаблона."

# bbb2ce51f0bf48f1b768a737d6b03970
#: ../../template_ref.rst:310
msgid "Relational"
msgstr ""

# ae04e8804a7742eeaec36f340a4a7a44
#: ../../template_ref.rst:313
msgid "cmp(x, y, lt, eq, gt)"
msgstr ""

# 45fdcdc7b95343c68dbefbdb025b1a2b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCmp:1
msgid ""
"cmp(x, y, lt, eq, gt) -- compares x and y after converting both to numbers. "
"Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr "cmp(x, y, lt, eq, gt) -- конвертирует x и y в числа, затем сравнивает их. Возвращает lt если x < y. Возвращает eq если x == y. Иначе возвращает gt."

# 3bddff3db9e74845af3e0da6f1f26434
#: ../../template_ref.rst:318
msgid "first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result)"
msgstr ""

# 061035d509f9424e897214667622291e
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinFirstMatchingCmp:1
msgid ""
"first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result) -- "
"compares \"val < cmpN\" in sequence, returning resultN for the first "
"comparison that succeeds. Returns else_result if no comparison succeeds. "
"Example: "
"first_matching_cmp(10,5,\"small\",10,\"middle\",15,\"large\",\"giant\") "
"returns \"large\". The same example with a first value of 16 returns "
"\"giant\"."
msgstr "first_matching_cmp(val, cmp1, result1, cmp2, r2, ..., else_result) -- последовательно производит сравнение \"val < cmpN\", возвращая resultN для первого успешного срабатывания. Возвращает else_result если не подошло ни одно значение. Например: first_matching_cmp(10,5,\"small\",10,\"middle\",15,\"large\",\"giant\") вернёт \"large\" :). Тот же пример с первым значением 16 вернёт \"giant\"."

# 2a33d10ae2274755b77453d0fd6baeeb
#: ../../template_ref.rst:323
msgid "strcmp(x, y, lt, eq, gt)"
msgstr ""

# 5b75b83d95514ee7b061a60639629258
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcmp:1
msgid ""
"strcmp(x, y, lt, eq, gt) -- does a case-insensitive comparison of x and y as"
" strings. Returns lt if x < y. Returns eq if x == y. Otherwise returns gt."
msgstr "strcmp(x, y, lt, eq, gt) -- сравнивает строки x и y без учета регистра. Возвращает lt если x < y. Возвращает eq если x == y. Иначе возвращает gt."

# 72447d62e38a4af1ac77694dd3cc8dce
#: ../../template_ref.rst:328
msgid "String case changes"
msgstr ""

# 1fbff04cce6c45f4a81a4a0ec541100b
#: ../../template_ref.rst:331
msgid "capitalize(val)"
msgstr ""

# a504fbf464ca402c878dc7b7bcec7f0b
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinCapitalize:1
msgid "capitalize(val) -- return value of the field capitalized"
msgstr "capitalize(значение) -- возвращает значение поля в режиме предложения (первая буква текста заглавная)"

# 6574b760de234616a136f33ee82d384f
#: ../../template_ref.rst:336
msgid "lowercase(val)"
msgstr ""

# b7458aea8ff941cd9909686e2de32362
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinLowercase:1
msgid "lowercase(val) -- return value of the field in lower case"
msgstr "lowercase(val) -- возвращает аргумент в нижнем регистре"

# 2687d41ce5444321927fec7212b57fc9
#: ../../template_ref.rst:341
msgid "titlecase(val)"
msgstr ""

# d0caacd5533b43789ce9a18c563611e6
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTitlecase:1
msgid "titlecase(val) -- return value of the field in title case"
msgstr "titlecase(val) -- возвращает значение поля в титульном регистре (первые буквы каждого слова заглавные)"

# cb6fb1df842c48a99dc23a10f678839d
#: ../../template_ref.rst:346
msgid "uppercase(val)"
msgstr ""

# 7b9ff1aeaad94fc4a4f850438cf44a17
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinUppercase:1
msgid "uppercase(val) -- return value of the field in upper case"
msgstr "uppercase(val) -- возвращает аргумент в верхнем регистре"

# ad3828f6510049b8b9fcca0f48cb045c
#: ../../template_ref.rst:351
msgid "String manipulation"
msgstr ""

# 6eda962facea4eb8b8c504a8ae4e3390
#: ../../template_ref.rst:354
msgid "re(val, pattern, replacement)"
msgstr ""

# 950bc4255b5340188b7c7ea21ec691b4
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinRe:1
msgid ""
"re(val, pattern, replacement) -- return the field after applying the regular"
" expression. All instances of `pattern` are replaced with `replacement`. As "
"in all of calibre, these are python-compatible regular expressions"
msgstr "re(значение, шаблон, замена) -- возвращает поле после применения регулярного выражения. Все экземпляры \"шаблона\" заменяются на \"замену\". Как и всё в calibre, это python-совместимые регулярные выражения"

# a864dc7a6e2a42ddaeca8f89c5cd4ca0
#: ../../template_ref.rst:359
msgid "shorten(val, left chars, middle text, right chars)"
msgstr ""

# d46a8a3366764af1aebff8864cc4b380
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinShorten:1
msgid ""
"shorten(val, left chars, middle text, right chars) -- Return a shortened "
"version of the field, consisting of `left chars` characters from the "
"beginning of the field, followed by `middle text`, followed by `right chars`"
" characters from the end of the string. `Left chars` and `right chars` must "
"be integers. For example, assume the title of the book is `Ancient English "
"Laws in the Times of Ivanhoe`, and you want it to fit in a space of at most "
"15 characters. If you use {title:shorten(9,-,5)}, the result will be "
"`Ancient E-nhoe`. If the field's length is less than left chars + right "
"chars + the length of `middle text`, then the field will be used intact. For"
" example, the title `The Dome` would not be changed."
msgstr "shorten(val, left chars, middle text, right chars) - Возвращает сокращенную версия поля, состоящую из числа символов от начала строки(`left chars`), затем `middle text`, после число символов с конца строки (`right chars`). `Left chars` и `right chars` должны быть целыми. Например, название книги `Ancient English Laws in the Times of Ivanhoe` и вы хотите, чтобы он поместился в 15 символах. Если вы используете {title:shorten(9,-,5)}, то результат будет `Ancient E-nhoe`. Если длина поля меньше, чем `left chars` + `right chars` + длина `middle text`, то поле будет останется без изменений. Например, название `The Dome` не будет изменено."

# 9befebdfdd4b4f8bb9d1f9236287f0c5
#: ../../template_ref.rst:364
msgid "strcat(a, b, ...)"
msgstr ""

# ffa25975e31d49a29c69d8487de34fd9
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcat:1
msgid ""
"strcat(a, b, ...) -- can take any number of arguments. Returns a string "
"formed by concatenating all the arguments"
msgstr "strcat(a, b, ...) -- принимает любое число аргументов. Возвращает строку, состоящую из объединённых аргументов."

# ed4c92c42be148e296c3abf19d9e9793
#: ../../template_ref.rst:369
msgid "strcat_max(max, string1, prefix2, string2, ...)"
msgstr ""

# 2b9826acf2194d39a61cadbf372993d2
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrcatMax:1
msgid ""
"strcat_max(max, string1, prefix2, string2, ...) -- Returns a string formed "
"by concatenating the arguments. The returned value is initialized to "
"string1. `Prefix, string` pairs are added to the end of the value as long as"
" the resulting string length is less than `max`. String1 is returned even if"
" string1 is longer than max. You can pass as many `prefix, string` pairs as "
"you wish."
msgstr "strcat_max(максимум, строка1, префикс2, строка2, ...) -- Возвращает строку сформированную из соединённых аргументов. Возвращаемое значение инициализируется строкой1. Пары \"префикс, строка\" добавляются в конец значения пока длина строки меньше \"максимума\". Строка1 возвращается даже если её длина больше максимума. Количество пар \"префикс, строка\" не ограничено."

# e14e625fae2a462bacdfe05c76a751fa
#: ../../template_ref.rst:374
msgid "strlen(a)"
msgstr ""

# 91732f037b2d40cc940ff3bb082848e0
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinStrlen:1
msgid "strlen(a) -- Returns the length of the string passed as the argument"
msgstr "strlen(a) -- Возвращает длину строки, переданной в качестве аргумента"

# c7818fdb5d04468d9c08fc976ce7cd8e
#: ../../template_ref.rst:379
msgid "substr(str, start, end)"
msgstr ""

# 9994484b02ca455eb4bf18adc50925ca
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSubstr:1
msgid ""
"substr(str, start, end) -- returns the start'th through the end'th "
"characters of str. The first character in str is the zero'th character. If "
"end is negative, then it indicates that many characters counting from the "
"right. If end is zero, then it indicates the last character. For example, "
"substr('12345', 1, 0) returns '2345', and substr('12345', 1, -1) returns "
"'234'."
msgstr "substr(строка, начало, конец) -- извлекает подстроку ограниченную заданными номерами символов. Первый символ строки имеет номер ноль. Если конец отриццательный, то символы будут отсчитываться с конца строки. Если конец равен нулю, то это означает последний символ строки. Например, substr('12345', 1, 0) вернёт '2345', и substr('12345', 1, -1) вернёт '234'."

# 5a46be26c44f4985abe8e15bee54fdf3
#: ../../template_ref.rst:384
msgid "swap_around_comma(val)"
msgstr ""

# e5ff601fc2064e60bbe7d1e92cabfe03
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinSwapAroundComma:1
msgid ""
"swap_around_comma(val) -- given a value of the form \"B, A\", return \"A "
"B\". This is most useful for converting names in LN, FN format to FN LN. If "
"there is no comma, the function returns val unchanged"
msgstr "swap_around_comma (значение) - получает значение \"B, A\", возвращает \"A B\". Это особенно полезно для преобразования имен из \"AB, AC\" в формат \"AC AB\". Если нет запятой, то функция возвращает значение без изменений"

# 5d01992fbe514d97a69b1e02cbc9de53
#: ../../template_ref.rst:389
msgid "transliterate(a)"
msgstr ""

# 9ca35508f309442cae0dbb69de9488db
#: ../../../src/calibre/utils/formatter_functions.pydocstring of
#: calibre.utils.formatter_functions.BuiltinTransliterate:1
msgid ""
"transliterate(a) -- Returns a string in a latin alphabet formed by "
"approximating the sound of the words in the source string. For example, if "
"the source is \"Фёдор Миха́йлович Достоевский\" the function returns "
"\"Fiodor Mikhailovich Dostoievskii\"."
msgstr ""

# b7dfed5a1abe4f308f56e9a27c5ac9fd
#: ../../template_ref.rst:395
msgid "API of the Metadata objects"
msgstr ""

# fe643ae169ab4ba4bdfd017ae8016606
#: ../../template_ref.rst:397
msgid ""
"The python implementation of the template functions is passed in a Metadata "
"object. Knowing it's API is useful if you want to define your own template "
"functions."
msgstr ""

# 37a0a64316b6431e9ec608702b5b4d4c
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:1
msgid ""
"A class representing all the metadata for a book. The various standard "
"metadata fields are available as attributes of this object. You can also "
"stick arbitrary attributes onto this object."
msgstr ""

# 2b66f74675694877ba671c6a8139eb47
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:5
msgid ""
"Metadata from custom columns should be accessed via the get() method, "
"passing in the lookup name for the column, for example: \"#mytags\"."
msgstr ""

# 91e28d3708a74dc895fb132dbdf484bb
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:8
msgid "Use the :meth:`is_null` method to test if a field is null."
msgstr ""

# c12840d72fc54e219557cb0db2badd71
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:10
msgid "This object also has functions to format fields into strings."
msgstr ""

# a86df87ded51483d872ccaa358a35143
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:12
msgid ""
"The list of standard metadata fields grows with time is in "
":data:`STANDARD_METADATA_FIELDS`."
msgstr ""

# 0fd423d4ce1d48b5970bdd1043319edf
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata:15
msgid ""
"Please keep the method based API of this class to a minimum. Every method "
"becomes a reserved field name."
msgstr ""

# 22911447960a42f6be3bbd1f4d1eee97
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:1
msgid ""
"Return True if the value of field is null in this object. 'null' means it is"
" unknown or evaluates to False. So a title of _('Unknown') is null or a "
"language of 'und' is null."
msgstr ""

# e7f5b3999b764efab2564cba96d0ea6e
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:5
msgid ""
"Be careful with numeric fields since this will return True for zero as well "
"as None."
msgstr ""

# cd104555c97a4778be60c1bd51e690e0
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.is_null:8
msgid "Also returns True if the field does not exist."
msgstr ""

# 50aed35d2c464da1aa06ce605f5709e9
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.deepcopy:1
msgid ""
"Do not use this method unless you know what you are doing, if you want to "
"create a simple clone of this object, use :meth:`deepcopy_metadata` instead."
" Class_generator must be a function that returns an instance of Metadata or "
"a subclass of it."
msgstr ""

# 8c718b42e7c44762a7672fc9f70f0c1e
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_identifiers:1
msgid ""
"Return a copy of the identifiers dictionary. The dict is small, and the "
"penalty for using a reference where a copy is needed is large. Also, we "
"don't want any manipulations of the returned dict to show up in the book."
msgstr ""

# 80231faea6944c6589890957ec7d6235
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_identifiers:1
msgid ""
"Set all identifiers. Note that if you previously set ISBN, calling this "
"method will delete it."
msgstr ""

# 00785d485b2041148982e3d36046b0d7
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_identifier:1
msgid "If val is empty, deletes identifier of type typ"
msgstr ""

# ca3a29c53a0d492fb45a4d44663f40c3
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.standard_field_keys:1
msgid ""
"return a list of all possible keys, even if this book doesn't have them"
msgstr ""

# 5e325a885d6c4e23b5385c660f35d216
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.custom_field_keys:1
msgid "return a list of the custom fields in this book"
msgstr ""

# 56925b7457e54239934484daa9a3406b
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.all_field_keys:1
msgid "All field keys known by this instance, even if their value is None"
msgstr ""

# 1afa7629f39a41ae823b68d120a536da
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.metadata_for_field:1
msgid "return metadata describing a standard or custom field."
msgstr ""

# 6cb732b912324622a5a936fb9e9414e9
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.all_non_none_fields:1
msgid ""
"Return a dictionary containing all non-None metadata fields, including the "
"custom ones."
msgstr ""

# bf3bcb5124f7414c95dcc8a53cd5f38e
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_standard_metadata:1
msgid ""
"return field metadata from the field if it is there. Otherwise return None. "
"field is the key name, not the label. Return a copy if requested, just in "
"case the user wants to change values in the dict."
msgstr ""

# 9f09451eee4a46488a6f45c8b99753b4
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_all_standard_metadata:1
msgid ""
"return a dict containing all the standard field metadata associated with the"
" book."
msgstr ""

# e7af6f739c4a472784adddd7487e4af1
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_all_user_metadata:1
msgid ""
"return a dict containing all the custom field metadata associated with the "
"book."
msgstr ""

# 1fdad734bddb49bd9d2f4328bdb4db59
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.get_user_metadata:1
msgid ""
"return field metadata from the object if it is there. Otherwise return None."
" field is the key name, not the label. Return a copy if requested, just in "
"case the user wants to change values in the dict."
msgstr ""

# b956f266fab540068e168807e0f50992
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_all_user_metadata:1
msgid ""
"store custom field metadata into the object. Field is the key name not the "
"label"
msgstr ""

# e3ece89349904438a959e1de5216fbd2
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.set_user_metadata:1
msgid ""
"store custom field metadata for one column into the object. Field is the key"
" name not the label"
msgstr ""

# 351e274d92c44eb093a5401830602063
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.template_to_attribute:1
msgid ""
"Takes a list [(src,dest), (src,dest)], evaluates the template in the context"
" of other, then copies the result to self[dest]. This is on a best-efforts "
"basis. Some assignments can make no sense."
msgstr ""

# b0a838a9c6834517a632e7700fa02a48
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.smart_update:1
msgid ""
"Merge the information in `other` into self. In case of conflicts, the "
"information in `other` takes precedence, unless the information in `other` "
"is NULL."
msgstr ""

# c05bc40e2c1e4ba8a225583e97c2a12b
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.format_field:1
msgid "Returns the tuple (display_name, formatted_value)"
msgstr ""

# e67e7a2c128d43909b5369b46846bf31
#: ../../../src/calibre/ebooks/metadata/book/base.pydocstring of
#: calibre.ebooks.metadata.book.base.Metadata.to_html:1
msgid "A HTML representation of this object."
msgstr ""

# 523ad4ecba4742139b99c8e91088a13b
#: ../../template_ref.rst:407
msgid "The set of standard metadata fields."
msgstr ""
